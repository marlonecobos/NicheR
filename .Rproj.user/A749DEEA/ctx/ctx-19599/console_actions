{
    "type": [
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        2,
        2,
        0,
        1,
        2,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        3,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        2,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        3,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        3,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        3,
        3,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        3,
        0,
        1,
        0,
        1,
        2,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        2,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        3,
        3,
        3,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        3,
        3,
        3,
        3,
        3,
        0,
        1,
        3,
        0,
        1,
        3,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        3,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        0,
        1,
        3,
        2
    ],
    "data": [
        "+ ",
        "+ ",
        "  if (!is.null(vs)) {",
        "+ ",
        "    if (!inherits(vs, \"NicheR_species\")) {",
        "+ ",
        "      stop(\"'vs' must be a NicheR_species object created by create_virtual_species().\")",
        "+ ",
        "    }",
        "+ ",
        "+ ",
        "    # Fill niche if missing",
        "+ ",
        "    if (is.null(niche) && !is.null(vs$niche)) {",
        "+ ",
        "      niche <- vs$niche",
        "+ ",
        "    }",
        "+ ",
        "+ ",
        "    # Fill occurrences if missing",
        "+ ",
        "    if (is.null(occ_pts) && !is.null(vs$occurrences)) {",
        "+ ",
        "      occ_pts <- vs$occurrences",
        "+ ",
        "    }",
        "+ ",
        "+ ",
        "    # Fill env_bg if missing, using suitability slot",
        "+ ",
        "    if (missing(env_bg) || is.null(env_bg)) {",
        "+ ",
        "      if (inherits(vs$suitability, \"SpatRaster\")) {",
        "+ ",
        "        env_bg <- as.data.frame.nicheR(vs$suitability)",
        "+ ",
        "      } else if (is.data.frame(vs$suitability)) {",
        "+ ",
        "        env_bg <- vs$suitability",
        "+ ",
        "      }",
        "+ ",
        "    }",
        "+ ",
        "+ ",
        "    # Fill suitable_env if missing, using suitability slot directly",
        "+ ",
        "    if (is.null(suitable_env) && !is.null(vs$suitability)) {",
        "+ ",
        "      suitable_env <- vs$suitability",
        "+ ",
        "    }",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  if (missing(env_bg) || is.null(env_bg)) {",
        "+ ",
        "    stop(\"'env_bg' must be supplied, or inferable from 'vs$suitability'.\")",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  # --- 0.1 Coerce env_bg to data.frame --------------------------------------",
        "+ ",
        "+ ",
        "  if (inherits(env_bg, \"tbl_df\")) {",
        "+ ",
        "    env_bg <- as.data.frame(env_bg)",
        "+ ",
        "  }",
        "+ ",
        "  if (inherits(env_bg, \"Raster\")) {",
        "+ ",
        "    env_bg <- terra::rast(env_bg)",
        "+ ",
        "  }",
        "+ ",
        "  if (inherits(env_bg, \"SpatRaster\")) {",
        "+ ",
        "+ ",
        "    ncell <- terra::ncell(env_bg)",
        "+ ",
        "    nlyr  <- terra::nlyr(env_bg)",
        "+ ",
        "    est_mb <- (ncell * nlyr * 8) / 1024^2  # 8 bytes per numeric",
        "+ ",
        "+ ",
        "    size_threshold_mb <- 5000",
        "+ ",
        "+ ",
        "    if (est_mb > size_threshold_mb) {",
        "+ ",
        "      stop(",
        "+ ",
        "        \"The provided 'env_bg' raster stack is large (estimated ~\",",
        "+ ",
        "        round(est_mb, 1),",
        "+ ",
        "        \" MB if converted to a full data.frame).\\n\",",
        "+ ",
        "        \"For memory safety, please convert it to a data.frame yourself, e.g. using\\n\",",
        "+ ",
        "        \"  as.data.frame.nicheR(env_bg, use_cache = TRUE)\\n\",",
        "+ ",
        "        \"and then pass that data.frame as 'env_bg'.\"",
        "+ ",
        "      )",
        "+ ",
        "    }",
        "+ ",
        "+ ",
        "    env_bg <- as.data.frame.nicheR(env_bg)",
        "+ ",
        "  }",
        "+ ",
        "  if (!is.data.frame(env_bg)) {",
        "+ ",
        "    stop(\"'env_bg' must be a data.frame or coercible to one.\")",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  # --- 0.2 Auto-infer x,y,z from env_bg if needed ---------------------------",
        "+ ",
        "+ ",
        "  if (auto_inferred) {",
        "+ ",
        "+ ",
        "    if (all(c(\"x\", \"y\") %in% names(env_bg))) {",
        "+ ",
        "      candidate_vars <- setdiff(names(env_bg), c(\"x\", \"y\"))",
        "+ ",
        "    } else {",
        "+ ",
        "      candidate_vars <- names(env_bg)",
        "+ ",
        "    }",
        "+ ",
        "+ ",
        "    if (length(candidate_vars) < 3) {",
        "+ ",
        "      stop(",
        "+ ",
        "        \"Could not infer x, y, z from 'env_bg' (fewer than 3 predictor columns after \",",
        "+ ",
        "        \"removing any 'x'/'y' coordinates). Please provide x, y, and z explicitly.\"",
        "+ ",
        "      )",
        "+ ",
        "    }",
        "+ ",
        "+ ",
        "    inferred <- candidate_vars[seq_len(3)]",
        "+ ",
        "    x <- inferred[1]",
        "+ ",
        "    y <- inferred[2]",
        "+ ",
        "    z <- inferred[3]",
        "+ ",
        "+ ",
        "    message(",
        "+ ",
        "      \"No complete x, y, z specification provided. Using predictor columns inferred from 'env_bg': \",",
        "+ ",
        "      paste(inferred, collapse = \", \")",
        "+ ",
        "    )",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  # --- 1. Validate core arguments and resolve predictor names ----------------",
        "+ ",
        "+ ",
        "  v <- validate_plot_e_space_args(",
        "+ ",
        "    env_bg, x, y, z,",
        "+ ",
        "    labels, n_bg,",
        "+ ",
        "    niche,",
        "+ ",
        "    show.pts.in       = FALSE,",
        "+ ",
        "    occ_pts           = occ_pts,",
        "+ ",
        "    show.occ.density  = show.occ.density",
        "+ ",
        "  )",
        "+ ",
        "+ ",
        "  col_x <- v$col_names[1]",
        "+ ",
        "  col_y <- v$col_names[2]",
        "+ ",
        "  col_z <- v$col_names[3]",
        "+ ",
        "+ ",
        "  # If x,y,z were inferred, remind user which columns are actually used",
        "+ ",
        "  if (auto_inferred) {",
        "+ ",
        "    message(",
        "+ ",
        "      \"Using predictor columns: \",",
        "+ ",
        "      paste(v$col_names, collapse = \", \")",
        "+ ",
        "    )",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  # Coerce occ_pts to data.frame (structure already checked in validator)",
        "+ ",
        "  if (!is.null(occ_pts)) {",
        "+ ",
        "    occ_pts <- as.data.frame(occ_pts)",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  # --- 2. Coerce suitable_env to a data.frame of inside points (if given) ----",
        "+ ",
        "+ ",
        "  pts_in <- NULL",
        "+ ",
        "  if (!is.null(suitable_env)) {",
        "+ ",
        "+ ",
        "    if (inherits(suitable_env, \"suitable_env\") ||",
        "+ ",
        "        (is.list(suitable_env) &&",
        "+ ",
        "         any(c(\"suitable_env_df\", \"suitable_env_sp\") %in% names(suitable_env)))) {",
        "+ ",
        "+ ",
        "      if (\"suitable_env_df\" %in% names(suitable_env) &&",
        "+ ",
        "          is.data.frame(suitable_env$suitable_env_df)) {",
        "+ ",
        "+ ",
        "        pts_in <- suitable_env$suitable_env_df",
        "+ ",
        "+ ",
        "      } else if (\"suitable_env_sp\" %in% names(suitable_env)) {",
        "+ ",
        "+ ",
        "        sp <- suitable_env$suitable_env_sp",
        "+ ",
        "        if (inherits(sp, \"Raster\")) sp <- terra::rast(sp)",
        "+ ",
        "+ ",
        "        if (inherits(sp, \"SpatRaster\")) {",
        "+ ",
        "          pts_in <- as.data.frame.nicheR(sp)",
        "+ ",
        "        } else if (is.list(sp) &&",
        "+ ",
        "                   length(sp) > 0 &&",
        "+ ",
        "                   all(vapply(sp, inherits, logical(1), \"SpatRaster\"))) {",
        "+ ",
        "+ ",
        "          if (\"suitable\" %in% names(sp)) {",
        "+ ",
        "            pts_in <- as.data.frame.nicheR(sp[[\"suitable\"]])",
        "+ ",
        "          } else {",
        "+ ",
        "            pts_in <- as.data.frame.nicheR(sp[[1]])",
        "+ ",
        "          }",
        "+ ",
        "        }",
        "+ ",
        "      }",
        "+ ",
        "+ ",
        "    } else if (inherits(suitable_env, \"Raster\") || inherits(suitable_env, \"SpatRaster\")) {",
        "+ ",
        "+ ",
        "      if (inherits(suitable_env, \"Raster\")) {",
        "+ ",
        "        suitable_env <- terra::rast(suitable_env)",
        "+ ",
        "      }",
        "+ ",
        "      pts_in <- as.data.frame.nicheR(suitable_env)",
        "+ ",
        "+ ",
        "    } else if (is.data.frame(suitable_env) || is.matrix(suitable_env)) {",
        "+ ",
        "+ ",
        "      pts_in <- as.data.frame(suitable_env)",
        "+ ",
        "    }",
        "+ ",
        "+ ",
        "    if (!is.null(pts_in)) {",
        "+ ",
        "      if (!all(c(col_x, col_y, col_z) %in% names(pts_in))) {",
        "+ ",
        "        warning(",
        "+ ",
        "          \"suitable_env does not contain all of x, y, z predictor columns; \",",
        "+ ",
        "          \"suitable points will not be plotted in E-space.\"",
        "+ ",
        "        )",
        "+ ",
        "        pts_in <- NULL",
        "+ ",
        "      }",
        "+ ",
        "    }",
        "+ ",
        "+ ",
        "    pts_in <- pts_in[sample.int(nrow(pts_in), size = n_bg, replace = FALSE), ]",
        "+ ",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  # --- 3. Colors / palette ---------------------------------------------------",
        "+ ",
        "+ ",
        "  palettes <- list(",
        "+ ",
        "    default = list(",
        "+ ",
        "      bg           = \"#9093A2FF\",",
        "+ ",
        "      ellipsoid    = \"#2A363BFF\",",
        "+ ",
        "      centroid     = \"#D72000FF\",",
        "+ ",
        "      tolerance    = \"#EE6100FF\",",
        "+ ",
        "      suitable_env = \"#FED789FF\",",
        "+ ",
        "      occ          = \"#B4BF3AFF\"",
        "+ ",
        "    ),",
        "+ ",
        "    palette2 = list(",
        "+ ",
        "      bg           = \"#9CA9BAFF\",",
        "+ ",
        "      ellipsoid    = \"#3D619DFF\",",
        "+ ",
        "      centroid     = \"#345084FF\",",
        "+ ",
        "      tolerance    = \"#693829FF\",",
        "+ ",
        "      suitable_env = \"#CFB267FF\",",
        "+ ",
        "      occ          = \"#A56A3EFF\"",
        "+ ",
        "    ),",
        "+ ",
        "    palette3 = list(",
        "+ ",
        "      bg           = \"#C8CCC6FF\",",
        "+ ",
        "      ellipsoid    = \"#023743FF\",",
        "+ ",
        "      centroid     = \"#72874EFF\",",
        "+ ",
        "      tolerance    = \"#476F84FF\",",
        "+ ",
        "      suitable_env = \"#FED789FF\",",
        "+ ",
        "      occ          = \"#A4BED5FF\"",
        "+ ",
        "    ),",
        "+ ",
        "    palette4 = list(",
        "+ ",
        "      bg           = \"#C0D1CEFF\",",
        "+ ",
        "      ellipsoid    = \"#859B6CFF\",",
        "+ ",
        "      centroid     = \"#B74954FF\",",
        "+ ",
        "      tolerance    = \"#A99364FF\",",
        "+ ",
        "      suitable_env = \"#C2DDB2FF\",",
        "+ ",
        "      occ          = \"#EBA49EFF\"",
        "+ ",
        "    ),",
        "+ ",
        "    palette5 = list(",
        "+ ",
        "      bg           = \"#A89F8EFF\",",
        "+ ",
        "      ellipsoid    = \"#7887A4FF\",",
        "+ ",
        "      centroid     = \"#A8CDECFF\",",
        "+ ",
        "      tolerance    = \"#682C37FF\",",
        "+ ",
        "      suitable_env = \"#F6955EFF\",",
        "+ ",
        "      occ          = \"#9B6981FF\"",
        "+ ",
        "    ),",
        "+ ",
        "    palette6 = list(",
        "+ ",
        "      bg           = \"#D3D4D8FF\",",
        "+ ",
        "      ellipsoid    = \"#731A12FF\",",
        "+ ",
        "      centroid     = \"#F2D43DFF\",",
        "+ ",
        "      tolerance    = \"#3F858CFF\",",
        "+ ",
        "      suitable_env = \"#D9814EFF\",",
        "+ ",
        "      occ          = \"#707322FF\"",
        "+ ",
        "    )",
        "+ ",
        "  )",
        "+ ",
        "+ ",
        "  if (!palette %in% names(palettes)) {",
        "+ ",
        "    stop(\"Unknown palette '\", palette, \"'.\")",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  base_colors <- palettes[[palette]]",
        "+ ",
        "+ ",
        "  if (is.null(colors)) {",
        "+ ",
        "    colors <- base_colors",
        "+ ",
        "  } else {",
        "+ ",
        "    if (is.null(names(colors))) {",
        "+ ",
        "      names(colors) <- names(base_colors)[seq_along(colors)]",
        "+ ",
        "      if (!is.list(colors)) colors <- as.list(colors)",
        "+ ",
        "      message(",
        "+ ",
        "        \"No names detected in 'colors'. \",",
        "+ ",
        "        \"Using the order provided and filling missing entries with defaults.\\n\",",
        "+ ",
        "        \"If you want to change a specific object, use a named list.\\n\",",
        "+ ",
        "        \"Available options are: \",",
        "+ ",
        "        paste(names(base_colors), collapse = \", \")",
        "+ ",
        "      )",
        "+ ",
        "    }",
        "+ ",
        "    if (!is.list(colors)) colors <- as.list(colors)",
        "+ ",
        "    colors <- utils::modifyList(base_colors, colors)",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  # Legend options ------------------------------------------------------------",
        "+ ",
        "+ ",
        "  opts <- list(",
        "+ ",
        "    background_point     = TRUE,",
        "+ ",
        "    trace_line           = !is.null(niche),",
        "+ ",
        "    centroid_point       = !is.null(niche),",
        "+ ",
        "    tolerance_range_line = !is.null(niche),",
        "+ ",
        "    suitable_point       = !is.null(pts_in),",
        "+ ",
        "    occurrence_point     = !is.null(occ_pts)",
        "+ ",
        "  )",
        "+ ",
        "+ ",
        "  legend_items <- data.frame(",
        "+ ",
        "    id       = c(\"background_point\",\"trace_line\",\"centroid_point\",",
        "+ ",
        "                 \"tolerance_range_line\",\"suitable_point\",\"occurrence_point\"),",
        "+ ",
        "    type     = c(\"point\",\"line\",\"point\",\"line\",\"point\",\"point\"),",
        "+ ",
        "    label    = c(\"Background environments\",\"Niche boundary\",\"Niche centroid\",",
        "+ ",
        "                 \"Tolerance ranges\",\"Suitable environments\",\"Occurrences\"),",
        "+ ",
        "    color    = c(colors[[\"bg\"]], colors[[\"ellipsoid\"]], colors[[\"centroid\"]],",
        "+ ",
        "                 colors[[\"tolerance\"]], colors[[\"suitable_env\"]], colors[[\"occ\"]]),",
        "+ ",
        "    linetype = c(NA, 1, NA, 2, NA, NA),",
        "+ ",
        "    stringsAsFactors = FALSE",
        "+ ",
        "  )",
        "+ ",
        "+ ",
        "  active <- logical(nrow(legend_items))",
        "+ ",
        "  for (i in seq_len(nrow(legend_items))) {",
        "+ ",
        "    active[i] <- isTRUE(opts[[ legend_items$id[i] ]])",
        "+ ",
        "  }",
        "+ ",
        "  legend_items <- legend_items[active, , drop = FALSE]",
        "+ ",
        "+ ",
        "  # Build legend plot ---------------------------------------------------------",
        "+ ",
        "+ ",
        "  if (nrow(legend_items) == 0) {",
        "+ ",
        "    legend_plot <- ggplot2::ggplot() + ggplot2::theme_void()",
        "+ ",
        "  } else {",
        "+ ",
        "    top_y   <- 2",
        "+ ",
        "    spacing <- 0.25",
        "+ ",
        "    x_point <- 0.00",
        "+ ",
        "    x_text  <- 0.1",
        "+ ",
        "    x0_line <- -0.2",
        "+ ",
        "    x1_line <-  0.00",
        "+ ",
        "+ ",
        "    legend_items <- legend_items %>%",
        "+ ",
        "      dplyr::mutate(",
        "+ ",
        "        row     = dplyr::row_number(),",
        "+ ",
        "        y       = top_y - (row - 1) * spacing,",
        "+ ",
        "        x_point = x_point,",
        "+ ",
        "        x_text  = x_text,",
        "+ ",
        "        x0_line = x0_line,",
        "+ ",
        "        x1_line = x1_line",
        "+ ",
        "      )",
        "+ ",
        "+ ",
        "    legend_base <- ggplot2::ggplot() +",
        "+ ",
        "      ggplot2::coord_cartesian(xlim = c(-0.5, 0.5), ylim = c(0, 2.5), clip = \"off\") +",
        "+ ",
        "      ggplot2::theme_void() +",
        "+ ",
        "      ggplot2::theme(legend.position = \"none\")",
        "+ ",
        "+ ",
        "    legend_plot <- legend_base +",
        "+ ",
        "      ggplot2::geom_point(",
        "+ ",
        "        data  = dplyr::filter(legend_items, type == \"point\"),",
        "+ ",
        "        ggplot2::aes(x = x_point, y = y, colour = color),",
        "+ ",
        "        size = 2",
        "+ ",
        "      ) +",
        "+ ",
        "      ggplot2::geom_segment(",
        "+ ",
        "        data  = dplyr::filter(legend_items, type == \"line\"),",
        "+ ",
        "        ggplot2::aes(x = x0_line, xend = x1_line, y = y, yend = y,",
        "+ ",
        "                     colour = color, linetype = linetype),",
        "+ ",
        "        linewidth = 0.5",
        "+ ",
        "      ) +",
        "+ ",
        "      ggplot2::geom_text(",
        "+ ",
        "        data  = legend_items,",
        "+ ",
        "        ggplot2::aes(x = x_text, y = y, label = label),",
        "+ ",
        "        hjust = 0",
        "+ ",
        "      ) +",
        "+ ",
        "      ggplot2::scale_colour_identity() +",
        "+ ",
        "      ggplot2::scale_linetype_identity()",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  # Downsample background -----------------------------------------------------",
        "+ ",
        "+ ",
        "  if (nrow(env_bg) > n_bg) {",
        "+ ",
        "    message(sprintf(\"Sampling %d of %d rows from 'env_bg' for plotting.\", n_bg, nrow(env_bg)))",
        "+ ",
        "    set.seed(rand_seed)",
        "+ ",
        "    env_bg <- env_bg[sample.int(nrow(env_bg), size = n_bg, replace = FALSE), ]",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  # ---------------------------------------------------------------------------",
        "+ ",
        "  # 3D plotting branch",
        "+ ",
        "  # ---------------------------------------------------------------------------",
        "+ ",
        "+ ",
        "  if (isTRUE(plot.3d)) {",
        "+ ",
        "+ ",
        "    p3 <- plotly::plot_ly(",
        "+ ",
        "      data = env_bg,",
        "+ ",
        "      x    = env_bg[[col_x]],",
        "+ ",
        "      y    = env_bg[[col_y]],",
        "+ ",
        "      z    = env_bg[[col_z]],",
        "+ ",
        "      type = \"scatter3d\",",
        "+ ",
        "      mode = \"markers\",",
        "+ ",
        "      marker = list(color = colors[[\"bg\"]], size = 2),",
        "+ ",
        "      name   = \"Background Environments\"",
        "+ ",
        "    ) %>%",
        "+ ",
        "      plotly::layout(",
        "+ ",
        "        title = list(text = \"Background Environments (E-space)\"),",
        "+ ",
        "        scene = list(",
        "+ ",
        "          xaxis = list(title = list(text = labels[1])),",
        "+ ",
        "          yaxis = list(title = list(text = labels[2])),",
        "+ ",
        "          zaxis = list(title = list(text = labels[3]))",
        "+ ",
        "        ),",
        "+ ",
        "        legend = list(x = 0.05, y = 0.95)",
        "+ ",
        "      )",
        "+ ",
        "+ ",
        "    # Ellipsoid surface + centroid (if present)",
        "+ ",
        "    if (!is.null(niche) && !is.null(niche$surface)) {",
        "+ ",
        "+ ",
        "      surf <- as.data.frame(niche$surface)",
        "+ ",
        "      if (ncol(surf) >= 3) {",
        "+ ",
        "        p3 <- p3 %>%",
        "+ ",
        "          plotly::add_trace(",
        "+ ",
        "            data = surf,",
        "+ ",
        "            x    = surf[[1]],",
        "+ ",
        "            y    = surf[[2]],",
        "+ ",
        "            z    = surf[[3]],",
        "+ ",
        "            type = \"scatter3d\",",
        "+ ",
        "            mode = \"lines\",",
        "+ ",
        "            line = list(color = colors[[\"ellipsoid\"]]),",
        "+ ",
        "            name = \"Niche Boundary\",",
        "+ ",
        "            inherit = FALSE",
        "+ ",
        "          )",
        "+ ",
        "      }",
        "+ ",
        "+ ",
        "      if (!is.null(niche$center) && length(niche$center) >= 3) {",
        "+ ",
        "        p3 <- p3 %>%",
        "+ ",
        "          plotly::add_markers(",
        "+ ",
        "            x = niche$center[1],",
        "+ ",
        "            y = niche$center[2],",
        "+ ",
        "            z = niche$center[3],",
        "+ ",
        "            marker = list(color = colors[[\"centroid\"]], size = 5),",
        "+ ",
        "            name   = \"Niche Centroid\"",
        "+ ",
        "          )",
        "+ ",
        "      }",
        "+ ",
        "    }",
        "+ ",
        "+ ",
        "    # Suitable points, if present",
        "+ ",
        "    if (!is.null(pts_in)) {",
        "+ ",
        "      p3 <- p3 %>%",
        "+ ",
        "        plotly::add_markers(",
        "+ ",
        "          data = pts_in,",
        "+ ",
        "          x    = pts_in[[col_x]],",
        "+ ",
        "          y    = pts_in[[col_y]],",
        "+ ",
        "          z    = pts_in[[col_z]],",
        "+ ",
        "          marker = list(color = colors[[\"suitable_env\"]], size = 3),",
        "+ ",
        "          name   = \"Suitable Environments\",",
        "+ ",
        "          inherit = FALSE",
        "+ ",
        "        )",
        "+ ",
        "    }",
        "+ ",
        "+ ",
        "    # Occurrence points in 3D",
        "+ ",
        "    if (!is.null(occ_pts)) {",
        "+ ",
        "      p3 <- p3 %>%",
        "+ ",
        "        plotly::add_markers(",
        "+ ",
        "          data = occ_pts,",
        "+ ",
        "          x    = occ_pts[[col_x]],",
        "+ ",
        "          y    = occ_pts[[col_y]],",
        "+ ",
        "          z    = occ_pts[[col_z]],",
        "+ ",
        "          marker = list(color = colors[[\"occ\"]], size = 3),",
        "+ ",
        "          name   = \"Sampled Occurrences\",",
        "+ ",
        "          inherit = FALSE",
        "+ ",
        "        ) %>%",
        "+ ",
        "        plotly::layout(",
        "+ ",
        "          title  = \"Virtual niche and sampled occurrences in E-space\",",
        "+ ",
        "          legend = list(x = 0.05, y = 0.95)",
        "+ ",
        "        )",
        "+ ",
        "    }",
        "+ ",
        "+ ",
        "    return(p3)",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  # ---------------------------------------------------------------------------",
        "+ ",
        "  # 2D plotting branch",
        "+ ",
        "  # ---------------------------------------------------------------------------",
        "+ ",
        "+ ",
        "  # Base background panels",
        "+ ",
        "  p_main_y_x <- ggplot2::ggplot(",
        "+ ",
        "    env_bg,",
        "+ ",
        "    ggplot2::aes(x = .data[[col_y]], y = .data[[col_x]])",
        "+ ",
        "  ) +",
        "+ ",
        "    ggplot2::geom_point(alpha = 0.5, color = colors[[\"bg\"]], pch = \".\") +",
        "+ ",
        "    ggplot2::theme_bw() +",
        "+ ",
        "    ggplot2::theme(axis.title = ggplot2::element_blank())",
        "+ ",
        "+ ",
        "  p_main_z_x <- ggplot2::ggplot(",
        "+ ",
        "    env_bg,",
        "+ ",
        "    ggplot2::aes(x = .data[[col_z]], y = .data[[col_x]])",
        "+ ",
        "  ) +",
        "+ ",
        "    ggplot2::geom_point(alpha = 0.5, color = colors[[\"bg\"]], pch = \".\") +",
        "+ ",
        "    ggplot2::theme_bw() +",
        "+ ",
        "    ggplot2::theme(axis.title = ggplot2::element_blank())",
        "+ ",
        "+ ",
        "  p_main_z_y <- ggplot2::ggplot(",
        "+ ",
        "    env_bg,",
        "+ ",
        "    ggplot2::aes(x = .data[[col_z]], y = .data[[col_y]])",
        "+ ",
        "  ) +",
        "+ ",
        "    ggplot2::geom_point(alpha = 0.5, color = colors[[\"bg\"]], pch = \".\") +",
        "+ ",
        "    ggplot2::theme_bw() +",
        "+ ",
        "    ggplot2::theme(axis.title = ggplot2::element_blank())",
        "+ ",
        "+ ",
        "  # Overlay suitable environments, if available (independent of niche)",
        "+ ",
        "  if (!is.null(pts_in)) {",
        "+ ",
        "+ ",
        "    p_main_y_x <- p_main_y_x +",
        "+ ",
        "      ggplot2::geom_point(",
        "+ ",
        "        data = pts_in,",
        "+ ",
        "        ggplot2::aes(",
        "+ ",
        "          x = .data[[col_y]],",
        "+ ",
        "          y = .data[[col_x]]",
        "+ ",
        "        ),",
        "+ ",
        "        color = colors[[\"suitable_env\"]],",
        "+ ",
        "        size  = 0.5",
        "+ ",
        "      )",
        "+ ",
        "+ ",
        "    p_main_z_x <- p_main_z_x +",
        "+ ",
        "      ggplot2::geom_point(",
        "+ ",
        "        data = pts_in,",
        "+ ",
        "        ggplot2::aes(",
        "+ ",
        "          x = .data[[col_z]],",
        "+ ",
        "          y = .data[[col_x]]",
        "+ ",
        "        ),",
        "+ ",
        "        color = colors[[\"suitable_env\"]],",
        "+ ",
        "        size  = 0.5",
        "+ ",
        "      )",
        "+ ",
        "+ ",
        "    p_main_z_y <- p_main_z_y +",
        "+ ",
        "      ggplot2::geom_point(",
        "+ ",
        "        data = pts_in,",
        "+ ",
        "        ggplot2::aes(",
        "+ ",
        "          x = .data[[col_z]],",
        "+ ",
        "          y = .data[[col_y]]",
        "+ ",
        "        ),",
        "+ ",
        "        color = colors[[\"suitable_env\"]],",
        "+ ",
        "        size  = 0.5",
        "+ ",
        "      )",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  # Overlay occurrence points, if available (independent of niche)",
        "+ ",
        "  if (!is.null(occ_pts)) {",
        "+ ",
        "+ ",
        "    p_main_y_x <- p_main_y_x +",
        "+ ",
        "      ggplot2::geom_point(",
        "+ ",
        "        data = occ_pts,",
        "+ ",
        "        ggplot2::aes(",
        "+ ",
        "          x = .data[[col_y]],",
        "+ ",
        "          y = .data[[col_x]]",
        "+ ",
        "        ),",
        "+ ",
        "        color = colors[[\"occ\"]],",
        "+ ",
        "        size  = 0.5",
        "+ ",
        "      )",
        "+ ",
        "+ ",
        "    p_main_z_x <- p_main_z_x +",
        "+ ",
        "      ggplot2::geom_point(",
        "+ ",
        "        data = occ_pts,",
        "+ ",
        "        ggplot2::aes(",
        "+ ",
        "          x = .data[[col_z]],",
        "+ ",
        "          y = .data[[col_x]]",
        "+ ",
        "        ),",
        "+ ",
        "        color = colors[[\"occ\"]],",
        "+ ",
        "        size  = 0.5",
        "+ ",
        "      )",
        "+ ",
        "+ ",
        "    p_main_z_y <- p_main_z_y +",
        "+ ",
        "      ggplot2::geom_point(",
        "+ ",
        "        data = occ_pts,",
        "+ ",
        "        ggplot2::aes(",
        "+ ",
        "          x = .data[[col_z]],",
        "+ ",
        "          y = .data[[col_y]]",
        "+ ",
        "        ),",
        "+ ",
        "        color = colors[[\"occ\"]],",
        "+ ",
        "        size  = 0.5",
        "+ ",
        "      )",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  # Axis label grobs",
        "+ ",
        "  x_name <- ggplot2::ggplot() + ggplot2::theme_void() +",
        "+ ",
        "    ggplot2::geom_text(ggplot2::aes(0, 0, label = labels[1]),",
        "+ ",
        "                       fontface = \"bold\")",
        "+ ",
        "  y_name <- ggplot2::ggplot() + ggplot2::theme_void() +",
        "+ ",
        "    ggplot2::geom_text(ggplot2::aes(0, 0, label = labels[2]),",
        "+ ",
        "                       fontface = \"bold\")",
        "+ ",
        "  z_name <- ggplot2::ggplot() + ggplot2::theme_void() +",
        "+ ",
        "    ggplot2::geom_text(ggplot2::aes(0, 0, label = labels[3]),",
        "+ ",
        "                       fontface = \"bold\")",
        "+ ",
        "+ ",
        "  # Start with panels that already include bg + suitable + occ",
        "+ ",
        "  panel_y_x <- p_main_y_x",
        "+ ",
        "  panel_z_x <- p_main_z_x",
        "+ ",
        "  panel_z_y <- p_main_z_y",
        "+ ",
        "+ ",
        "  angle_warn <- NULL",
        "+ ",
        "+ ",
        "  # --- Ellipsoid overlays and extras (2D), only if niche provided -----------",
        "+ ",
        "+ ",
        "  if (!is.null(niche)) {",
        "+ ",
        "+ ",
        "    center_y_x <- c(niche$center[2], niche$center[1])",
        "+ ",
        "    axes_y_x   <- c(niche$axes[2],   niche$axes[1])",
        "+ ",
        "    angle_y_x  <- c(niche$angles[2], niche$angles[1])",
        "+ ",
        "+ ",
        "    center_z_x <- c(niche$center[3], niche$center[1])",
        "+ ",
        "    axes_z_x   <- c(niche$axes[3],   niche$axes[1])",
        "+ ",
        "    angle_z_x  <- c(niche$angles[3], niche$angles[1])",
        "+ ",
        "+ ",
        "    center_z_y <- c(niche$center[3], niche$center[2])",
        "+ ",
        "    axes_z_y   <- c(niche$axes[3],   niche$axes[2])",
        "+ ",
        "    angle_z_y  <- c(niche$angles[3], niche$angles[2])",
        "+ ",
        "+ ",
        "    ell2d_y_x <- build_ellps(center = center_y_x, axes = axes_y_x, angles = angle_y_x)",
        "+ ",
        "    ell2d_z_x <- build_ellps(center = center_z_x, axes = axes_z_x, angles = angle_z_x)",
        "+ ",
        "    ell2d_z_y <- build_ellps(center = center_z_y, axes = axes_z_y, angles = angle_z_y)",
        "+ ",
        "+ ",
        "    if (!is.null(niche$angles) && any(niche$angles != 0)) {",
        "+ ",
        "      angle_warn <- ggplot2::ggplot() + ggplot2::theme_void() +",
        "+ ",
        "        ggplot2::geom_text(",
        "+ ",
        "          ggplot2::aes(",
        "+ ",
        "            0, 0,",
        "+ ",
        "            label = \"Note: The ellipsoid is angled; its shape may appear distorted and some points may fall outside due to dimensionality.\"",
        "+ ",
        "          ),",
        "+ ",
        "          size = 2",
        "+ ",
        "        )",
        "+ ",
        "    }",
        "+ ",
        "+ ",
        "    # Ellipse boundaries + axes + centroid -----------------------------------",
        "+ ",
        "+ ",
        "    panel_y_x <- panel_y_x +",
        "+ ",
        "      ggplot2::geom_path(",
        "+ ",
        "        data   = ell2d_y_x$surface,",
        "+ ",
        "        ggplot2::aes(x, y),",
        "+ ",
        "        color = colors[[\"ellipsoid\"]],",
        "+ ",
        "        linewidth = 0.5",
        "+ ",
        "      ) +",
        "+ ",
        "      ggplot2::annotate(",
        "+ ",
        "        \"segment\",",
        "+ ",
        "        x    = ell2d_y_x$center[1] - ell2d_y_x$axes[1],",
        "+ ",
        "        xend = ell2d_y_x$center[1] + ell2d_y_x$axes[1],",
        "+ ",
        "        y    = ell2d_y_x$center[2],",
        "+ ",
        "        yend = ell2d_y_x$center[2],",
        "+ ",
        "        color = colors[[\"tolerance\"]],",
        "+ ",
        "        linetype = \"dashed\"",
        "+ ",
        "      ) +",
        "+ ",
        "      ggplot2::annotate(",
        "+ ",
        "        \"segment\",",
        "+ ",
        "        y    = ell2d_y_x$center[2] - ell2d_y_x$axes[2],",
        "+ ",
        "        yend = ell2d_y_x$center[2] + ell2d_y_x$axes[2],",
        "+ ",
        "        x    = ell2d_y_x$center[1],",
        "+ ",
        "        xend = ell2d_y_x$center[1],",
        "+ ",
        "        color = colors[[\"tolerance\"]],",
        "+ ",
        "        linetype = \"dashed\"",
        "+ ",
        "      ) +",
        "+ ",
        "      ggplot2::annotate(",
        "+ ",
        "        \"point\",",
        "+ ",
        "        x = ell2d_y_x$center[1],",
        "+ ",
        "        y = ell2d_y_x$center[2],",
        "+ ",
        "        color = colors[[\"centroid\"]],",
        "+ ",
        "        size  = 2",
        "+ ",
        "      )",
        "+ ",
        "+ ",
        "    panel_z_x <- panel_z_x +",
        "+ ",
        "      ggplot2::geom_path(",
        "+ ",
        "        data   = ell2d_z_x$surface,",
        "+ ",
        "        ggplot2::aes(x, y),",
        "+ ",
        "        color = colors[[\"ellipsoid\"]],",
        "+ ",
        "        linewidth = 0.5",
        "+ ",
        "      ) +",
        "+ ",
        "      ggplot2::annotate(",
        "+ ",
        "        \"segment\",",
        "+ ",
        "        x    = ell2d_z_x$center[1] - ell2d_z_x$axes[1],",
        "+ ",
        "        xend = ell2d_z_x$center[1] + ell2d_z_x$axes[1],",
        "+ ",
        "        y    = ell2d_z_x$center[2],",
        "+ ",
        "        yend = ell2d_z_x$center[2],",
        "+ ",
        "        color = colors[[\"tolerance\"]],",
        "+ ",
        "        linetype = \"dashed\"",
        "+ ",
        "      ) +",
        "+ ",
        "      ggplot2::annotate(",
        "+ ",
        "        \"segment\",",
        "+ ",
        "        y    = ell2d_z_x$center[2] - ell2d_z_x$axes[2],",
        "+ ",
        "        yend = ell2d_z_x$center[2] + ell2d_z_x$axes[2],",
        "+ ",
        "        x    = ell2d_z_x$center[1],",
        "+ ",
        "        xend = ell2d_z_x$center[1],",
        "+ ",
        "        color = colors[[\"tolerance\"]],",
        "+ ",
        "        linetype = \"dashed\"",
        "+ ",
        "      ) +",
        "+ ",
        "      ggplot2::annotate(",
        "+ ",
        "        \"point\",",
        "+ ",
        "        x = ell2d_z_x$center[1],",
        "+ ",
        "        y = ell2d_z_x$center[2],",
        "+ ",
        "        color = colors[[\"centroid\"]],",
        "+ ",
        "        size  = 2",
        "+ ",
        "      )",
        "+ ",
        "+ ",
        "    panel_z_y <- panel_z_y +",
        "+ ",
        "      ggplot2::geom_path(",
        "+ ",
        "        data   = ell2d_z_y$surface,",
        "+ ",
        "        ggplot2::aes(x, y),",
        "+ ",
        "        color = colors[[\"ellipsoid\"]],",
        "+ ",
        "        linewidth = 0.5",
        "+ ",
        "      ) +",
        "+ ",
        "      ggplot2::annotate(",
        "+ ",
        "        \"segment\",",
        "+ ",
        "        x    = ell2d_z_y$center[1] - ell2d_z_y$axes[1],",
        "+ ",
        "        xend = ell2d_z_y$center[1] + ell2d_z_y$axes[1],",
        "+ ",
        "        y    = ell2d_z_y$center[2],",
        "+ ",
        "        yend = ell2d_z_y$center[2],",
        "+ ",
        "        color = colors[[\"tolerance\"]],",
        "+ ",
        "        linetype = \"dashed\"",
        "+ ",
        "      ) +",
        "+ ",
        "      ggplot2::annotate(",
        "+ ",
        "        \"segment\",",
        "+ ",
        "        y    = ell2d_z_y$center[2] - ell2d_z_y$axes[2],",
        "+ ",
        "        yend = ell2d_z_y$center[2] + ell2d_z_y$axes[2],",
        "+ ",
        "        x    = ell2d_z_y$center[1],",
        "+ ",
        "        xend = ell2d_z_y$center[1],",
        "+ ",
        "        color = colors[[\"tolerance\"]],",
        "+ ",
        "        linetype = \"dashed\"",
        "+ ",
        "      ) +",
        "+ ",
        "      ggplot2::annotate(",
        "+ ",
        "        \"point\",",
        "+ ",
        "        x = ell2d_z_y$center[1],",
        "+ ",
        "        y = ell2d_z_y$center[2],",
        "+ ",
        "        color = colors[[\"centroid\"]],",
        "+ ",
        "        size  = 2",
        "+ ",
        "      )",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  # Base 3 x 3 layout (without density panels) -------------------------------",
        "+ ",
        "+ ",
        "  return_plot <- ggpubr::ggarrange(",
        "+ ",
        "    x_name,      panel_y_x,   panel_z_x,",
        "+ ",
        "    legend_plot, y_name,      panel_z_y,",
        "+ ",
        "    NULL,        angle_warn,  z_name,",
        "+ ",
        "    ncol = 3, nrow = 3,",
        "+ ",
        "    widths  = c(0.15, 0.425, 0.425),",
        "+ ",
        "    heights = c(0.45, 0.45, 0.15)",
        "+ ",
        "  )",
        "+ ",
        "+ ",
        "  # Optional occurrence density panels ---------------------------------------",
        "+ ",
        "+ ",
        "  if (isTRUE(show.occ.density) && !is.null(occ_pts)) {",
        "+ ",
        "+ ",
        "    rng_z <- range(env_bg[[col_z]], na.rm = TRUE)",
        "+ ",
        "    rng_y <- range(env_bg[[col_y]], na.rm = TRUE)",
        "+ ",
        "    rng_x <- range(env_bg[[col_x]], na.rm = TRUE)",
        "+ ",
        "+ ",
        "    env_z_top <- ggplot2::ggplot(occ_pts, ggplot2::aes(x = .data[[col_z]])) +",
        "+ ",
        "      ggplot2::geom_density(fill = colors[[\"occ\"]], alpha = 0.6) +",
        "+ ",
        "      ggplot2::scale_x_continuous(limits = rng_z) +",
        "+ ",
        "      ggplot2::scale_y_continuous(n.breaks = 3) +",
        "+ ",
        "      ggplot2::theme_minimal() +",
        "+ ",
        "      ggplot2::theme(",
        "+ ",
        "        axis.text.x  = ggplot2::element_blank(),",
        "+ ",
        "        axis.title.x = ggplot2::element_blank(),",
        "+ ",
        "        axis.title.y = ggplot2::element_blank(),",
        "+ ",
        "        axis.text.y  = ggplot2::element_text(size = 5)",
        "+ ",
        "      )",
        "+ ",
        "+ ",
        "    env_y_top <- ggplot2::ggplot(occ_pts, ggplot2::aes(x = .data[[col_y]])) +",
        "+ ",
        "      ggplot2::geom_density(fill = colors[[\"occ\"]], alpha = 0.6) +",
        "+ ",
        "      ggplot2::scale_x_continuous(limits = rng_y) +",
        "+ ",
        "      ggplot2::scale_y_continuous(n.breaks = 3) +",
        "+ ",
        "      ggplot2::theme_minimal() +",
        "+ ",
        "      ggplot2::theme(",
        "+ ",
        "        axis.text.x  = ggplot2::element_blank(),",
        "+ ",
        "        axis.title.x = ggplot2::element_blank(),",
        "+ ",
        "        axis.title.y = ggplot2::element_blank(),",
        "+ ",
        "        axis.text.y  = ggplot2::element_text(size = 5)",
        "+ ",
        "      )",
        "+ ",
        "+ ",
        "    env_x_right <- ggplot2::ggplot(occ_pts, ggplot2::aes(x = .data[[col_x]])) +",
        "+ ",
        "      ggplot2::geom_density(fill = colors[[\"occ\"]], alpha = 0.6) +",
        "+ ",
        "      ggplot2::scale_x_continuous(limits = rng_x) +",
        "+ ",
        "      ggplot2::coord_flip() +",
        "+ ",
        "      ggplot2::scale_y_continuous(n.breaks = 3) +",
        "+ ",
        "      ggplot2::theme_minimal() +",
        "+ ",
        "      ggplot2::theme(",
        "+ ",
        "        axis.text.y  = ggplot2::element_blank(),",
        "+ ",
        "        axis.title.y = ggplot2::element_blank(),",
        "+ ",
        "        axis.title.x = ggplot2::element_blank(),",
        "+ ",
        "        axis.text.x  = ggplot2::element_text(size = 5)",
        "+ ",
        "      )",
        "+ ",
        "+ ",
        "    env_y_right <- ggplot2::ggplot(occ_pts, ggplot2::aes(x = .data[[col_y]])) +",
        "+ ",
        "      ggplot2::geom_density(fill = colors[[\"occ\"]], alpha = 0.6) +",
        "+ ",
        "      ggplot2::scale_x_continuous(limits = rng_y) +",
        "+ ",
        "      ggplot2::coord_flip() +",
        "+ ",
        "      ggplot2::scale_y_continuous(n.breaks = 3) +",
        "+ ",
        "      ggplot2::theme_minimal() +",
        "+ ",
        "      ggplot2::theme(",
        "+ ",
        "        axis.text.y  = ggplot2::element_blank(),",
        "+ ",
        "        axis.title.y = ggplot2::element_blank(),",
        "+ ",
        "        axis.title.x = ggplot2::element_blank(),",
        "+ ",
        "        axis.text.x  = ggplot2::element_text(size = 5)",
        "+ ",
        "      )",
        "+ ",
        "+ ",
        "    return_plot <- ggpubr::ggarrange(",
        "+ ",
        "      NULL,        env_y_top,  env_z_top,  NULL,",
        "+ ",
        "      x_name,      panel_y_x,  panel_z_x,  env_x_right,",
        "+ ",
        "      legend_plot, y_name,     panel_z_y,  env_y_right,",
        "+ ",
        "      NULL,        angle_warn, z_name,     NULL,",
        "+ ",
        "      ncol = 4, nrow = 4,",
        "+ ",
        "      widths  = c(0.1, 0.4, 0.4, 0.1),",
        "+ ",
        "      heights = c(0.1, 0.4, 0.4, 0.1)",
        "+ ",
        "    )",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  return(return_plot)",
        "+ ",
        "}",
        "> ",
        "suitbale_area",
        "Suitable environment object:\n  Spatial rasters (list):\n   - suitable :\nclass       : SpatRaster \nsize        : 14048, 38985, 1  (nrow, ncol, nlyr)\nresolution  : 0.008983153, 0.008983153  (x, y)\nextent      : -170.5541, 179.6541, -55.04876, 71.14657  (xmin, xmax, ymin, ymax)\ncoord. ref. :  \nsource(s)   : memory\nname        : suitable \nmin value   :        1 \nmax value   :        1 \n\n  Data frame (showing first 6 rows):\n                x        y    pr_sum tmmn_min tmmx_max\n13781812 27.85227 70.94445 0.810771",
        "3 25.24837 29.42946\n13781813 27.86125 70.94445 0.8107713 25.24837 29.42946\n13781814 27.87023 70.94445 0.8107713 25.24837 29.42946\n13781815 27.87921 70.94445 0.8107713 25.24837 29.42946\n13781816 27.88820 70.94445 0.8107713 25.24837 29.42946\n13781817 27.89718 70.94445 0.8107713 25.24837 29.42946\n",
        "> ",
        "nrow(suitbale_area$suitable_env_df)",
        "[1] 8890236\n",
        "> ",
        "plot_e_space(env_bg = env_df_db,",
        "+ ",
        "             niche = my_niche_large,",
        "+ ",
        "             suitable_env = suitbale_area,",
        "+ ",
        "             x = \"pr_sum\", y = \"tmmn_min\", z = \"tmmx_max\")",
        "\u001BG1;\u001BH1;Error\u001Bh in validate_plot_e_space_args(env_bg, x, y, z, labels, n_bg, niche,  : \n  unused argument (show.pts.in = FALSE)\n\u001Bg",
        "> ",
        "#' Plot Environmental Space with Optional Ellipsoid Overlays",
        "> ",
        "#'",
        "> ",
        "#' Produces pairwise views of a 3D environmental space with optional overlays of a",
        "> ",
        "#' virtual niche ellipsoid and occurrence points. In 2D mode, it returns a grid",
        "> ",
        "#' of pairwise scatterplots with projected ellipse boundaries. In 3D mode, it",
        "> ",
        "#' returns an interactive \\code{plotly} scatterplot.",
        "> ",
        "#'",
        "> ",
        "#' @param env_bg A \\code{data.frame} (or coercible object) of background environments",
        "> ",
        "#'   with at least three numeric predictor columns. These columns must contain",
        "> ",
        "#'   the variables referenced by \\code{x}, \\code{y}, and \\code{z}. If \\code{env_bg}",
        "> ",
        "#'   is a \\code{terra::SpatRaster} or \\code{raster::Raster*}, it is converted with",
        "> ",
        "#'   \\code{as.data.frame.nicheR()}. If \\code{NULL}, a \\code{NicheR_species} object",
        "> ",
        "#'   supplied via \\code{vs} can be used to infer \\code{env_bg} from its",
        "> ",
        "#'   \\code{suitability} slot.",
        "> ",
        "#' @param x,y,z Column specifications for the three predictors to display. Each may",
        "> ",
        "#'   be a single column name (character string) or a single 1-based integer index",
        "> ",
        "#'   into \\code{env_bg}. If any of \\code{x}, \\code{y}, or \\code{z} are omitted,",
        "> ",
        "#'   the function attempts to infer them from the predictor columns in \\code{env_bg}",
        "> ",
        "#'   (excluding \\code{\"x\"} and \\code{\"y\"} coordinate columns if present).",
        "> ",
        "#' @param labels Character vector of length 3 giving axis labels for the x, y,",
        "> ",
        "#'   and z variables in display order. Defaults to \\code{c(\"ENV 1\", \"ENV 2\", \"ENV 3\")}.",
        "> ",
        "#' @param n_bg Positive integer giving the maximum number of background rows to plot.",
        "> ",
        "#'   If \\code{nrow(env_bg)} is greater than \\code{n_bg}, a random subset of size",
        "> ",
        "#'   \\code{n_bg} is drawn. Using a large \\code{n_bg} may slow plotting.",
        "> ",
        "#' @param niche Optional object of class \\code{ellipsoid} describing the niche. If",
        "> ",
        "#'   provided, its boundary and center will be plotted. For 2D plots, the",
        "> ",
        "#'   object should contain \\code{niche$angles}. If \\code{NULL} and a",
        "> ",
        "#'   \\code{NicheR_species} object is supplied via \\code{vs}, \\code{niche} is",
        "> ",
        "#'   filled from \\code{vs$niche}.",
        "> ",
        "#' @param suitable_env Optional suitable environment object (data.frame,",
        "> ",
        "#'   \\code{suitable_env} list, or SpatRaster), typically produced by",
        "> ",
        "#'   \\code{\\link{get_suitable_env}}. When provided, points inside the ellipsoid",
        "> ",
        "#'   are plotted in E space.",
        "> ",
        "#' @param occ_pts Optional \\code{data.frame} of occurrence points that includes the",
        "> ",
        "#'   same predictor columns used for \\code{x}, \\code{y}, and \\code{z}. These are",
        "> ",
        "#'   overplotted if supplied. If \\code{NULL} and a \\code{NicheR_species} object",
        "> ",
        "#'   is supplied via \\code{vs}, this is filled from \\code{vs$occurrences} when available.",
        "> ",
        "#' @param rand_seed Integer used to set the random number generator seed for",
        "> ",
        "#'   reproducible background downsampling.",
        "> ",
        "#' @param show.occ.density Logical. If \\code{TRUE} and \\code{occ_pts} is provided,",
        "> ",
        "#'   adds marginal density panels for each variable (2D plots only;",
        "> ",
        "#'   \\code{plot.3d = FALSE}).",
        "> ",
        "#' @param plot.3d Logical. If \\code{TRUE}, returns an interactive \\code{plotly} 3D scatter",
        "> ",
        "#'   plot. If \\code{FALSE} (the default), returns a static \\code{ggpubr} grid of 2D panels.",
        "> ",
        "#' @param colors Optional named list of colors to override the default palette.",
        "> ",
        "#'   Valid names are: \\code{bg}, \\code{ellipsoid}, \\code{centroid}, \\code{tolerance},",
        "> ",
        "#'   \\code{suitable_env}, \\code{occ}.",
        "> ",
        "#' @param palette Character name of the internal palette to use.",
        "> ",
        "#'   One of \\code{\"default\"}, \\code{\"palette2\"}, ..., \\code{\"palette6\"}.",
        "> ",
        "#' @param vs Optional \\code{NicheR_species} object returned by",
        "> ",
        "#'   \\code{\\link{create_virtual_species}}. If provided, \\code{niche},",
        "> ",
        "#'   \\code{occ_pts}, \\code{env_bg}, and \\code{suitable_env} are auto-filled from",
        "> ",
        "#'   this object when they are not supplied explicitly.",
        "> ",
        "#'",
        "> ",
        "#' @return",
        "> ",
        "#' If \\code{plot.3d = TRUE}, a \\code{plotly} object.",
        "> ",
        "#' If \\code{plot.3d = FALSE}, a \\code{ggpubr} object containing arranged",
        "> ",
        "#' \\code{ggplot2} panels.",
        "> ",
        "#'",
        "> ",
        "#' @family plotting functions",
        "> ",
        "#' @seealso \\code{\\link{validate_plot_e_space_args}}, \\code{\\link{build_ellps}},",
        "> ",
        "#'   \\code{\\link{get_suitable_env}}, \\code{\\link{create_virtual_species}}",
        "> ",
        "#' @import RColorBrewer ggplot2 dplyr",
        "> ",
        "#' @importFrom rlang .data",
        "> ",
        "#' @export",
        "> ",
        "plot_e_space <- function(env_bg,",
        "+ ",
        "                         x, y, z,",
        "+ ",
        "                         labels = c(\"ENV 1\", \"ENV 2\", \"ENV 3\"),",
        "+ ",
        "                         n_bg = 10000,",
        "+ ",
        "                         niche = NULL,",
        "+ ",
        "                         suitable_env = NULL,",
        "+ ",
        "                         occ_pts = NULL,",
        "+ ",
        "                         rand_seed = 1234,",
        "+ ",
        "                         show.occ.density = FALSE, # only for 2D plots",
        "+ ",
        "                         plot.3d = FALSE,",
        "+ ",
        "                         colors = NULL,",
        "+ ",
        "                         palette = \"default\",",
        "+ ",
        "                         vs = NULL) {",
        "+ ",
        "+ ",
        "  # Track whether x,y,z were auto-inferred",
        "+ ",
        "  x_missing <- missing(x)",
        "+ ",
        "  y_missing <- missing(y)",
        "+ ",
        "  z_missing <- missing(z)",
        "+ ",
        "  auto_inferred <- x_missing || y_missing || z_missing",
        "+ ",
        "+ ",
        "  # --- 0. Optionally fill from NicheR_species object -------------------------",
        "+ ",
        "+ ",
        "  if (!is.null(vs)) {",
        "+ ",
        "    if (!inherits(vs, \"NicheR_species\")) {",
        "+ ",
        "      stop(\"'vs' must be a NicheR_species object created by create_virtual_species().\")",
        "+ ",
        "    }",
        "+ ",
        "+ ",
        "    # Fill niche if missing",
        "+ ",
        "    if (is.null(niche) && !is.null(vs$niche)) {",
        "+ ",
        "      niche <- vs$niche",
        "+ ",
        "    }",
        "+ ",
        "+ ",
        "    # Fill occurrences if missing",
        "+ ",
        "    if (is.null(occ_pts) && !is.null(vs$occurrences)) {",
        "+ ",
        "      occ_pts <- vs$occurrences",
        "+ ",
        "    }",
        "+ ",
        "+ ",
        "    # Fill env_bg if missing, using suitability slot",
        "+ ",
        "    if (missing(env_bg) || is.null(env_bg)) {",
        "+ ",
        "      if (inherits(vs$suitability, \"SpatRaster\")) {",
        "+ ",
        "        env_bg <- as.data.frame.nicheR(vs$suitability)",
        "+ ",
        "      } else if (is.data.frame(vs$suitability)) {",
        "+ ",
        "        env_bg <- vs$suitability",
        "+ ",
        "      }",
        "+ ",
        "    }",
        "+ ",
        "+ ",
        "    # Fill suitable_env if missing, using suitability slot directly",
        "+ ",
        "    if (is.null(suitable_env) && !is.null(vs$suitability)) {",
        "+ ",
        "      suitable_env <- vs$suitability",
        "+ ",
        "    }",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  if (missing(env_bg) || is.null(env_bg)) {",
        "+ ",
        "    stop(\"'env_bg' must be supplied, or inferable from 'vs$suitability'.\")",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  # --- 0.1 Coerce env_bg to data.frame --------------------------------------",
        "+ ",
        "+ ",
        "  if (inherits(env_bg, \"tbl_df\")) {",
        "+ ",
        "    env_bg <- as.data.frame(env_bg)",
        "+ ",
        "  }",
        "+ ",
        "  if (inherits(env_bg, \"Raster\")) {",
        "+ ",
        "    env_bg <- terra::rast(env_bg)",
        "+ ",
        "  }",
        "+ ",
        "  if (inherits(env_bg, \"SpatRaster\")) {",
        "+ ",
        "+ ",
        "    ncell <- terra::ncell(env_bg)",
        "+ ",
        "    nlyr  <- terra::nlyr(env_bg)",
        "+ ",
        "    est_mb <- (ncell * nlyr * 8) / 1024^2  # 8 bytes per numeric",
        "+ ",
        "+ ",
        "    size_threshold_mb <- 5000",
        "+ ",
        "+ ",
        "    if (est_mb > size_threshold_mb) {",
        "+ ",
        "      stop(",
        "+ ",
        "        \"The provided 'env_bg' raster stack is large (estimated ~\",",
        "+ ",
        "        round(est_mb, 1),",
        "+ ",
        "        \" MB if converted to a full data.frame).\\n\",",
        "+ ",
        "        \"For memory safety, please convert it to a data.frame yourself, e.g. using\\n\",",
        "+ ",
        "        \"  as.data.frame.nicheR(env_bg, use_cache = TRUE)\\n\",",
        "+ ",
        "        \"and then pass that data.frame as 'env_bg'.\"",
        "+ ",
        "      )",
        "+ ",
        "    }",
        "+ ",
        "+ ",
        "    env_bg <- as.data.frame.nicheR(env_bg)",
        "+ ",
        "+ ",
        "  }",
        "+ ",
        "  if (!is.data.frame(env_bg)) {",
        "+ ",
        "    stop(\"'env_bg' must be a data.frame or coercible to one.\")",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  # --- 0.2 Auto-infer x,y,z from env_bg if needed ---------------------------",
        "+ ",
        "+ ",
        "  if (auto_inferred) {",
        "+ ",
        "+ ",
        "    if (all(c(\"x\", \"y\") %in% names(env_bg))) {",
        "+ ",
        "      candidate_vars <- setdiff(names(env_bg), c(\"x\", \"y\"))",
        "+ ",
        "    } else {",
        "+ ",
        "      candidate_vars <- names(env_bg)",
        "+ ",
        "    }",
        "+ ",
        "+ ",
        "    if (length(candidate_vars) < 3) {",
        "+ ",
        "      stop(",
        "+ ",
        "        \"Could not infer x, y, z from 'env_bg' (fewer than 3 predictor columns after \",",
        "+ ",
        "        \"removing any 'x'/'y' coordinates). Please provide x, y, and z explicitly.\"",
        "+ ",
        "      )",
        "+ ",
        "    }",
        "+ ",
        "+ ",
        "    # Use first 3 predictor columns as x,y,z",
        "+ ",
        "    inferred <- candidate_vars[seq_len(3)]",
        "+ ",
        "    x <- inferred[1]",
        "+ ",
        "    y <- inferred[2]",
        "+ ",
        "    z <- inferred[3]",
        "+ ",
        "+ ",
        "    message(",
        "+ ",
        "      \"No complete x, y, z specification provided. Using predictor columns inferred from 'env_bg': \",",
        "+ ",
        "      paste(inferred, collapse = \", \")",
        "+ ",
        "    )",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  # --- 1. Validate core arguments and resolve predictor names ----------------",
        "+ ",
        "+ ",
        "  v <- validate_plot_e_space_args(",
        "+ ",
        "    env_bg, x, y, z,",
        "+ ",
        "    labels, n_bg,",
        "+ ",
        "    niche,",
        "+ ",
        "    occ_pts, show.occ.density",
        "+ ",
        "  )",
        "+ ",
        "+ ",
        "  col_x <- v$col_names[1]",
        "+ ",
        "  col_y <- v$col_names[2]",
        "+ ",
        "  col_z <- v$col_names[3]",
        "+ ",
        "+ ",
        "  # If user did provide x,y,z but as indices/variants, still nice to tell them",
        "+ ",
        "  if (auto_inferred) {",
        "+ ",
        "    message(",
        "+ ",
        "      \"Using predictor columns: \",",
        "+ ",
        "      paste(v$col_names, collapse = \", \")",
        "+ ",
        "    )",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  # Coerce occ_pts to data.frame (structure already checked in validator)",
        "+ ",
        "  if (!is.null(occ_pts)) {",
        "+ ",
        "    occ_pts <- as.data.frame(occ_pts)",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  # --- 2. Coerce suitable_env to a data.frame of inside points (if given) ----",
        "+ ",
        "+ ",
        "  pts_in <- NULL",
        "+ ",
        "  if (!is.null(suitable_env)) {",
        "+ ",
        "+ ",
        "    if (inherits(suitable_env, \"suitable_env\") ||",
        "+ ",
        "        (is.list(suitable_env) &&",
        "+ ",
        "         any(c(\"suitable_env_df\", \"suitable_env_sp\") %in% names(suitable_env)))) {",
        "+ ",
        "+ ",
        "      if (\"suitable_env_df\" %in% names(suitable_env) &&",
        "+ ",
        "          is.data.frame(suitable_env$suitable_env_df)) {",
        "+ ",
        "+ ",
        "        pts_in <- suitable_env$suitable_env_df",
        "+ ",
        "+ ",
        "      } else if (\"suitable_env_sp\" %in% names(suitable_env)) {",
        "+ ",
        "+ ",
        "        sp <- suitable_env$suitable_env_sp",
        "+ ",
        "        if (inherits(sp, \"Raster\")) sp <- terra::rast(sp)",
        "+ ",
        "+ ",
        "        if (inherits(sp, \"SpatRaster\")) {",
        "+ ",
        "          pts_in <- as.data.frame.nicheR(sp)",
        "+ ",
        "        } else if (is.list(sp) &&",
        "+ ",
        "                   length(sp) > 0 &&",
        "+ ",
        "                   all(vapply(sp, inherits, logical(1), \"SpatRaster\"))) {",
        "+ ",
        "+ ",
        "          if (\"suitable\" %in% names(sp)) {",
        "+ ",
        "            pts_in <- as.data.frame.nicheR(sp[[\"suitable\"]])",
        "+ ",
        "          } else {",
        "+ ",
        "            pts_in <- as.data.frame.nicheR(sp[[1]])",
        "+ ",
        "          }",
        "+ ",
        "        }",
        "+ ",
        "      }",
        "+ ",
        "+ ",
        "    } else if (inherits(suitable_env, \"Raster\") || inherits(suitable_env, \"SpatRaster\")) {",
        "+ ",
        "+ ",
        "      if (inherits(suitable_env, \"Raster\")) {",
        "+ ",
        "        suitable_env <- terra::rast(suitable_env)",
        "+ ",
        "      }",
        "+ ",
        "      pts_in <- as.data.frame.nicheR(suitable_env)",
        "+ ",
        "+ ",
        "    } else if (is.data.frame(suitable_env) || is.matrix(suitable_env)) {",
        "+ ",
        "+ ",
        "      pts_in <- as.data.frame(suitable_env)",
        "+ ",
        "    }",
        "+ ",
        "+ ",
        "    if (!is.null(pts_in)) {",
        "+ ",
        "      if (!all(c(col_x, col_y, col_z) %in% names(pts_in))) {",
        "+ ",
        "        warning(",
        "+ ",
        "          \"suitable_env does not contain all of x, y, z predictor columns; \",",
        "+ ",
        "          \"suitable points will not be plotted in E-space.\"",
        "+ ",
        "        )",
        "+ ",
        "        pts_in <- NULL",
        "+ ",
        "      }",
        "+ ",
        "+ ",
        "      if (nrow(pts_in) > n_bg) {",
        "+ ",
        "        message(sprintf(\"Sampling %d of %d rows from 'suitable_env' for plotting.\", n_bg, nrow(pts_in)))",
        "+ ",
        "        set.seed(rand_seed)",
        "+ ",
        "        pts_in <- pts_in[sample.int(nrow(pts_in), size = n_bg, replace = FALSE), ]",
        "+ ",
        "      }",
        "+ ",
        "+ ",
        "    }",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  # --- 3. Colors / palette ---------------------------------------------------",
        "+ ",
        "+ ",
        "  palettes <- list(",
        "+ ",
        "    default = list(",
        "+ ",
        "      bg           = \"#9093A2FF\",",
        "+ ",
        "      ellipsoid    = \"#2A363BFF\",",
        "+ ",
        "      centroid     = \"#D72000FF\",",
        "+ ",
        "      tolerance    = \"#EE6100FF\",",
        "+ ",
        "      suitable_env = \"#FED789FF\",",
        "+ ",
        "      occ          = \"#B4BF3AFF\"",
        "+ ",
        "    ),",
        "+ ",
        "    palette2 = list(",
        "+ ",
        "      bg           = \"#9CA9BAFF\",",
        "+ ",
        "      ellipsoid    = \"#3D619DFF\",",
        "+ ",
        "      centroid     = \"#345084FF\",",
        "+ ",
        "      tolerance    = \"#693829FF\",",
        "+ ",
        "      suitable_env = \"#CFB267FF\",",
        "+ ",
        "      occ          = \"#A56A3EFF\"",
        "+ ",
        "    ),",
        "+ ",
        "    palette3 = list(",
        "+ ",
        "      bg           = \"#C8CCC6FF\",",
        "+ ",
        "      ellipsoid    = \"#023743FF\",",
        "+ ",
        "      centroid     = \"#72874EFF\",",
        "+ ",
        "      tolerance    = \"#476F84FF\",",
        "+ ",
        "      suitable_env = \"#FED789FF\",",
        "+ ",
        "      occ          = \"#A4BED5FF\"",
        "+ ",
        "    ),",
        "+ ",
        "    palette4 = list(",
        "+ ",
        "      bg           = \"#C0D1CEFF\",",
        "+ ",
        "      ellipsoid    = \"#859B6CFF\",",
        "+ ",
        "      centroid     = \"#B74954FF\",",
        "+ ",
        "      tolerance    = \"#A99364FF\",",
        "+ ",
        "      suitable_env = \"#C2DDB2FF\",",
        "+ ",
        "      occ          = \"#EBA49EFF\"",
        "+ ",
        "    ),",
        "+ ",
        "    palette5 = list(",
        "+ ",
        "      bg           = \"#A89F8EFF\",",
        "+ ",
        "      ellipsoid    = \"#7887A4FF\",",
        "+ ",
        "      centroid     = \"#A8CDECFF\",",
        "+ ",
        "      tolerance    = \"#682C37FF\",",
        "+ ",
        "      suitable_env = \"#F6955EFF\",",
        "+ ",
        "      occ          = \"#9B6981FF\"",
        "+ ",
        "    ),",
        "+ ",
        "    palette6 = list(",
        "+ ",
        "      bg           = \"#D3D4D8FF\",",
        "+ ",
        "      ellipsoid    = \"#731A12FF\",",
        "+ ",
        "      centroid     = \"#F2D43DFF\",",
        "+ ",
        "      tolerance    = \"#3F858CFF\",",
        "+ ",
        "      suitable_env = \"#D9814EFF\",",
        "+ ",
        "      occ          = \"#707322FF\"",
        "+ ",
        "    )",
        "+ ",
        "  )",
        "+ ",
        "+ ",
        "  if (!palette %in% names(palettes)) {",
        "+ ",
        "    stop(\"Unknown palette '\", palette, \"'.\")",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  base_colors <- palettes[[palette]]",
        "+ ",
        "+ ",
        "  if (is.null(colors)) {",
        "+ ",
        "    colors <- base_colors",
        "+ ",
        "  } else {",
        "+ ",
        "    if (is.null(names(colors))) {",
        "+ ",
        "      names(colors) <- names(base_colors)[seq_along(colors)]",
        "+ ",
        "      if (!is.list(colors)) colors <- as.list(colors)",
        "+ ",
        "      message(",
        "+ ",
        "        \"No names detected in 'colors'. \",",
        "+ ",
        "        \"Using the order provided and filling missing entries with defaults.\\n\",",
        "+ ",
        "        \"If you want to change a specific object, use a named list.\\n\",",
        "+ ",
        "        \"Available options are: \",",
        "+ ",
        "        paste(names(base_colors), collapse = \", \")",
        "+ ",
        "      )",
        "+ ",
        "    }",
        "+ ",
        "    if (!is.list(colors)) colors <- as.list(colors)",
        "+ ",
        "    colors <- utils::modifyList(base_colors, colors)",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  # Legend options ------------------------------------------------------------",
        "+ ",
        "+ ",
        "  opts <- list(",
        "+ ",
        "    background_point     = TRUE,",
        "+ ",
        "    trace_line           = !is.null(niche),",
        "+ ",
        "    centroid_point       = !is.null(niche),",
        "+ ",
        "    tolerance_range_line = !is.null(niche),",
        "+ ",
        "    suitable_point       = !is.null(pts_in),",
        "+ ",
        "    occurrence_point     = !is.null(occ_pts)",
        "+ ",
        "  )",
        "+ ",
        "+ ",
        "  legend_items <- data.frame(",
        "+ ",
        "    id       = c(\"background_point\",\"trace_line\",\"centroid_point\",",
        "+ ",
        "                 \"tolerance_range_line\",\"suitable_point\",\"occurrence_point\"),",
        "+ ",
        "    type     = c(\"point\",\"line\",\"point\",\"line\",\"point\",\"point\"),",
        "+ ",
        "    label    = c(\"Background environments\",\"Niche boundary\",\"Niche centroid\",",
        "+ ",
        "                 \"Tolerance ranges\",\"Suitable environments\",\"Occurrences\"),",
        "+ ",
        "    color    = c(colors[[\"bg\"]], colors[[\"ellipsoid\"]], colors[[\"centroid\"]],",
        "+ ",
        "                 colors[[\"tolerance\"]], colors[[\"suitable_env\"]], colors[[\"occ\"]]),",
        "+ ",
        "    linetype = c(NA, 1, NA, 2, NA, NA),",
        "+ ",
        "    stringsAsFactors = FALSE",
        "+ ",
        "  )",
        "+ ",
        "+ ",
        "  active <- logical(nrow(legend_items))",
        "+ ",
        "  for (i in seq_len(nrow(legend_items))) {",
        "+ ",
        "    active[i] <- isTRUE(opts[[ legend_items$id[i] ]])",
        "+ ",
        "  }",
        "+ ",
        "  legend_items <- legend_items[active, , drop = FALSE]",
        "+ ",
        "+ ",
        "  # Build legend plot ---------------------------------------------------------",
        "+ ",
        "+ ",
        "  if (nrow(legend_items) == 0) {",
        "+ ",
        "    legend_plot <- ggplot2::ggplot() + ggplot2::theme_void()",
        "+ ",
        "  } else {",
        "+ ",
        "    top_y   <- 2",
        "+ ",
        "    spacing <- 0.25",
        "+ ",
        "    x_point <- 0.00",
        "+ ",
        "    x_text  <- 0.1",
        "+ ",
        "    x0_line <- -0.2",
        "+ ",
        "    x1_line <-  0.00",
        "+ ",
        "+ ",
        "    legend_items <- legend_items %>%",
        "+ ",
        "      dplyr::mutate(",
        "+ ",
        "        row     = dplyr::row_number(),",
        "+ ",
        "        y       = top_y - (row - 1) * spacing,",
        "+ ",
        "        x_point = x_point,",
        "+ ",
        "        x_text  = x_text,",
        "+ ",
        "        x0_line = x0_line,",
        "+ ",
        "        x1_line = x1_line",
        "+ ",
        "      )",
        "+ ",
        "+ ",
        "    legend_base <- ggplot2::ggplot() +",
        "+ ",
        "      ggplot2::coord_cartesian(xlim = c(-0.5, 0.5), ylim = c(0, 2.5), clip = \"off\") +",
        "+ ",
        "      ggplot2::theme_void() +",
        "+ ",
        "      ggplot2::theme(legend.position = \"none\")",
        "+ ",
        "+ ",
        "    legend_plot <- legend_base +",
        "+ ",
        "      ggplot2::geom_point(",
        "+ ",
        "        data  = dplyr::filter(legend_items, type == \"point\"),",
        "+ ",
        "        ggplot2::aes(x = x_point, y = y, colour = color),",
        "+ ",
        "        size = 2",
        "+ ",
        "      ) +",
        "+ ",
        "      ggplot2::geom_segment(",
        "+ ",
        "        data  = dplyr::filter(legend_items, type == \"line\"),",
        "+ ",
        "        ggplot2::aes(x = x0_line, xend = x1_line, y = y, yend = y,",
        "+ ",
        "                     colour = color, linetype = linetype),",
        "+ ",
        "        linewidth = 0.5",
        "+ ",
        "      ) +",
        "+ ",
        "      ggplot2::geom_text(",
        "+ ",
        "        data  = legend_items,",
        "+ ",
        "        ggplot2::aes(x = x_text, y = y, label = label),",
        "+ ",
        "        hjust = 0",
        "+ ",
        "      ) +",
        "+ ",
        "      ggplot2::scale_colour_identity() +",
        "+ ",
        "      ggplot2::scale_linetype_identity()",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  # Downsample background -----------------------------------------------------",
        "+ ",
        "+ ",
        "  if (nrow(env_bg) > n_bg) {",
        "+ ",
        "    message(sprintf(\"Sampling %d of %d rows from 'env_bg' for plotting.\", n_bg, nrow(env_bg)))",
        "+ ",
        "    set.seed(rand_seed)",
        "+ ",
        "    env_bg <- env_bg[sample.int(nrow(env_bg), size = n_bg, replace = FALSE), ]",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  # ---------------------------------------------------------------------------",
        "+ ",
        "  # 3D plotting branch",
        "+ ",
        "  # ---------------------------------------------------------------------------",
        "+ ",
        "+ ",
        "  if (isTRUE(plot.3d)) {",
        "+ ",
        "+ ",
        "    p3 <- plotly::plot_ly(",
        "+ ",
        "      data = env_bg,",
        "+ ",
        "      x    = env_bg[[col_x]],",
        "+ ",
        "      y    = env_bg[[col_y]],",
        "+ ",
        "      z    = env_bg[[col_z]],",
        "+ ",
        "      type = \"scatter3d\",",
        "+ ",
        "      mode = \"markers\",",
        "+ ",
        "      marker = list(color = colors[[\"bg\"]], size = 2),",
        "+ ",
        "      name   = \"Background Environments\"",
        "+ ",
        "    ) %>%",
        "+ ",
        "      plotly::layout(",
        "+ ",
        "        title = list(text = \"Background Environments (E-space)\"),",
        "+ ",
        "        scene = list(",
        "+ ",
        "          xaxis = list(title = list(text = labels[1])),",
        "+ ",
        "          yaxis = list(title = list(text = labels[2])),",
        "+ ",
        "          zaxis = list(title = list(text = labels[3]))",
        "+ ",
        "        ),",
        "+ ",
        "        legend = list(x = 0.05, y = 0.95)",
        "+ ",
        "      )",
        "+ ",
        "+ ",
        "    # Ellipsoid surface + centroid (if present)",
        "+ ",
        "    if (!is.null(niche) && !is.null(niche$surface)) {",
        "+ ",
        "+ ",
        "      surf <- as.data.frame(niche$surface)",
        "+ ",
        "      if (ncol(surf) >= 3) {",
        "+ ",
        "        p3 <- p3 %>%",
        "+ ",
        "          plotly::add_trace(",
        "+ ",
        "            data = surf,",
        "+ ",
        "            x    = surf[[1]],",
        "+ ",
        "            y    = surf[[2]],",
        "+ ",
        "            z    = surf[[3]],",
        "+ ",
        "            type = \"scatter3d\",",
        "+ ",
        "            mode = \"lines\",",
        "+ ",
        "            line = list(color = colors[[\"ellipsoid\"]]),",
        "+ ",
        "            name = \"Niche Boundary\",",
        "+ ",
        "            inherit = FALSE",
        "+ ",
        "          )",
        "+ ",
        "      }",
        "+ ",
        "+ ",
        "      if (!is.null(niche$center) && length(niche$center) >= 3) {",
        "+ ",
        "        p3 <- p3 %>%",
        "+ ",
        "          plotly::add_markers(",
        "+ ",
        "            x = niche$center[1],",
        "+ ",
        "            y = niche$center[2],",
        "+ ",
        "            z = niche$center[3],",
        "+ ",
        "            marker = list(color = colors[[\"centroid\"]], size = 5),",
        "+ ",
        "            name   = \"Niche Centroid\"",
        "+ ",
        "          )",
        "+ ",
        "      }",
        "+ ",
        "+ ",
        "      if (!is.null(pts_in)) {",
        "+ ",
        "        p3 <- p3 %>%",
        "+ ",
        "          plotly::add_markers(",
        "+ ",
        "            data = pts_in,",
        "+ ",
        "            x    = pts_in[[col_x]],",
        "+ ",
        "            y    = pts_in[[col_y]],",
        "+ ",
        "            z    = pts_in[[col_z]],",
        "+ ",
        "            marker = list(color = colors[[\"suitable_env\"]], size = 3),",
        "+ ",
        "            name   = \"Suitable Environments\",",
        "+ ",
        "            inherit = FALSE",
        "+ ",
        "          )",
        "+ ",
        "      }",
        "+ ",
        "    }",
        "+ ",
        "+ ",
        "    # Occurrence points in 3D",
        "+ ",
        "    if (!is.null(occ_pts)) {",
        "+ ",
        "      p3 <- p3 %>%",
        "+ ",
        "        plotly::add_markers(",
        "+ ",
        "          data = occ_pts,",
        "+ ",
        "          x    = occ_pts[[col_x]],",
        "+ ",
        "          y    = occ_pts[[col_y]],",
        "+ ",
        "          z    = occ_pts[[col_z]],",
        "+ ",
        "          marker = list(color = colors[[\"occ\"]], size = 3),",
        "+ ",
        "          name   = \"Sampled Occurrences\",",
        "+ ",
        "          inherit = FALSE",
        "+ ",
        "        ) %>%",
        "+ ",
        "        plotly::layout(",
        "+ ",
        "          title  = \"Virtual Niche and Sampled Occurrences in E-space\",",
        "+ ",
        "          legend = list(x = 0.05, y = 0.95)",
        "+ ",
        "        )",
        "+ ",
        "    }",
        "+ ",
        "+ ",
        "    return(p3)",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  # ---------------------------------------------------------------------------",
        "+ ",
        "  # 2D plotting branch",
        "+ ",
        "  # ---------------------------------------------------------------------------",
        "+ ",
        "+ ",
        "  p_main_y_x <- ggplot2::ggplot(",
        "+ ",
        "    env_bg,",
        "+ ",
        "    ggplot2::aes(x = .data[[col_y]], y = .data[[col_x]])",
        "+ ",
        "  ) +",
        "+ ",
        "    ggplot2::geom_point(alpha = 0.5, color = colors[[\"bg\"]], pch = \".\") +",
        "+ ",
        "    ggplot2::theme_bw() +",
        "+ ",
        "    ggplot2::theme(axis.title = ggplot2::element_blank())",
        "+ ",
        "+ ",
        "  p_main_z_x <- ggplot2::ggplot(",
        "+ ",
        "    env_bg,",
        "+ ",
        "    ggplot2::aes(x = .data[[col_z]], y = .data[[col_x]])",
        "+ ",
        "  ) +",
        "+ ",
        "    ggplot2::geom_point(alpha = 0.5, color = colors[[\"bg\"]], pch = \".\") +",
        "+ ",
        "    ggplot2::theme_bw() +",
        "+ ",
        "    ggplot2::theme(axis.title = ggplot2::element_blank())",
        "+ ",
        "+ ",
        "  p_main_z_y <- ggplot2::ggplot(",
        "+ ",
        "    env_bg,",
        "+ ",
        "    ggplot2::aes(x = .data[[col_z]], y = .data[[col_y]])",
        "+ ",
        "  ) +",
        "+ ",
        "    ggplot2::geom_point(alpha = 0.5, color = colors[[\"bg\"]], pch = \".\") +",
        "+ ",
        "    ggplot2::theme_bw() +",
        "+ ",
        "    ggplot2::theme(axis.title = ggplot2::element_blank())",
        "+ ",
        "+ ",
        "  x_name <- ggplot2::ggplot() + ggplot2::theme_void() +",
        "+ ",
        "    ggplot2::geom_text(ggplot2::aes(0, 0, label = labels[1]),",
        "+ ",
        "                       fontface = \"bold\")",
        "+ ",
        "  y_name <- ggplot2::ggplot() + ggplot2::theme_void() +",
        "+ ",
        "    ggplot2::geom_text(ggplot2::aes(0, 0, label = labels[2]),",
        "+ ",
        "                       fontface = \"bold\")",
        "+ ",
        "  z_name <- ggplot2::ggplot() + ggplot2::theme_void() +",
        "+ ",
        "    ggplot2::geom_text(ggplot2::aes(0, 0, label = labels[3]),",
        "+ ",
        "                       fontface = \"bold\")",
        "+ ",
        "+ ",
        "  return_plot <- ggpubr::ggarrange(",
        "+ ",
        "    x_name,      p_main_y_x, p_main_z_x,",
        "+ ",
        "    legend_plot, y_name,     p_main_z_y,",
        "+ ",
        "    NULL,        NULL,       z_name,",
        "+ ",
        "    ncol = 3, nrow = 3,",
        "+ ",
        "    widths  = c(0.15, 0.425, 0.425),",
        "+ ",
        "    heights = c(0.45, 0.45, 0.15)",
        "+ ",
        "  )",
        "+ ",
        "+ ",
        "  # --- Ellipsoid overlays and extras (2D) ------------------------------------",
        "+ ",
        "+ ",
        "  if (!is.null(niche)) {",
        "+ ",
        "+ ",
        "    center_y_x <- c(niche$center[2], niche$center[1])",
        "+ ",
        "    axes_y_x   <- c(niche$axes[2],   niche$axes[1])",
        "+ ",
        "    angle_y_x  <- c(niche$angles[2], niche$angles[1])",
        "+ ",
        "+ ",
        "    center_z_x <- c(niche$center[3], niche$center[1])",
        "+ ",
        "    axes_z_x   <- c(niche$axes[3],   niche$axes[1])",
        "+ ",
        "    angle_z_x  <- c(niche$angles[3], niche$angles[1])",
        "+ ",
        "+ ",
        "    center_z_y <- c(niche$center[3], niche$center[2])",
        "+ ",
        "    axes_z_y   <- c(niche$axes[3],   niche$axes[2])",
        "+ ",
        "    angle_z_y  <- c(niche$angles[3], niche$angles[2])",
        "+ ",
        "+ ",
        "    ell2d_y_x <- build_ellps(center = center_y_x, axes = axes_y_x, angles = angle_y_x)",
        "+ ",
        "    ell2d_z_x <- build_ellps(center = center_z_x, axes = axes_z_x, angles = angle_z_x)",
        "+ ",
        "    ell2d_z_y <- build_ellps(center = center_z_y, axes = axes_z_y, angles = angle_z_y)",
        "+ ",
        "+ ",
        "    ell_y_x <- p_main_y_x",
        "+ ",
        "    ell_z_x <- p_main_z_x",
        "+ ",
        "    ell_z_y <- p_main_z_y",
        "+ ",
        "+ ",
        "    if (any(niche$angles != 0)) {",
        "+ ",
        "      angle_warn <- ggplot2::ggplot() + ggplot2::theme_void() +",
        "+ ",
        "        ggplot2::geom_text(",
        "+ ",
        "          ggplot2::aes(0, 0,",
        "+ ",
        "                       label = \"Note: The ellipsoid is angled; its shape may appear distorted and some points may fall outside due to dimensionality.\"),",
        "+ ",
        "          size = 2",
        "+ ",
        "        )",
        "+ ",
        "    } else {",
        "+ ",
        "      angle_warn <- NULL",
        "+ ",
        "    }",
        "+ ",
        "+ ",
        "    # Suitable points (inside)",
        "+ ",
        "    if (!is.null(pts_in)) {",
        "+ ",
        "+ ",
        "      ell_y_x <- ell_y_x +",
        "+ ",
        "        ggplot2::geom_point(",
        "+ ",
        "          data = pts_in,",
        "+ ",
        "          ggplot2::aes(",
        "+ ",
        "            x = .data[[col_y]],",
        "+ ",
        "            y = .data[[col_x]]",
        "+ ",
        "          ),",
        "+ ",
        "          color = colors[[\"suitable_env\"]],",
        "+ ",
        "          size  = 0.5",
        "+ ",
        "        )",
        "+ ",
        "+ ",
        "      ell_z_x <- ell_z_x +",
        "+ ",
        "        ggplot2::geom_point(",
        "+ ",
        "          data = pts_in,",
        "+ ",
        "          ggplot2::aes(",
        "+ ",
        "            x = .data[[col_z]],",
        "+ ",
        "            y = .data[[col_x]]",
        "+ ",
        "          ),",
        "+ ",
        "          color = colors[[\"suitable_env\"]],",
        "+ ",
        "          size  = 0.5",
        "+ ",
        "        )",
        "+ ",
        "+ ",
        "      ell_z_y <- ell_z_y +",
        "+ ",
        "        ggplot2::geom_point(",
        "+ ",
        "          data = pts_in,",
        "+ ",
        "          ggplot2::aes(",
        "+ ",
        "            x = .data[[col_z]],",
        "+ ",
        "            y = .data[[col_y]]",
        "+ ",
        "          ),",
        "+ ",
        "          color = colors[[\"suitable_env\"]],",
        "+ ",
        "          size  = 0.5",
        "+ ",
        "        )",
        "+ ",
        "    }",
        "+ ",
        "+ ",
        "    # Occurrence points in 2D",
        "+ ",
        "    if (!is.null(occ_pts)) {",
        "+ ",
        "      ell_y_x <- ell_y_x +",
        "+ ",
        "        ggplot2::geom_point(",
        "+ ",
        "          data = occ_pts,",
        "+ ",
        "          ggplot2::aes(",
        "+ ",
        "            x = .data[[col_y]],",
        "+ ",
        "            y = .data[[col_x]]",
        "+ ",
        "          ),",
        "+ ",
        "          color = colors[[\"occ\"]],",
        "+ ",
        "          size  = 0.5",
        "+ ",
        "        )",
        "+ ",
        "+ ",
        "      ell_z_x <- ell_z_x +",
        "+ ",
        "        ggplot2::geom_point(",
        "+ ",
        "          data = occ_pts,",
        "+ ",
        "          ggplot2::aes(",
        "+ ",
        "            x = .data[[col_z]],",
        "+ ",
        "            y = .data[[col_x]]",
        "+ ",
        "          ),",
        "+ ",
        "          color = colors[[\"occ\"]],",
        "+ ",
        "          size  = 0.5",
        "+ ",
        "        )",
        "+ ",
        "+ ",
        "      ell_z_y <- ell_z_y +",
        "+ ",
        "        ggplot2::geom_point(",
        "+ ",
        "          data = occ_pts,",
        "+ ",
        "          ggplot2::aes(",
        "+ ",
        "            x = .data[[col_z]],",
        "+ ",
        "            y = .data[[col_y]]",
        "+ ",
        "          ),",
        "+ ",
        "          color = colors[[\"occ\"]],",
        "+ ",
        "          size  = 0.5",
        "+ ",
        "        )",
        "+ ",
        "    }",
        "+ ",
        "+ ",
        "    # Ellipse boundaries + axes + centroid -----------------------------------",
        "+ ",
        "+ ",
        "    ell_y_x <- ell_y_x +",
        "+ ",
        "      ggplot2::geom_path(",
        "+ ",
        "        data   = ell2d_y_x$surface,",
        "+ ",
        "        ggplot2::aes(x, y),",
        "+ ",
        "        color = colors[[\"ellipsoid\"]],",
        "+ ",
        "        linewidth = 0.5",
        "+ ",
        "      ) +",
        "+ ",
        "      ggplot2::annotate(",
        "+ ",
        "        \"segment\",",
        "+ ",
        "        x    = ell2d_y_x$center[1] - ell2d_y_x$axes[1],",
        "+ ",
        "        xend = ell2d_y_x$center[1] + ell2d_y_x$axes[1],",
        "+ ",
        "        y    = ell2d_y_x$center[2],",
        "+ ",
        "        yend = ell2d_y_x$center[2],",
        "+ ",
        "        color = colors[[\"tolerance\"]],",
        "+ ",
        "        linetype = \"dashed\"",
        "+ ",
        "      ) +",
        "+ ",
        "      ggplot2::annotate(",
        "+ ",
        "        \"segment\",",
        "+ ",
        "        y    = ell2d_y_x$center[2] - ell2d_y_x$axes[2],",
        "+ ",
        "        yend = ell2d_y_x$center[2] + ell2d_y_x$axes[2],",
        "+ ",
        "        x    = ell2d_y_x$center[1],",
        "+ ",
        "        xend = ell2d_y_x$center[1],",
        "+ ",
        "        color = colors[[\"tolerance\"]],",
        "+ ",
        "        linetype = \"dashed\"",
        "+ ",
        "      ) +",
        "+ ",
        "      ggplot2::annotate(",
        "+ ",
        "        \"point\",",
        "+ ",
        "        x = ell2d_y_x$center[1],",
        "+ ",
        "        y = ell2d_y_x$center[2],",
        "+ ",
        "        color = colors[[\"centroid\"]],",
        "+ ",
        "        size  = 2",
        "+ ",
        "      )",
        "+ ",
        "+ ",
        "    ell_z_x <- ell_z_x +",
        "+ ",
        "      ggplot2::geom_path(",
        "+ ",
        "        data   = ell2d_z_x$surface,",
        "+ ",
        "        ggplot2::aes(x, y),",
        "+ ",
        "        color = colors[[\"ellipsoid\"]],",
        "+ ",
        "        linewidth = 0.5",
        "+ ",
        "      ) +",
        "+ ",
        "      ggplot2::annotate(",
        "+ ",
        "        \"segment\",",
        "+ ",
        "        x    = ell2d_z_x$center[1] - ell2d_z_x$axes[1],",
        "+ ",
        "        xend = ell2d_z_x$center[1] + ell2d_z_x$axes[1],",
        "+ ",
        "        y    = ell2d_z_x$center[2],",
        "+ ",
        "        yend = ell2d_z_x$center[2],",
        "+ ",
        "        color = colors[[\"tolerance\"]],",
        "+ ",
        "        linetype = \"dashed\"",
        "+ ",
        "      ) +",
        "+ ",
        "      ggplot2::annotate(",
        "+ ",
        "        \"segment\",",
        "+ ",
        "        y    = ell2d_z_x$center[2] - ell2d_z_x$axes[2],",
        "+ ",
        "        yend = ell2d_z_x$center[2] + ell2d_z_x$axes[2],",
        "+ ",
        "        x    = ell2d_z_x$center[1],",
        "+ ",
        "        xend = ell2d_z_x$center[1],",
        "+ ",
        "        color = colors[[\"tolerance\"]],",
        "+ ",
        "        linetype = \"dashed\"",
        "+ ",
        "      ) +",
        "+ ",
        "      ggplot2::annotate(",
        "+ ",
        "        \"point\",",
        "+ ",
        "        x = ell2d_z_x$center[1],",
        "+ ",
        "        y = ell2d_z_x$center[2],",
        "+ ",
        "        color = colors[[\"centroid\"]],",
        "+ ",
        "        size  = 2",
        "+ ",
        "      )",
        "+ ",
        "+ ",
        "    ell_z_y <- ell_z_y +",
        "+ ",
        "      ggplot2::geom_path(",
        "+ ",
        "        data   = ell2d_z_y$surface,",
        "+ ",
        "        ggplot2::aes(x, y),",
        "+ ",
        "        color = colors[[\"ellipsoid\"]],",
        "+ ",
        "        linewidth = 0.5",
        "+ ",
        "      ) +",
        "+ ",
        "      ggplot2::annotate(",
        "+ ",
        "        \"segment\",",
        "+ ",
        "        x    = ell2d_z_y$center[1] - ell2d_z_y$axes[1],",
        "+ ",
        "        xend = ell2d_z_y$center[1] + ell2d_z_y$axes[1],",
        "+ ",
        "        y    = ell2d_z_y$center[2],",
        "+ ",
        "        yend = ell2d_z_y$center[2],",
        "+ ",
        "        color = colors[[\"tolerance\"]],",
        "+ ",
        "        linetype = \"dashed\"",
        "+ ",
        "      ) +",
        "+ ",
        "      ggplot2::annotate(",
        "+ ",
        "        \"segment\",",
        "+ ",
        "        y    = ell2d_z_y$center[2] - ell2d_z_y$axes[2],",
        "+ ",
        "        yend = ell2d_z_y$center[2] + ell2d_z_y$axes[2],",
        "+ ",
        "        x    = ell2d_z_y$center[1],",
        "+ ",
        "        xend = ell2d_z_y$center[1],",
        "+ ",
        "        color = colors[[\"tolerance\"]],",
        "+ ",
        "        linetype = \"dashed\"",
        "+ ",
        "      ) +",
        "+ ",
        "      ggplot2::annotate(",
        "+ ",
        "        \"point\",",
        "+ ",
        "        x = ell2d_z_y$center[1],",
        "+ ",
        "        y = ell2d_z_y$center[2],",
        "+ ",
        "        color = colors[[\"centroid\"]],",
        "+ ",
        "        size  = 2",
        "+ ",
        "      )",
        "+ ",
        "+ ",
        "    # Re-assemble main grid with ellipsoid overlays --------------------------",
        "+ ",
        "+ ",
        "    return_plot <- ggpubr::ggarrange(",
        "+ ",
        "      x_name,      ell_y_x,   ell_z_x,",
        "+ ",
        "      legend_plot, y_name,    ell_z_y,",
        "+ ",
        "      NULL,        angle_warn, z_name,",
        "+ ",
        "      ncol = 3, nrow = 3,",
        "+ ",
        "      widths  = c(0.15, 0.425, 0.425),",
        "+ ",
        "      heights = c(0.45, 0.45, 0.15)",
        "+ ",
        "    )",
        "+ ",
        "+ ",
        "    # Optional occurrence density panels -------------------------------------",
        "+ ",
        "+ ",
        "    if (isTRUE(show.occ.density) && !is.null(occ_pts)) {",
        "+ ",
        "+ ",
        "      rng_z <- range(env_bg[[col_z]], na.rm = TRUE)",
        "+ ",
        "      rng_y <- range(env_bg[[col_y]], na.rm = TRUE)",
        "+ ",
        "      rng_x <- range(env_bg[[col_x]], na.rm = TRUE)",
        "+ ",
        "+ ",
        "      env_z_top <- ggplot2::ggplot(occ_pts, ggplot2::aes(x = .data[[col_z]])) +",
        "+ ",
        "        ggplot2::geom_density(fill = colors[[\"occ\"]], alpha = 0.6) +",
        "+ ",
        "        ggplot2::scale_x_continuous(limits = rng_z) +",
        "+ ",
        "        ggplot2::scale_y_continuous(n.breaks = 3) +",
        "+ ",
        "        ggplot2::theme_minimal() +",
        "+ ",
        "        ggplot2::theme(",
        "+ ",
        "          axis.text.x  = ggplot2::element_blank(),",
        "+ ",
        "          axis.title.x = ggplot2::element_blank(),",
        "+ ",
        "          axis.title.y = ggplot2::element_blank(),",
        "+ ",
        "          axis.text.y  = ggplot2::element_text(size = 5)",
        "+ ",
        "        )",
        "+ ",
        "+ ",
        "      env_y_top <- ggplot2::ggplot(occ_pts, ggplot2::aes(x = .data[[col_y]])) +",
        "+ ",
        "        ggplot2::geom_density(fill = colors[[\"occ\"]], alpha = 0.6) +",
        "+ ",
        "        ggplot2::scale_x_continuous(limits = rng_y) +",
        "+ ",
        "        ggplot2::scale_y_continuous(n.breaks = 3) +",
        "+ ",
        "        ggplot2::theme_minimal() +",
        "+ ",
        "        ggplot2::theme(",
        "+ ",
        "          axis.text.x  = ggplot2::element_blank(),",
        "+ ",
        "          axis.title.x = ggplot2::element_blank(),",
        "+ ",
        "          axis.title.y = ggplot2::element_blank(),",
        "+ ",
        "          axis.text.y  = ggplot2::element_text(size = 5)",
        "+ ",
        "        )",
        "+ ",
        "+ ",
        "      env_x_right <- ggplot2::ggplot(occ_pts, ggplot2::aes(x = .data[[col_x]])) +",
        "+ ",
        "        ggplot2::geom_density(fill = colors[[\"occ\"]], alpha = 0.6) +",
        "+ ",
        "        ggplot2::scale_x_continuous(limits = rng_x) +",
        "+ ",
        "        ggplot2::coord_flip() +",
        "+ ",
        "        ggplot2::scale_y_continuous(n.breaks = 3) +",
        "+ ",
        "        ggplot2::theme_minimal() +",
        "+ ",
        "        ggplot2::theme(",
        "+ ",
        "          axis.text.y  = ggplot2::element_blank(),",
        "+ ",
        "          axis.title.y = ggplot2::element_blank(),",
        "+ ",
        "          axis.title.x = ggplot2::element_blank(),",
        "+ ",
        "          axis.text.x  = ggplot2::element_text(size = 5)",
        "+ ",
        "        )",
        "+ ",
        "+ ",
        "      env_y_right <- ggplot2::ggplot(occ_pts, ggplot2::aes(x = .data[[col_y]])) +",
        "+ ",
        "        ggplot2::geom_density(fill = colors[[\"occ\"]], alpha = 0.6) +",
        "+ ",
        "        ggplot2::scale_x_continuous(limits = rng_y) +",
        "+ ",
        "        ggplot2::coord_flip() +",
        "+ ",
        "        ggplot2::scale_y_continuous(n.breaks = 3) +",
        "+ ",
        "        ggplot2::theme_minimal() +",
        "+ ",
        "        ggplot2::theme(",
        "+ ",
        "          axis.text.y  = ggplot2::element_blank(),",
        "+ ",
        "          axis.title.y = ggplot2::element_blank(),",
        "+ ",
        "          axis.title.x = ggplot2::element_blank(),",
        "+ ",
        "          axis.text.x  = ggplot2::element_text(size = 5)",
        "+ ",
        "        )",
        "+ ",
        "+ ",
        "      return_plot <- ggpubr::ggarrange(",
        "+ ",
        "        NULL,        env_y_top, env_z_top, NULL,",
        "+ ",
        "        x_name,      ell_y_x,   ell_z_x,   env_x_right,",
        "+ ",
        "        legend_plot, y_name,    ell_z_y,   env_y_right,",
        "+ ",
        "        NULL,        angle_warn, z_name,   NULL,",
        "+ ",
        "        ncol = 4, nrow = 4,",
        "+ ",
        "        widths  = c(0.1, 0.4, 0.4, 0.1),",
        "+ ",
        "        heights = c(0.1, 0.4, 0.4, 0.1)",
        "+ ",
        "      )",
        "+ ",
        "    }",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  return(return_plot)",
        "+ ",
        "}",
        "> ",
        "gc()",
        "             used    (Mb) gc trigger    (Mb)   max used\nNcells    4968949   265.4   20799317  1110.9   37274142\nVcells 1679039183 12810.1 3598670520 27455.7 3595506651\n          (Mb)\nNcells  1990.7\nVcells 27431.6\n",
        "> ",
        "plot_e_space(env_bg = env_df_db,",
        "+ ",
        "             niche = my_niche_large,",
        "+ ",
        "             suitable_env = suitbale_area,",
        "+ ",
        "             x = \"pr_sum\", y = \"tmmn_min\", z = \"tmmx_max\")",
        "\u001BG3;Sampling 10000 of 8890236 rows from 'suitable_env' for plotting.\n\u001Bg\u001BG3;Sampling 10000 of 274007375 rows from 'env_bg' for plotting.\n\u001Bg",
        "> ",
        "plot_e_space(env_bg = env_df_small,",
        "+ ",
        "             niche = my_niche_small,",
        "+ ",
        "             suitable_env = suitable_area_t1,",
        "+ ",
        "             plot.3d = FALSE)",
        "\u001BG3;No complete x, y, z specification provided. Using predictor columns inferred from 'env_bg': mean_temp, temp_seasonality, annual_precip\n\u001Bg\u001BG3;Using predictor columns: mean_temp, temp_seasonality, annual_precip\n\u001Bg\u001BG3;Sampling 10000 of 310771 rows from 'suitable_env' for plotting.\n\u001Bg\u001BG3;Sampling 10000 of 12412229 rows from 'env_bg' for plotting.\n\u001Bg",
        "> ",
        "# IN: Stack (small)",
        "> ",
        "# OUT: data frame",
        "> ",
        "suitable_area_t1 <- get_suitable_env(niche = my_niche_small,",
        "+ ",
        "                                  env_bg = env_stack_small,",
        "+ ",
        "                                  out = \"data.frame\",",
        "+ ",
        "                                  distances = TRUE)",
        "\u001BG3;Starting get_suitable_env()...\n\u001Bg\u001BG3;Preparing environmental background...\n\u001Bg\u001BG3;env_bg is a SpatRaster. Estimating size for data.frame conversion...\n\u001Bg\u001BG3;Estimated size ~851 MB. Converting raster to data.frame with as.data.frame.nicheR()...\n\u001Bg\u001BG3;Estimated raster size ~ 425.52 MB (37182370 cells x 3 layers)\n\u001Bg\u001BG3;Using in-memory terra::as.data.frame (below threshold).\n\u001Bg\u001BG3;Using 3 predictor columns for the ellipsoid.\n\u001Bg\u001BG3;Subsetting to the ellipsoid bounding box in E space...\n\u001Bg\u001BG3;Bounding box subs",
        "etting reduced data from 12412229 to 1070550 rows.\n\u001Bg\u001BG3;1070550 rows have complete predictor values. Computing Mahalanobis distances...\n\u001Bg\u001BG3;310771 points fall inside the ellipsoid.\n\u001Bg\u001BG3;Finished get_suitable_env().\n\u001Bg",
        "> ",
        "plot_e_space(env_bg = env_df_small,",
        "+ ",
        "             niche = my_niche_small,",
        "+ ",
        "             suitable_env = suitable_area_t1,",
        "+ ",
        "             plot.3d = FALSE)",
        "\u001BG3;No complete x, y, z specification provided. Using predictor columns inferred from 'env_bg': mean_temp, temp_seasonality, annual_precip\n\u001Bg\u001BG3;Using predictor columns: mean_temp, temp_seasonality, annual_precip\n\u001Bg\u001BG3;Sampling 10000 of 310771 rows from 'suitable_env' for plotting.\n\u001Bg\u001BG3;Sampling 10000 of 12412229 rows from 'env_bg' for plotting.\n\u001Bg",
        "> ",
        "env_df_small <- as.data.frame.nicheR(raster_stack = env_stack_small)",
        "> ",
        "nrow(env_df_small)",
        "[1] 12412229\n",
        "> ",
        "plot_g_space(suitable_env = suitable_area_t1)",
        "> ",
        "#' Plot Geographic Space with Optional Suitability/Distance and Occurrences",
        "> ",
        "#'",
        "> ",
        "#' Draws a basemap and overlays (a) suitable environments as tiles,",
        "> ",
        "#' (b) an optional continuous distance-to-centroid surface, and/or (c)",
        "> ",
        "#' occurrence points. The map extent is primarily inferred from \\code{env_bg}",
        "> ",
        "#' (if available), otherwise from the coordinates in \\code{suitable_env} and",
        "> ",
        "#' finally from \\code{occ_pts}, always with a small buffer where needed.",
        "> ",
        "#'",
        "> ",
        "#' @param env_bg Optional background environment object used when",
        "> ",
        "#'   \\code{suitable_env} is not supplied and suitability must be computed.",
        "> ",
        "#'   Typically a \\code{terra::SpatRaster} (or \\code{raster::Raster*}).",
        "> ",
        "#' @param suitable_env Optional precomputed suitable environment object. Can be:",
        "> ",
        "#'   \\itemize{",
        "> ",
        "#'     \\item a \\code{data.frame} with columns \\code{x}, \\code{y}, and optionally \\code{dist_sq},",
        "> ",
        "#'     \\item a \\code{\"suitable_env\"} object returned by \\code{\\link{get_suitable_env}}",
        "> ",
        "#'           with a \\code{suitable_env_df} or \\code{suitable_env_sp} component,",
        "> ",
        "#'     \\item a \\code{terra::SpatRaster} or a list of \\code{terra::SpatRaster} objects.",
        "> ",
        "#'   }",
        "> ",
        "#'   When a data.frame is used, it is assumed that each row corresponds to a",
        "> ",
        "#'   suitable cell (i.e. presence-only). When \\code{dist_sq} is present, a",
        "> ",
        "#'   distance panel can also be drawn.",
        "> ",
        "#' @param occ_pts Optional \\code{data.frame} of occurrences with columns",
        "> ",
        "#'   \\code{x}, \\code{y} (assumed longitude/latitude, WGS84). Plotted as points",
        "> ",
        "#'   if supplied. If \\code{vs} is supplied and \\code{occ_pts} is \\code{NULL},",
        "> ",
        "#'   the function will try to use \\code{vs$occurrences}.",
        "> ",
        "#' @param show.occ.density Logical (currently unused; reserved for future",
        "> ",
        "#'   density panels).",
        "> ",
        "#' @param colors Optional named list to override aesthetics. Recognized names:",
        "> ",
        "#'   \\code{bg} (basemap fill), \\code{suitable_env} (suitable tiles),",
        "> ",
        "#'   \\code{occ_fill}, \\code{occ_stroke}, and \\code{dist} (RColorBrewer palette",
        "> ",
        "#'   name for distance tiles).",
        "> ",
        "#' @param palette Character palette key. One of \\code{\"default\"},",
        "> ",
        "#'   \\code{\"palette2\"}, or \\code{\"palette3\"}.",
        "> ",
        "#' @param surface Character; which surface(s) to plot. One of:",
        "> ",
        "#'   \\itemize{",
        "> ",
        "#'     \\item \\code{\"both\"}: show suitability tiles and (if available) distance tiles,",
        "> ",
        "#'     \\item \\code{\"suit\"}: show only suitability tiles,",
        "> ",
        "#'     \\item \\code{\"dist\"}: show only the distance-to-centroid surface",
        "> ",
        "#'           (requires a \\code{dist_sq} column).",
        "> ",
        "#'   }",
        "> ",
        "#' @param vs Optional object of class \\code{\"NicheR_species\"} created by",
        "> ",
        "#'   \\code{\\link{create_virtual_species}}. When provided, any of",
        "> ",
        "#'   \\code{env_bg}, \\code{niche}, \\code{occ_pts}, or \\code{suitable_env} that",
        "> ",
        "#'   are \\code{NULL} will be filled from this object if possible.",
        "> ",
        "#' @param niche Optional object of class \\code{\"ellipsoid\"} (from",
        "> ",
        "#'   \\code{\\link{build_ellps}}). Required when suitability is computed internally",
        "> ",
        "#'   (i.e., when \\code{suitable_env} is \\code{NULL}).",
        "> ",
        "#'",
        "> ",
        "#' @return A \\code{ggpubr} object produced by \\code{\\link[ggpubr]{ggarrange}},",
        "> ",
        "#'   containing one or two map panels plus a matching legend panel.",
        "> ",
        "#'",
        "> ",
        "#' @family plotting functions",
        "> ",
        "#' @seealso \\code{\\link{build_ellps}}, \\code{\\link{get_suitable_env}},",
        "> ",
        "#'   \\code{\\link{create_virtual_species}}",
        "> ",
        "#'",
        "> ",
        "#' @export",
        "> ",
        "plot_g_space <- function(env_bg = NULL,",
        "+ ",
        "                         suitable_env = NULL,",
        "+ ",
        "                         occ_pts = NULL,",
        "+ ",
        "                         show.occ.density = FALSE,",
        "+ ",
        "                         colors = NULL,",
        "+ ",
        "                         palette = \"default\",",
        "+ ",
        "                         surface = c(\"both\", \"suit\", \"dist\"),",
        "+ ",
        "                         vs = NULL,",
        "+ ",
        "                         niche = NULL) {",
        "+ ",
        "+ ",
        "  surface <- match.arg(surface)",
        "+ ",
        "+ ",
        "  # ---- 0. Pull components from NicheR_species if provided -----------------",
        "+ ",
        "  if (!is.null(vs)) {",
        "+ ",
        "    if (!inherits(vs, \"NicheR_species\")) {",
        "+ ",
        "      stop(\"'vs' must be an object of class 'NicheR_species' created by create_virtual_species().\")",
        "+ ",
        "    }",
        "+ ",
        "+ ",
        "    if (is.null(env_bg) && !is.null(vs$call_args) && \"env_bg\" %in% names(vs$call_args)) {",
        "+ ",
        "      env_bg <- vs$call_args$env_bg",
        "+ ",
        "    }",
        "+ ",
        "    if (is.null(niche) && !is.null(vs$niche)) {",
        "+ ",
        "      niche <- vs$niche",
        "+ ",
        "    }",
        "+ ",
        "    if (is.null(occ_pts) && !is.null(vs$occurrences)) {",
        "+ ",
        "      occ_pts <- vs$occurrences",
        "+ ",
        "    }",
        "+ ",
        "    if (is.null(suitable_env) && !is.null(vs$suitability)) {",
        "+ ",
        "      suitable_env <- vs$suitability",
        "+ ",
        "    }",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  # ---- 1. Palette / color handling ----------------------------------------",
        "+ ",
        "  palettes <- list(",
        "+ ",
        "    default = list(",
        "+ ",
        "      bg           = \"#F0F0F0FF\",",
        "+ ",
        "      suitable_env = \"#FED789FF\",",
        "+ ",
        "      occ_fill     = \"#B4BF3AFF\",",
        "+ ",
        "      occ_stroke   = \"black\",",
        "+ ",
        "      dist         = \"YlOrRd\"   # brewer palette name",
        "+ ",
        "    ),",
        "+ ",
        "    palette2 = list(",
        "+ ",
        "      bg           = \"#E0ECF4FF\",",
        "+ ",
        "      suitable_env = \"#9ECAE1FF\",",
        "+ ",
        "      occ_fill     = \"#08519CFF\",",
        "+ ",
        "      occ_stroke   = \"#08306BFF\",",
        "+ ",
        "      dist         = \"YlGnBu\"",
        "+ ",
        "    ),",
        "+ ",
        "    palette3 = list(",
        "+ ",
        "      bg           = \"#F0F0F0FF\",",
        "+ ",
        "      suitable_env = \"#BDBDBDFF\",",
        "+ ",
        "      occ_fill     = \"#252525FF\",",
        "+ ",
        "      occ_stroke   = \"#000000FF\",",
        "+ ",
        "      dist         = \"OrRd\"",
        "+ ",
        "    )",
        "+ ",
        "  )",
        "+ ",
        "+ ",
        "  if (!palette %in% names(palettes)) {",
        "+ ",
        "    stop(\"Unknown palette '\", palette, \"'. Use one of: \",",
        "+ ",
        "         paste(names(palettes), collapse = \", \"), \".\")",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  base_colors <- palettes[[palette]]",
        "+ ",
        "+ ",
        "  if (is.null(colors)) {",
        "+ ",
        "    default_colors <- base_colors",
        "+ ",
        "  } else {",
        "+ ",
        "    if (is.null(names(colors))) {",
        "+ ",
        "      names(colors) <- names(base_colors)[seq_along(colors)]",
        "+ ",
        "      if (!is.list(colors)) colors <- as.list(colors)",
        "+ ",
        "      message(",
        "+ ",
        "        \"No names detected in 'colors'. Using the provided order and filling \",",
        "+ ",
        "        \"missing entries with defaults.\\n\",",
        "+ ",
        "        \"Named options are: \",",
        "+ ",
        "        paste(names(base_colors), collapse = \", \"), \".\"",
        "+ ",
        "      )",
        "+ ",
        "    }",
        "+ ",
        "    if (!is.list(colors)) colors <- as.list(colors)",
        "+ ",
        "    default_colors <- utils::modifyList(base_colors, colors)",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  # ---- 2. Occurrence points validation ------------------------------------",
        "+ ",
        "+ ",
        "  if (!is.null(occ_pts) && !all(c(\"x\", \"y\") %in% names(occ_pts))) {",
        "+ ",
        "    stop(\"`occ_pts` must have columns named 'x' and 'y'.\")",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  # ---- 3. Standardize suitable_env into a data.frame ----------------------",
        "+ ",
        "+ ",
        "  suitable_df <- NULL",
        "+ ",
        "+ ",
        "  if (!is.null(suitable_env)) {",
        "+ ",
        "+ ",
        "    # Case 1: plain data.frame / matrix",
        "+ ",
        "    if (is.data.frame(suitable_env) || is.matrix(suitable_env)) {",
        "+ ",
        "+ ",
        "      suitable_df <- as.data.frame(suitable_env)",
        "+ ",
        "+ ",
        "      # Case 2: \"suitable_env\" style object",
        "+ ",
        "    } else if (is.list(suitable_env) &&",
        "+ ",
        "               any(c(\"suitable_env_df\", \"suitable_env_sp\") %in% names(suitable_env))) {",
        "+ ",
        "+ ",
        "      if (\"suitable_env_df\" %in% names(suitable_env) &&",
        "+ ",
        "          is.data.frame(suitable_env$suitable_env_df)) {",
        "+ ",
        "+ ",
        "        suitable_df <- suitable_env$suitable_env_df",
        "+ ",
        "+ ",
        "      } else if (\"suitable_env_sp\" %in% names(suitable_env)) {",
        "+ ",
        "+ ",
        "        sp <- suitable_env$suitable_env_sp",
        "+ ",
        "        if (inherits(sp, \"Raster\")) {",
        "+ ",
        "          sp <- terra::rast(sp)",
        "+ ",
        "        }",
        "+ ",
        "+ ",
        "        if (inherits(sp, \"SpatRaster\")) {",
        "+ ",
        "          rast_stack <- sp",
        "+ ",
        "        } else if (is.list(sp) &&",
        "+ ",
        "                   length(sp) > 0 &&",
        "+ ",
        "                   all(vapply(sp, inherits, logical(1), \"SpatRaster\"))) {",
        "+ ",
        "+ ",
        "          rast_stack <- do.call(c, sp)",
        "+ ",
        "        } else {",
        "+ ",
        "          stop(",
        "+ ",
        "            \"'suitable_env$suitable_env_sp' must be a SpatRaster or a list of SpatRasters \",",
        "+ ",
        "            \"when no 'suitable_env_df' is present.\"",
        "+ ",
        "          )",
        "+ ",
        "        }",
        "+ ",
        "+ ",
        "        suitable_df <- as.data.frame.nicheR(rast_stack)",
        "+ ",
        "      } else {",
        "+ ",
        "        stop(",
        "+ ",
        "          \"`suitable_env` list must contain either 'suitable_env_df' or 'suitable_env_sp'.\"",
        "+ ",
        "        )",
        "+ ",
        "      }",
        "+ ",
        "+ ",
        "      # Case 3: Raster / SpatRaster / list of SpatRasters directly",
        "+ ",
        "    } else {",
        "+ ",
        "+ ",
        "      if (inherits(suitable_env, \"Raster\")) {",
        "+ ",
        "        suitable_env <- terra::rast(suitable_env)",
        "+ ",
        "      }",
        "+ ",
        "+ ",
        "      if (inherits(suitable_env, \"SpatRaster\")) {",
        "+ ",
        "+ ",
        "        rast_stack <- suitable_env",
        "+ ",
        "+ ",
        "      } else if (is.list(suitable_env) &&",
        "+ ",
        "                 length(suitable_env) > 0 &&",
        "+ ",
        "                 all(vapply(suitable_env, inherits, logical(1), \"SpatRaster\"))) {",
        "+ ",
        "+ ",
        "        rast_stack <- do.call(c, suitable_env)",
        "+ ",
        "+ ",
        "      } else {",
        "+ ",
        "        stop(",
        "+ ",
        "          \"`suitable_env` must be either:\\n\",",
        "+ ",
        "          \"  * a data.frame with columns 'x', 'y' (and optionally 'dist_sq'), or\\n\",",
        "+ ",
        "          \"  * a 'suitable_env' object with 'suitable_env_df' or 'suitable_env_sp', or\\n\",",
        "+ ",
        "          \"  * a SpatRaster / list of SpatRasters.\\n\"",
        "+ ",
        "        )",
        "+ ",
        "      }",
        "+ ",
        "+ ",
        "      suitable_df <- as.data.frame.nicheR(rast_stack)",
        "+ ",
        "    }",
        "+ ",
        "+ ",
        "    # sanity check for coordinates",
        "+ ",
        "    if (!all(c(\"x\", \"y\") %in% names(suitable_df))) {",
        "+ ",
        "      stop(\"`suitable_env` (after coercion) must contain 'x' and 'y' columns.\")",
        "+ ",
        "    }",
        "+ ",
        "+ ",
        "  } else {",
        "+ ",
        "    # no suitable_env provided; fall back to internal computation if possible",
        "+ ",
        "    if (!is.null(niche) && !is.null(env_bg)) {",
        "+ ",
        "      suitable_df <- get_suitable_env(",
        "+ ",
        "        niche     = niche,",
        "+ ",
        "        env_bg    = env_bg,",
        "+ ",
        "        out.suit  = \"data.frame\",",
        "+ ",
        "        distances = TRUE,",
        "+ ",
        "        verbose   = FALSE",
        "+ ",
        "      )",
        "+ ",
        "      message(",
        "+ ",
        "        \"Suitability was not supplied; computed internally via get_suitable_env().\\n\",",
        "+ ",
        "        \"For repeated plots, consider calling get_suitable_env() once and passing \",",
        "+ ",
        "        \"the result to `suitable_env`.\"",
        "+ ",
        "      )",
        "+ ",
        "    } else {",
        "+ ",
        "      suitable_df <- NULL",
        "+ ",
        "    }",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  has_suitable <- !is.null(suitable_df)",
        "+ ",
        "  has_distance <- has_suitable && (\"dist_sq\" %in% names(suitable_df))",
        "+ ",
        "+ ",
        "  if (surface == \"dist\" && !has_distance) {",
        "+ ",
        "    stop(",
        "+ ",
        "      \"surface = 'dist' requested, but 'suitable_env' does not contain a 'dist_sq' column.\\n\",",
        "+ ",
        "      \"Run get_suitable_env(..., distances = TRUE) or provide a data.frame with 'dist_sq'.\"",
        "+ ",
        "    )",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  # ---- 4. Legend configuration --------------------------------------------",
        "+ ",
        "+ ",
        "  opts <- list(",
        "+ ",
        "    background_point = TRUE,",
        "+ ",
        "    suitable_point   = has_suitable,",
        "+ ",
        "    occurrence_point = !is.null(occ_pts)",
        "+ ",
        "  )",
        "+ ",
        "+ ",
        "  legend_items <- data.frame(",
        "+ ",
        "    id    = c(\"background_point\",\"suitable_point\",\"occurrence_point\"),",
        "+ ",
        "    type  = c(\"point\",\"point\",\"point\"),",
        "+ ",
        "    label = c(\"Background environments\",\"Suitable environments\",\"Occurrence\"),",
        "+ ",
        "    color = c(default_colors[[\"bg\"]],",
        "+ ",
        "      default_colors[[\"suitable_env\"]],",
        "+ ",
        "      default_colors[[\"occ_fill\"]]",
        "+ ",
        "    ),",
        "+ ",
        "    stringsAsFactors = FALSE",
        "+ ",
        "  )",
        "+ ",
        "+ ",
        "  active <- logical(nrow(legend_items))",
        "+ ",
        "  for (i in seq_len(nrow(legend_items))) {",
        "+ ",
        "    active[i] <- isTRUE(opts[[ legend_items$id[i] ]])",
        "+ ",
        "  }",
        "+ ",
        "  legend_items <- legend_items[active, , drop = FALSE]",
        "+ ",
        "+ ",
        "  if (nrow(legend_items) == 0) {",
        "+ ",
        "    legend_plot <- ggplot2::ggplot() + ggplot2::theme_void()",
        "+ ",
        "  } else {",
        "+ ",
        "    top_y   <- 2",
        "+ ",
        "    spacing <- 0.25",
        "+ ",
        "    x_point <- 0.00",
        "+ ",
        "+ ",
        "    legend_items <- legend_items %>%",
        "+ ",
        "      dplyr::mutate(",
        "+ ",
        "        row     = dplyr::row_number(),",
        "+ ",
        "        y       = top_y - (row - 1) * spacing,",
        "+ ",
        "        x_point = x_point,",
        "+ ",
        "        x_text  = 0.01",
        "+ ",
        "      )",
        "+ ",
        "+ ",
        "    legend_base <- ggplot2::ggplot() +",
        "+ ",
        "      ggplot2::coord_cartesian(xlim = c(0, 0.2), ylim = c(0, 2.5), clip = \"off\") +",
        "+ ",
        "      ggplot2::theme_void() +",
        "+ ",
        "      ggplot2::theme(legend.position = \"none\")",
        "+ ",
        "+ ",
        "    legend_plot <- legend_base +",
        "+ ",
        "      ggplot2::geom_point(",
        "+ ",
        "        data  = dplyr::filter(legend_items, type == \"point\"),",
        "+ ",
        "        ggplot2::aes(x = x_point, y = y, colour = color),",
        "+ ",
        "        size  = 2",
        "+ ",
        "      ) +",
        "+ ",
        "      ggplot2::geom_text(",
        "+ ",
        "        data  = legend_items,",
        "+ ",
        "        ggplot2::aes(x = x_text, y = y, label = label),",
        "+ ",
        "        hjust = 0",
        "+ ",
        "      ) +",
        "+ ",
        "      ggplot2::scale_colour_identity()",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  # ---- 5. Compute map extent: env_bg -> suitable_env -> occ_pts -----------",
        "+ ",
        "+ ",
        "  x_lim <- y_lim <- NULL",
        "+ ",
        "+ ",
        "  # 5A. Try env_bg first",
        "+ ",
        "  if (!is.null(env_bg)) {",
        "+ ",
        "    if (inherits(env_bg, \"Raster\")) {",
        "+ ",
        "      env_bg_r <- terra::rast(env_bg)",
        "+ ",
        "    } else if (inherits(env_bg, \"SpatRaster\")) {",
        "+ ",
        "      env_bg_r <- env_bg",
        "+ ",
        "    } else {",
        "+ ",
        "      env_bg_r <- NULL",
        "+ ",
        "    }",
        "+ ",
        "+ ",
        "    if (!is.null(env_bg_r)) {",
        "+ ",
        "      ex <- terra::ext(env_bg_r)",
        "+ ",
        "+ ",
        "      if (all(is.finite(as.vector(ex)))) {",
        "+ ",
        "        x_lim <- c(ex[1], ex[2])",
        "+ ",
        "        y_lim <- c(ex[3], ex[4])",
        "+ ",
        "      }",
        "+ ",
        "    } else if (is.data.frame(env_bg) || is.matrix(env_bg)) {",
        "+ ",
        "      env_bg_df <- as.data.frame(env_bg)",
        "+ ",
        "      if (all(c(\"x\", \"y\") %in% names(env_bg_df))) {",
        "+ ",
        "        coords <- env_bg_df[, c(\"x\", \"y\")]",
        "+ ",
        "        coords <- coords[stats::complete.cases(coords), , drop = FALSE]",
        "+ ",
        "        if (nrow(coords) > 0) {",
        "+ ",
        "          x_rng <- range(coords$x, na.rm = TRUE)",
        "+ ",
        "          y_rng <- range(coords$y, na.rm = TRUE)",
        "+ ",
        "          dx    <- x_rng[2] - x_rng[1]",
        "+ ",
        "          dy    <- y_rng[2] - y_rng[1]",
        "+ ",
        "          if (!is.finite(dx) || dx <= 0) dx <- 1",
        "+ ",
        "          if (!is.finite(dy) || dy <= 0) dy <- 1",
        "+ ",
        "          pad_x <- 0.05 * dx",
        "+ ",
        "          pad_y <- 0.05 * dy",
        "+ ",
        "          x_lim <- c(x_rng[1] - pad_x, x_rng[2] + pad_x)",
        "+ ",
        "          y_lim <- c(y_rng[1] - pad_y, y_rng[2] + pad_y)",
        "+ ",
        "        }",
        "+ ",
        "      }",
        "+ ",
        "    }",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  # 5B. If env_bg did not give an extent, use suitable_env coords",
        "+ ",
        "  if (is.null(x_lim) || is.null(y_lim)) {",
        "+ ",
        "    coord_sources <- list()",
        "+ ",
        "    if (has_suitable) {",
        "+ ",
        "      coord_sources[[length(coord_sources) + 1]] <- suitable_df[, c(\"x\", \"y\")]",
        "+ ",
        "    }",
        "+ ",
        "    if (!is.null(occ_pts) && all(c(\"x\", \"y\") %in% names(occ_pts))) {",
        "+ ",
        "      coord_sources[[length(coord_sources) + 1]] <- occ_pts[, c(\"x\", \"y\")]",
        "+ ",
        "    }",
        "+ ",
        "+ ",
        "    if (length(coord_sources) > 0) {",
        "+ ",
        "      coords <- do.call(rbind, coord_sources)",
        "+ ",
        "      coords <- coords[stats::complete.cases(coords), , drop = FALSE]",
        "+ ",
        "+ ",
        "      if (nrow(coords) > 0) {",
        "+ ",
        "        x_rng <- range(coords$x, na.rm = TRUE)",
        "+ ",
        "        y_rng <- range(coords$y, na.rm = TRUE)",
        "+ ",
        "        dx    <- x_rng[2] - x_rng[1]",
        "+ ",
        "        dy    <- y_rng[2] - y_rng[1]",
        "+ ",
        "        if (!is.finite(dx) || dx <= 0) dx <- 1",
        "+ ",
        "        if (!is.finite(dy) || dy <= 0) dy <- 1",
        "+ ",
        "        pad_x <- 0.1 * dx",
        "+ ",
        "        pad_y <- 0.1 * dy",
        "+ ",
        "        x_lim <- c(x_rng[1] - pad_x, x_rng[2] + pad_x)",
        "+ ",
        "        y_lim <- c(y_rng[1] - pad_y, y_rng[2] + pad_y)",
        "+ ",
        "      }",
        "+ ",
        "    }",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  # ---- 6. Basemap ----------------------------------------------------------",
        "+ ",
        "+ ",
        "  world <- ggplot2::map_data(\"world\")",
        "+ ",
        "+ ",
        "  base_map <- ggplot2::ggplot() +",
        "+ ",
        "    ggplot2::geom_polygon(",
        "+ ",
        "      data = world,",
        "+ ",
        "      ggplot2::aes(x = long, y = lat, group = group),",
        "+ ",
        "      fill = default_colors[[\"bg\"]]",
        "+ ",
        "    ) +",
        "+ ",
        "    ggplot2::xlab(\"Longitude\") +",
        "+ ",
        "    ggplot2::ylab(\"Latitude\") +",
        "+ ",
        "    ggplot2::theme_bw()",
        "+ ",
        "+ ",
        "  if (!is.null(x_lim) && !is.null(y_lim)) {",
        "+ ",
        "    base_map <- base_map +",
        "+ ",
        "      ggplot2::coord_quickmap(xlim = x_lim, ylim = y_lim, expand = FALSE)",
        "+ ",
        "  } else {",
        "+ ",
        "    base_map <- base_map +",
        "+ ",
        "      ggplot2::coord_quickmap()",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  # ---- 7. Occurrence points (convert to sf) --------------------------------",
        "+ ",
        "+ ",
        "  occ_pts_sp <- NULL",
        "+ ",
        "  if (!is.null(occ_pts)) {",
        "+ ",
        "    occ_pts_sp <- sf::st_as_sf(",
        "+ ",
        "      occ_pts[, c(\"x\", \"y\")],",
        "+ ",
        "      coords = c(\"x\", \"y\"),",
        "+ ",
        "      crs    = 4326",
        "+ ",
        "    )",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  add_occ <- function(p) {",
        "+ ",
        "    if (!is.null(occ_pts_sp)) {",
        "+ ",
        "      p <- p +",
        "+ ",
        "        ggplot2::geom_sf(",
        "+ ",
        "          data  = occ_pts_sp,",
        "+ ",
        "          ggplot2::aes(geometry = geometry),",
        "+ ",
        "          color = default_colors[[\"occ_stroke\"]],",
        "+ ",
        "          fill  = default_colors[[\"occ_fill\"]],",
        "+ ",
        "          pch   = 21,",
        "+ ",
        "          size  = 0.75",
        "+ ",
        "        )",
        "+ ",
        "    }",
        "+ ",
        "    p",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  # ---- 8. Build one or two map panels -------------------------------------",
        "+ ",
        "+ ",
        "  map_list <- list()",
        "+ ",
        "+ ",
        "  # Panel 1: binary suitable (presence-only tiles)",
        "+ ",
        "  if (has_suitable && surface %in% c(\"both\", \"suit\")) {",
        "+ ",
        "    p_suit <- base_map +",
        "+ ",
        "      ggplot2::geom_tile(",
        "+ ",
        "        data = suitable_df,",
        "+ ",
        "        ggplot2::aes(x = x, y = y),",
        "+ ",
        "        fill = default_colors[[\"suitable_env\"]]",
        "+ ",
        "      ) +",
        "+ ",
        "      ggplot2::ggtitle(\"Suitable Environments\")",
        "+ ",
        "+ ",
        "    p_suit <- add_occ(p_suit)",
        "+ ",
        "    map_list[[\"suitable\"]] <- p_suit",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  # Panel 2: distance surface",
        "+ ",
        "  if (has_distance && surface %in% c(\"both\", \"dist\")) {",
        "+ ",
        "    p_dist <- base_map +",
        "+ ",
        "      # ggplot2::geom_tile(",
        "+ ",
        "      #   data = suitable_df,",
        "+ ",
        "      #   ggplot2::aes(x = x, y = y, fill = dist_sq)",
        "+ ",
        "      # ) +",
        "+ ",
        "      ggplot2::scale_fill_distiller(",
        "+ ",
        "        name    = \"Distance to centroid\",",
        "+ ",
        "        palette = default_colors[[\"dist\"]]",
        "+ ",
        "      ) +",
        "+ ",
        "      ggplot2::ggtitle(\"Distance surface\") +",
        "+ ",
        "      ggplot2::theme(legend.position = \"bottom\")",
        "+ ",
        "+ ",
        "    p_dist <- add_occ(p_dist)",
        "+ ",
        "    map_list[[\"dist_sq\"]] <- p_dist",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  # If no suitability at all, just show basemap + occurrences",
        "+ ",
        "  if (length(map_list) == 0L) {",
        "+ ",
        "    p_base <- add_occ(base_map)",
        "+ ",
        "    return(ggpubr::ggarrange(p_base, legend_plot, widths = c(0.7, 0.3)))",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  # ---- 9. Arrange panels + legend -----------------------------------------",
        "+ ",
        "+ ",
        "  if (length(map_list) == 1L) {",
        "+ ",
        "    main_panel <- map_list[[1]]",
        "+ ",
        "+ ",
        "    return(ggpubr::ggarrange(main_panel,",
        "+ ",
        "                             legend_plot,",
        "+ ",
        "                             ncol    = 1,",
        "+ ",
        "                             heights = c(0.7, 0.3)))",
        "+ ",
        "+ ",
        "  } else {",
        "+ ",
        "+ ",
        "    main_panel <- ggpubr::ggarrange(",
        "+ ",
        "      plotlist = map_list,",
        "+ ",
        "      nrow     = length(map_list),",
        "+ ",
        "      labels   = NULL,",
        "+ ",
        "      heights  = c(0.45, 0.55)",
        "+ ",
        "    )",
        "+ ",
        "+ ",
        "    return(ggpubr::ggarrange(main_panel,",
        "+ ",
        "                             legend_plot,",
        "+ ",
        "                             ncol    = 1,",
        "+ ",
        "                             heights = c(0.8, 0.2)))",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "}",
        "> ",
        "plot_g_space(env_bg = env_stack_small,",
        "+ ",
        "             suitable_env = suitable_area_t1)",
        "> ",
        "gc()",
        "             used    (Mb) gc trigger    (Mb)   max used\nNcells    4945612   264.2   16639454   888.7   37274142\nVcells 1522343425 11614.6 3598670520 27455.7 3595506651\n          (Mb)\nNcells  1990.7\nVcells 27431.6\n",
        "> ",
        "#' Plot Geographic Space with Optional Suitability/Distance and Occurrences",
        "> ",
        "#'",
        "> ",
        "#' Draws a basemap and overlays (a) suitable environments as tiles,",
        "> ",
        "#' (b) an optional continuous distance-to-centroid surface, and/or (c)",
        "> ",
        "#' occurrence points. The map extent is primarily inferred from \\code{env_bg}",
        "> ",
        "#' (if available), otherwise from the coordinates in \\code{suitable_env} and",
        "> ",
        "#' finally from \\code{occ_pts}, always with a small buffer where needed.",
        "> ",
        "#'",
        "> ",
        "#' @param env_bg Optional background environment object used when",
        "> ",
        "#'   \\code{suitable_env} is not supplied and suitability must be computed.",
        "> ",
        "#'   Typically a \\code{terra::SpatRaster} (or \\code{raster::Raster*}).",
        "> ",
        "#' @param suitable_env Optional precomputed suitable environment object. Can be:",
        "> ",
        "#'   \\itemize{",
        "> ",
        "#'     \\item a \\code{data.frame} with columns \\code{x}, \\code{y}, and optionally \\code{dist_sq},",
        "> ",
        "#'     \\item a \\code{\"suitable_env\"} object returned by \\code{\\link{get_suitable_env}}",
        "> ",
        "#'           with a \\code{suitable_env_df} or \\code{suitable_env_sp} component,",
        "> ",
        "#'     \\item a \\code{terra::SpatRaster} or a list of \\code{terra::SpatRaster} objects.",
        "> ",
        "#'   }",
        "> ",
        "#'   When a data.frame is used, it is assumed that each row corresponds to a",
        "> ",
        "#'   suitable cell (i.e. presence-only). When \\code{dist_sq} is present, a",
        "> ",
        "#'   distance panel can also be drawn.",
        "> ",
        "#' @param occ_pts Optional \\code{data.frame} of occurrences with columns",
        "> ",
        "#'   \\code{x}, \\code{y} (assumed longitude/latitude, WGS84). Plotted as points",
        "> ",
        "#'   if supplied. If \\code{vs} is supplied and \\code{occ_pts} is \\code{NULL},",
        "> ",
        "#'   the function will try to use \\code{vs$occurrences}.",
        "> ",
        "#' @param show.occ.density Logical (currently unused; reserved for future",
        "> ",
        "#'   density panels).",
        "> ",
        "#' @param colors Optional named list to override aesthetics. Recognized names:",
        "> ",
        "#'   \\code{bg} (basemap fill), \\code{suitable_env} (suitable tiles),",
        "> ",
        "#'   \\code{occ_fill}, \\code{occ_stroke}, and \\code{dist} (RColorBrewer palette",
        "> ",
        "#'   name for distance tiles).",
        "> ",
        "#' @param palette Character palette key. One of \\code{\"default\"},",
        "> ",
        "#'   \\code{\"palette2\"}, or \\code{\"palette3\"}.",
        "> ",
        "#' @param surface Character; which surface(s) to plot. One of:",
        "> ",
        "#'   \\itemize{",
        "> ",
        "#'     \\item \\code{\"both\"}: show suitability tiles and (if available) distance tiles,",
        "> ",
        "#'     \\item \\code{\"suit\"}: show only suitability tiles,",
        "> ",
        "#'     \\item \\code{\"dist\"}: show only the distance-to-centroid surface",
        "> ",
        "#'           (requires a \\code{dist_sq} column).",
        "> ",
        "#'   }",
        "> ",
        "#' @param vs Optional object of class \\code{\"NicheR_species\"} created by",
        "> ",
        "#'   \\code{\\link{create_virtual_species}}. When provided, any of",
        "> ",
        "#'   \\code{env_bg}, \\code{niche}, \\code{occ_pts}, or \\code{suitable_env} that",
        "> ",
        "#'   are \\code{NULL} will be filled from this object if possible.",
        "> ",
        "#' @param niche Optional object of class \\code{\"ellipsoid\"} (from",
        "> ",
        "#'   \\code{\\link{build_ellps}}). Required when suitability is computed internally",
        "> ",
        "#'   (i.e., when \\code{suitable_env} is \\code{NULL}).",
        "> ",
        "#'",
        "> ",
        "#' @return A \\code{ggpubr} object produced by \\code{\\link[ggpubr]{ggarrange}},",
        "> ",
        "#'   containing one or two map panels plus a matching legend panel.",
        "> ",
        "#'",
        "> ",
        "#' @family plotting functions",
        "> ",
        "#' @seealso \\code{\\link{build_ellps}}, \\code{\\link{get_suitable_env}},",
        "> ",
        "#'   \\code{\\link{create_virtual_species}}",
        "> ",
        "#'",
        "> ",
        "#' @export",
        "> ",
        "plot_g_space <- function(env_bg = NULL,",
        "+ ",
        "                         suitable_env = NULL,",
        "+ ",
        "                         occ_pts = NULL,",
        "+ ",
        "                         show.occ.density = FALSE,",
        "+ ",
        "                         colors = NULL,",
        "+ ",
        "                         palette = \"default\",",
        "+ ",
        "                         surface = c(\"both\", \"suit\", \"dist\"),",
        "+ ",
        "                         vs = NULL,",
        "+ ",
        "                         niche = NULL) {",
        "+ ",
        "+ ",
        "  surface <- match.arg(surface)",
        "+ ",
        "+ ",
        "  # ---- 0. Pull components from NicheR_species if provided -----------------",
        "+ ",
        "  if (!is.null(vs)) {",
        "+ ",
        "    if (!inherits(vs, \"NicheR_species\")) {",
        "+ ",
        "      stop(\"'vs' must be an object of class 'NicheR_species' created by create_virtual_species().\")",
        "+ ",
        "    }",
        "+ ",
        "+ ",
        "    if (is.null(env_bg) && !is.null(vs$call_args) && \"env_bg\" %in% names(vs$call_args)) {",
        "+ ",
        "      env_bg <- vs$call_args$env_bg",
        "+ ",
        "    }",
        "+ ",
        "    if (is.null(niche) && !is.null(vs$niche)) {",
        "+ ",
        "      niche <- vs$niche",
        "+ ",
        "    }",
        "+ ",
        "    if (is.null(occ_pts) && !is.null(vs$occurrences)) {",
        "+ ",
        "      occ_pts <- vs$occurrences",
        "+ ",
        "    }",
        "+ ",
        "    if (is.null(suitable_env) && !is.null(vs$suitability)) {",
        "+ ",
        "      suitable_env <- vs$suitability",
        "+ ",
        "    }",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  # ---- 1. Palette / color handling ----------------------------------------",
        "+ ",
        "  palettes <- list(",
        "+ ",
        "    default = list(",
        "+ ",
        "      bg           = \"#F0F0F0FF\",",
        "+ ",
        "      suitable_env = \"#FED789FF\",",
        "+ ",
        "      occ_fill     = \"#B4BF3AFF\",",
        "+ ",
        "      occ_stroke   = \"black\",",
        "+ ",
        "      dist         = \"YlOrRd\"   # brewer palette name",
        "+ ",
        "    ),",
        "+ ",
        "    palette2 = list(",
        "+ ",
        "      bg           = \"#E0ECF4FF\",",
        "+ ",
        "      suitable_env = \"#9ECAE1FF\",",
        "+ ",
        "      occ_fill     = \"#08519CFF\",",
        "+ ",
        "      occ_stroke   = \"#08306BFF\",",
        "+ ",
        "      dist         = \"YlGnBu\"",
        "+ ",
        "    ),",
        "+ ",
        "    palette3 = list(",
        "+ ",
        "      bg           = \"#F0F0F0FF\",",
        "+ ",
        "      suitable_env = \"#BDBDBDFF\",",
        "+ ",
        "      occ_fill     = \"#252525FF\",",
        "+ ",
        "      occ_stroke   = \"#000000FF\",",
        "+ ",
        "      dist         = \"OrRd\"",
        "+ ",
        "    )",
        "+ ",
        "  )",
        "+ ",
        "+ ",
        "  if (!palette %in% names(palettes)) {",
        "+ ",
        "    stop(\"Unknown palette '\", palette, \"'. Use one of: \",",
        "+ ",
        "         paste(names(palettes), collapse = \", \"), \".\")",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  base_colors <- palettes[[palette]]",
        "+ ",
        "+ ",
        "  if (is.null(colors)) {",
        "+ ",
        "    default_colors <- base_colors",
        "+ ",
        "  } else {",
        "+ ",
        "    if (is.null(names(colors))) {",
        "+ ",
        "      names(colors) <- names(base_colors)[seq_along(colors)]",
        "+ ",
        "      if (!is.list(colors)) colors <- as.list(colors)",
        "+ ",
        "      message(",
        "+ ",
        "        \"No names detected in 'colors'. Using the provided order and filling \",",
        "+ ",
        "        \"missing entries with defaults.\\n\",",
        "+ ",
        "        \"Named options are: \",",
        "+ ",
        "        paste(names(base_colors), collapse = \", \"), \".\"",
        "+ ",
        "      )",
        "+ ",
        "    }",
        "+ ",
        "    if (!is.list(colors)) colors <- as.list(colors)",
        "+ ",
        "    default_colors <- utils::modifyList(base_colors, colors)",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  # ---- 2. Occurrence points validation ------------------------------------",
        "+ ",
        "+ ",
        "  if (!is.null(occ_pts) && !all(c(\"x\", \"y\") %in% names(occ_pts))) {",
        "+ ",
        "    stop(\"`occ_pts` must have columns named 'x' and 'y'.\")",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  # ---- 3. Standardize suitable_env into a data.frame ----------------------",
        "+ ",
        "+ ",
        "  suitable_df <- NULL",
        "+ ",
        "+ ",
        "  if (!is.null(suitable_env)) {",
        "+ ",
        "+ ",
        "    # Case 1: plain data.frame / matrix",
        "+ ",
        "    if (is.data.frame(suitable_env) || is.matrix(suitable_env)) {",
        "+ ",
        "+ ",
        "      suitable_df <- as.data.frame(suitable_env)",
        "+ ",
        "+ ",
        "      # Case 2: \"suitable_env\" style object",
        "+ ",
        "    } else if (is.list(suitable_env) &&",
        "+ ",
        "               any(c(\"suitable_env_df\", \"suitable_env_sp\") %in% names(suitable_env))) {",
        "+ ",
        "+ ",
        "      if (\"suitable_env_df\" %in% names(suitable_env) &&",
        "+ ",
        "          is.data.frame(suitable_env$suitable_env_df)) {",
        "+ ",
        "+ ",
        "        suitable_df <- suitable_env$suitable_env_df",
        "+ ",
        "+ ",
        "      } else if (\"suitable_env_sp\" %in% names(suitable_env)) {",
        "+ ",
        "+ ",
        "        sp <- suitable_env$suitable_env_sp",
        "+ ",
        "        if (inherits(sp, \"Raster\")) {",
        "+ ",
        "          sp <- terra::rast(sp)",
        "+ ",
        "        }",
        "+ ",
        "+ ",
        "        if (inherits(sp, \"SpatRaster\")) {",
        "+ ",
        "          rast_stack <- sp",
        "+ ",
        "        } else if (is.list(sp) &&",
        "+ ",
        "                   length(sp) > 0 &&",
        "+ ",
        "                   all(vapply(sp, inherits, logical(1), \"SpatRaster\"))) {",
        "+ ",
        "+ ",
        "          rast_stack <- do.call(c, sp)",
        "+ ",
        "        } else {",
        "+ ",
        "          stop(",
        "+ ",
        "            \"'suitable_env$suitable_env_sp' must be a SpatRaster or a list of SpatRasters \",",
        "+ ",
        "            \"when no 'suitable_env_df' is present.\"",
        "+ ",
        "          )",
        "+ ",
        "        }",
        "+ ",
        "+ ",
        "        suitable_df <- as.data.frame.nicheR(rast_stack)",
        "+ ",
        "      } else {",
        "+ ",
        "        stop(",
        "+ ",
        "          \"`suitable_env` list must contain either 'suitable_env_df' or 'suitable_env_sp'.\"",
        "+ ",
        "        )",
        "+ ",
        "      }",
        "+ ",
        "+ ",
        "      # Case 3: Raster / SpatRaster / list of SpatRasters directly",
        "+ ",
        "    } else {",
        "+ ",
        "+ ",
        "      if (inherits(suitable_env, \"Raster\")) {",
        "+ ",
        "        suitable_env <- terra::rast(suitable_env)",
        "+ ",
        "      }",
        "+ ",
        "+ ",
        "      if (inherits(suitable_env, \"SpatRaster\")) {",
        "+ ",
        "+ ",
        "        rast_stack <- suitable_env",
        "+ ",
        "+ ",
        "      } else if (is.list(suitable_env) &&",
        "+ ",
        "                 length(suitable_env) > 0 &&",
        "+ ",
        "                 all(vapply(suitable_env, inherits, logical(1), \"SpatRaster\"))) {",
        "+ ",
        "+ ",
        "        rast_stack <- do.call(c, suitable_env)",
        "+ ",
        "+ ",
        "      } else {",
        "+ ",
        "        stop(",
        "+ ",
        "          \"`suitable_env` must be either:\\n\",",
        "+ ",
        "          \"  * a data.frame with columns 'x', 'y' (and optionally 'dist_sq'), or\\n\",",
        "+ ",
        "          \"  * a 'suitable_env' object with 'suitable_env_df' or 'suitable_env_sp', or\\n\",",
        "+ ",
        "          \"  * a SpatRaster / list of SpatRasters.\\n\"",
        "+ ",
        "        )",
        "+ ",
        "      }",
        "+ ",
        "+ ",
        "      suitable_df <- as.data.frame.nicheR(rast_stack)",
        "+ ",
        "    }",
        "+ ",
        "+ ",
        "    # sanity check for coordinates",
        "+ ",
        "    if (!all(c(\"x\", \"y\") %in% names(suitable_df))) {",
        "+ ",
        "      stop(\"`suitable_env` (after coercion) must contain 'x' and 'y' columns.\")",
        "+ ",
        "    }",
        "+ ",
        "+ ",
        "  } else {",
        "+ ",
        "    # no suitable_env provided; fall back to internal computation if possible",
        "+ ",
        "    if (!is.null(niche) && !is.null(env_bg)) {",
        "+ ",
        "      suitable_df <- get_suitable_env(",
        "+ ",
        "        niche     = niche,",
        "+ ",
        "        env_bg    = env_bg,",
        "+ ",
        "        out.suit  = \"data.frame\",",
        "+ ",
        "        distances = TRUE,",
        "+ ",
        "        verbose   = FALSE",
        "+ ",
        "      )",
        "+ ",
        "      message(",
        "+ ",
        "        \"Suitability was not supplied; computed internally via get_suitable_env().\\n\",",
        "+ ",
        "        \"For repeated plots, consider calling get_suitable_env() once and passing \",",
        "+ ",
        "        \"the result to `suitable_env`.\"",
        "+ ",
        "      )",
        "+ ",
        "    } else {",
        "+ ",
        "      suitable_df <- NULL",
        "+ ",
        "    }",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  has_suitable <- !is.null(suitable_df)",
        "+ ",
        "  has_distance <- has_suitable && (\"dist_sq\" %in% names(suitable_df))",
        "+ ",
        "+ ",
        "  if (surface == \"dist\" && !has_distance) {",
        "+ ",
        "    stop(",
        "+ ",
        "      \"surface = 'dist' requested, but 'suitable_env' does not contain a 'dist_sq' column.\\n\",",
        "+ ",
        "      \"Run get_suitable_env(..., distances = TRUE) or provide a data.frame with 'dist_sq'.\"",
        "+ ",
        "    )",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  # ---- 4. Legend configuration --------------------------------------------",
        "+ ",
        "+ ",
        "  opts <- list(",
        "+ ",
        "    background_point = TRUE,",
        "+ ",
        "    suitable_point   = has_suitable,",
        "+ ",
        "    occurrence_point = !is.null(occ_pts)",
        "+ ",
        "  )",
        "+ ",
        "+ ",
        "  legend_items <- data.frame(",
        "+ ",
        "    id    = c(\"background_point\",\"suitable_point\",\"occurrence_point\"),",
        "+ ",
        "    type  = c(\"point\",\"point\",\"point\"),",
        "+ ",
        "    label = c(\"Background environments\",\"Suitable environments\",\"Occurrence\"),",
        "+ ",
        "    color = c(default_colors[[\"bg\"]],",
        "+ ",
        "      default_colors[[\"suitable_env\"]],",
        "+ ",
        "      default_colors[[\"occ_fill\"]]",
        "+ ",
        "    ),",
        "+ ",
        "    stringsAsFactors = FALSE",
        "+ ",
        "  )",
        "+ ",
        "+ ",
        "  active <- logical(nrow(legend_items))",
        "+ ",
        "  for (i in seq_len(nrow(legend_items))) {",
        "+ ",
        "    active[i] <- isTRUE(opts[[ legend_items$id[i] ]])",
        "+ ",
        "  }",
        "+ ",
        "  legend_items <- legend_items[active, , drop = FALSE]",
        "+ ",
        "+ ",
        "  if (nrow(legend_items) == 0) {",
        "+ ",
        "    legend_plot <- ggplot2::ggplot() + ggplot2::theme_void()",
        "+ ",
        "  } else {",
        "+ ",
        "    top_y   <- 2",
        "+ ",
        "    spacing <- 0.25",
        "+ ",
        "    x_point <- 0.00",
        "+ ",
        "+ ",
        "    legend_items <- legend_items %>%",
        "+ ",
        "      dplyr::mutate(",
        "+ ",
        "        row     = dplyr::row_number(),",
        "+ ",
        "        y       = top_y - (row - 1) * spacing,",
        "+ ",
        "        x_point = x_point,",
        "+ ",
        "        x_text  = 0.01",
        "+ ",
        "      )",
        "+ ",
        "+ ",
        "    legend_base <- ggplot2::ggplot() +",
        "+ ",
        "      ggplot2::coord_cartesian(xlim = c(0, 0.2), ylim = c(0, 2.5), clip = \"off\") +",
        "+ ",
        "      ggplot2::theme_void() +",
        "+ ",
        "      ggplot2::theme(legend.position = \"none\")",
        "+ ",
        "+ ",
        "    legend_plot <- legend_base +",
        "+ ",
        "      ggplot2::geom_point(",
        "+ ",
        "        data  = dplyr::filter(legend_items, type == \"point\"),",
        "+ ",
        "        ggplot2::aes(x = x_point, y = y, colour = color),",
        "+ ",
        "        size  = 2",
        "+ ",
        "      ) +",
        "+ ",
        "      ggplot2::geom_text(",
        "+ ",
        "        data  = legend_items,",
        "+ ",
        "        ggplot2::aes(x = x_text, y = y, label = label),",
        "+ ",
        "        hjust = 0",
        "+ ",
        "      ) +",
        "+ ",
        "      ggplot2::scale_colour_identity()",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  # ---- 5. Compute map extent: env_bg -> suitable_env -> occ_pts -----------",
        "+ ",
        "+ ",
        "  x_lim <- y_lim <- NULL",
        "+ ",
        "+ ",
        "  # 5A. Try env_bg first",
        "+ ",
        "  if (!is.null(env_bg)) {",
        "+ ",
        "    if (inherits(env_bg, \"Raster\")) {",
        "+ ",
        "      env_bg_r <- terra::rast(env_bg)",
        "+ ",
        "    } else if (inherits(env_bg, \"SpatRaster\")) {",
        "+ ",
        "      env_bg_r <- env_bg",
        "+ ",
        "    } else {",
        "+ ",
        "      env_bg_r <- NULL",
        "+ ",
        "    }",
        "+ ",
        "+ ",
        "    if (!is.null(env_bg_r)) {",
        "+ ",
        "      ex <- terra::ext(env_bg_r)",
        "+ ",
        "+ ",
        "      if (all(is.finite(as.vector(ex)))) {",
        "+ ",
        "        x_lim <- c(ex[1], ex[2])",
        "+ ",
        "        y_lim <- c(ex[3], ex[4])",
        "+ ",
        "      }",
        "+ ",
        "    } else if (is.data.frame(env_bg) || is.matrix(env_bg)) {",
        "+ ",
        "      env_bg_df <- as.data.frame(env_bg)",
        "+ ",
        "      if (all(c(\"x\", \"y\") %in% names(env_bg_df))) {",
        "+ ",
        "        coords <- env_bg_df[, c(\"x\", \"y\")]",
        "+ ",
        "        coords <- coords[stats::complete.cases(coords), , drop = FALSE]",
        "+ ",
        "        if (nrow(coords) > 0) {",
        "+ ",
        "          x_rng <- range(coords$x, na.rm = TRUE)",
        "+ ",
        "          y_rng <- range(coords$y, na.rm = TRUE)",
        "+ ",
        "          dx    <- x_rng[2] - x_rng[1]",
        "+ ",
        "          dy    <- y_rng[2] - y_rng[1]",
        "+ ",
        "          if (!is.finite(dx) || dx <= 0) dx <- 1",
        "+ ",
        "          if (!is.finite(dy) || dy <= 0) dy <- 1",
        "+ ",
        "          pad_x <- 0.05 * dx",
        "+ ",
        "          pad_y <- 0.05 * dy",
        "+ ",
        "          x_lim <- c(x_rng[1] - pad_x, x_rng[2] + pad_x)",
        "+ ",
        "          y_lim <- c(y_rng[1] - pad_y, y_rng[2] + pad_y)",
        "+ ",
        "        }",
        "+ ",
        "      }",
        "+ ",
        "    }",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  # 5B. If env_bg did not give an extent, use suitable_env coords",
        "+ ",
        "  if (is.null(x_lim) || is.null(y_lim)) {",
        "+ ",
        "    coord_sources <- list()",
        "+ ",
        "    if (has_suitable) {",
        "+ ",
        "      coord_sources[[length(coord_sources) + 1]] <- suitable_df[, c(\"x\", \"y\")]",
        "+ ",
        "    }",
        "+ ",
        "    if (!is.null(occ_pts) && all(c(\"x\", \"y\") %in% names(occ_pts))) {",
        "+ ",
        "      coord_sources[[length(coord_sources) + 1]] <- occ_pts[, c(\"x\", \"y\")]",
        "+ ",
        "    }",
        "+ ",
        "+ ",
        "    if (length(coord_sources) > 0) {",
        "+ ",
        "      coords <- do.call(rbind, coord_sources)",
        "+ ",
        "      coords <- coords[stats::complete.cases(coords), , drop = FALSE]",
        "+ ",
        "+ ",
        "      if (nrow(coords) > 0) {",
        "+ ",
        "        x_rng <- range(coords$x, na.rm = TRUE)",
        "+ ",
        "        y_rng <- range(coords$y, na.rm = TRUE)",
        "+ ",
        "        dx    <- x_rng[2] - x_rng[1]",
        "+ ",
        "        dy    <- y_rng[2] - y_rng[1]",
        "+ ",
        "        if (!is.finite(dx) || dx <= 0) dx <- 1",
        "+ ",
        "        if (!is.finite(dy) || dy <= 0) dy <- 1",
        "+ ",
        "        pad_x <- 0.1 * dx",
        "+ ",
        "        pad_y <- 0.1 * dy",
        "+ ",
        "        x_lim <- c(x_rng[1] - pad_x, x_rng[2] + pad_x)",
        "+ ",
        "        y_lim <- c(y_rng[1] - pad_y, y_rng[2] + pad_y)",
        "+ ",
        "      }",
        "+ ",
        "    }",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  # ---- 6. Basemap ----------------------------------------------------------",
        "+ ",
        "+ ",
        "  world <- ggplot2::map_data(\"world\")",
        "+ ",
        "+ ",
        "  base_map <- ggplot2::ggplot() +",
        "+ ",
        "    ggplot2::geom_polygon(",
        "+ ",
        "      data = world,",
        "+ ",
        "      ggplot2::aes(x = long, y = lat, group = group),",
        "+ ",
        "      fill = default_colors[[\"bg\"]]",
        "+ ",
        "    ) +",
        "+ ",
        "    ggplot2::xlab(\"Longitude\") +",
        "+ ",
        "    ggplot2::ylab(\"Latitude\") +",
        "+ ",
        "    ggplot2::theme_bw()",
        "+ ",
        "+ ",
        "  if (!is.null(x_lim) && !is.null(y_lim)) {",
        "+ ",
        "    base_map <- base_map +",
        "+ ",
        "      ggplot2::coord_quickmap(xlim = x_lim, ylim = y_lim, expand = FALSE)",
        "+ ",
        "  } else {",
        "+ ",
        "    base_map <- base_map +",
        "+ ",
        "      ggplot2::coord_quickmap()",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  # ---- 7. Occurrence points (convert to sf) --------------------------------",
        "+ ",
        "+ ",
        "  occ_pts_sp <- NULL",
        "+ ",
        "  if (!is.null(occ_pts)) {",
        "+ ",
        "    occ_pts_sp <- sf::st_as_sf(",
        "+ ",
        "      occ_pts[, c(\"x\", \"y\")],",
        "+ ",
        "      coords = c(\"x\", \"y\"),",
        "+ ",
        "      crs    = 4326",
        "+ ",
        "    )",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  add_occ <- function(p) {",
        "+ ",
        "    if (!is.null(occ_pts_sp)) {",
        "+ ",
        "      p <- p +",
        "+ ",
        "        ggplot2::geom_sf(",
        "+ ",
        "          data  = occ_pts_sp,",
        "+ ",
        "          ggplot2::aes(geometry = geometry),",
        "+ ",
        "          color = default_colors[[\"occ_stroke\"]],",
        "+ ",
        "          fill  = default_colors[[\"occ_fill\"]],",
        "+ ",
        "          pch   = 21,",
        "+ ",
        "          size  = 0.75",
        "+ ",
        "        )",
        "+ ",
        "    }",
        "+ ",
        "    p",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  # ---- 8. Build one or two map panels -------------------------------------",
        "+ ",
        "+ ",
        "  map_list <- list()",
        "+ ",
        "+ ",
        "  # Panel 1: binary suitable (presence-only tiles)",
        "+ ",
        "  if (has_suitable && surface %in% c(\"both\", \"suit\")) {",
        "+ ",
        "    p_suit <- base_map +",
        "+ ",
        "      ggplot2::geom_tile(",
        "+ ",
        "        data = suitable_df,",
        "+ ",
        "        ggplot2::aes(x = x, y = y),",
        "+ ",
        "        fill = default_colors[[\"suitable_env\"]]",
        "+ ",
        "      ) +",
        "+ ",
        "      ggplot2::ggtitle(\"Suitable Environments\")",
        "+ ",
        "+ ",
        "    p_suit <- add_occ(p_suit)",
        "+ ",
        "    map_list[[\"suitable\"]] <- p_suit",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  # Panel 2: distance surface",
        "+ ",
        "  if (has_distance && surface %in% c(\"both\", \"dist\")) {",
        "+ ",
        "    p_dist <- base_map +",
        "+ ",
        "      ggplot2::geom_tile(",
        "+ ",
        "        data = suitable_df,",
        "+ ",
        "        ggplot2::aes(x = x, y = y, fill = dist_sq)",
        "+ ",
        "      ) +",
        "+ ",
        "      ggplot2::scale_fill_distiller(",
        "+ ",
        "        name    = \"Distance to centroid\",",
        "+ ",
        "        palette = default_colors[[\"dist\"]]",
        "+ ",
        "      ) +",
        "+ ",
        "      ggplot2::ggtitle(\"Distance surface\") +",
        "+ ",
        "      ggplot2::theme(legend.position = \"bottom\")",
        "+ ",
        "+ ",
        "    p_dist <- add_occ(p_dist)",
        "+ ",
        "    map_list[[\"dist_sq\"]] <- p_dist",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  # If no suitability at all, just show basemap + occurrences",
        "+ ",
        "  if (length(map_list) == 0L) {",
        "+ ",
        "    p_base <- add_occ(base_map)",
        "+ ",
        "    return(ggpubr::ggarrange(p_base, legend_plot, widths = c(0.7, 0.3)))",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  # ---- 9. Arrange panels + legend -----------------------------------------",
        "+ ",
        "+ ",
        "  if (length(map_list) == 1L) {",
        "+ ",
        "    main_panel <- map_list[[1]]",
        "+ ",
        "+ ",
        "    return(ggpubr::ggarrange(main_panel,",
        "+ ",
        "                             legend_plot,",
        "+ ",
        "                             ncol    = 1,",
        "+ ",
        "                             heights = c(0.7, 0.3)))",
        "+ ",
        "+ ",
        "  } else {",
        "+ ",
        "+ ",
        "    main_panel <- ggpubr::ggarrange(",
        "+ ",
        "      plotlist = map_list,",
        "+ ",
        "      nrow     = length(map_list),",
        "+ ",
        "      labels   = NULL,",
        "+ ",
        "      heights  = c(0.45, 0.55)",
        "+ ",
        "    )",
        "+ ",
        "+ ",
        "    return(ggpubr::ggarrange(main_panel,",
        "+ ",
        "                             legend_plot,",
        "+ ",
        "                             ncol    = 1,",
        "+ ",
        "                             heights = c(0.8, 0.2)))",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "}",
        "> ",
        "plot_g_space(env_bg = env_stack_small,",
        "+ ",
        "             suitable_env = suitable_area_t1)",
        "> ",
        "# Load or read in the environmetal conditions",
        "> ",
        "bio_1 <- terra::rast(system.file(\"extdata\", \"Bio1.tif\", package = \"NicheR\"))",
        "> ",
        "bio_4 <- terra::rast(system.file(\"extdata\", \"Bio4.tif\", package = \"NicheR\"))",
        "> ",
        "bio_12 <- terra::rast(system.file(\"extdata\", \"Bio12.tif\", package = \"NicheR\"))",
        "> ",
        "# Stack and name the environmental layers",
        "> ",
        "env_stack_small <- c(bio_1, bio_12, bio_4)",
        "> ",
        "names(env_stack_small) <- c(\"mean_temp\", \"temp_seasonality\", \"annual_precip\")",
        "> ",
        "# Define niche parameters",
        "> ",
        "niche_center <- c(mean_temp = 200,",
        "+ ",
        "                  temp_seasonality = 1000,",
        "+ ",
        "                  annual_precip = 6500)",
        "> ",
        "niche_axes <- c(75, 250, 2000) ",
        "> ",
        "vs_1 <- create_virtual_species(env_bg = env_stack_small,",
        "+ ",
        "                               center = niche_center,",
        "+ ",
        "                               axes = niche_axes,",
        "+ ",
        "                               n_occ = 75,",
        "+ ",
        "                               bias_surface = c(sp_rich, nighttime),",
        "+ ",
        "                               bias_dir = c(1, -1),",
        "+ ",
        "                               out.suit = \"both\",",
        "+ ",
        "                               out.bias = \"both\",",
        "+ ",
        "                               distances = TRUE,",
        "+ ",
        "                               out.file = TRUE)",
        "\u001BG3;Built niche object.\n\u001Bg\u001BG3;Starting get_suitable_env()...\n\u001Bg\u001BG3;Preparing environmental background...\n\u001Bg\u001BG3;env_bg is a SpatRaster. Estimating size for data.frame conversion...\n\u001Bg\u001BG3;Estimated size ~851 MB. Converting raster to data.frame with as.data.frame.nicheR()...\n\u001Bg\u001BG3;Estimated raster size ~ 425.52 MB (37182370 cells x 3 layers)\n\u001Bg\u001BG3;Using in-memory terra::as.data.frame (below threshold).\n\u001Bg\u001BG3;Using 3 predictor columns for the ellipsoid.\n\u001Bg\u001BG3;Subsetting to the ellipsoid bounding box in E space.",
        "..\n\u001Bg\u001BG3;Bounding box subsetting reduced data from 12412229 to 1070550 rows.\n\u001Bg\u001BG3;1070550 rows have complete predictor values. Computing Mahalanobis distances...\n\u001Bg\u001BG3;310771 points fall inside the ellipsoid.\n\u001Bg\u001BG3;Building spatial output...\n\u001Bg\u001BG3;Using original SpatRaster as template for spatial output.\n\u001Bg\u001BG3;Also creating distance raster (dist_sq).\n\u001Bg\u001BG3;Finished get_suitable_env().\n\u001Bg\u001BG3;Computed suitable environments.\n\u001Bg\u001BG1;\u001BH1;Error\u001Bh in value[[3L]](cond) : \n  set_bias_surface failed: unused argument ",
        "(template = new(\"SpatRaster\", pntr = new(\"Rcpp_SpatRaster\", .xData = <environment>)))\n\u001Bg\u001BG2;In addition: \u001BH2;Warning message\u001Bh:\nIn (function (center = c(x = 0, y = 0), axes = c(1, 1), angles = 0,  :\n  No angles specified. All axes will be applied the same angle specified: 0\n\u001Bg",
        "> ",
        "#'   \\item \\code{occurrences}: sampled occurrences from [get_sample_occ()].",
        "> ",
        "#'   \\item \\code{call_args}: the original `...` captured as a named list.",
        "> ",
        "#'   \\item \\code{routed_args}: a list showing which args went to each function.",
        "> ",
        "#'   \\item \\code{save_path}: file path if \\code{out.file = TRUE}, otherwise `NULL`.",
        "> ",
        "#' }",
        "> ",
        "#'",
        "> ",
        "#' @seealso [build_ellps()], [get_suitable_env()], [set_bias_surface()],",
        "> ",
        "#'   [get_sample_occ()]",
        "> ",
        "#'",
        "> ",
        "#' @export",
        "> ",
        "create_virtual_species <- function(...,",
        "+ ",
        "                                   out.file = FALSE,",
        "+ ",
        "                                   out.file.name = NULL,",
        "+ ",
        "                                   verbose = TRUE) {",
        "+ ",
        "  ",
        "+ ",
        "  # capture all args once",
        "+ ",
        "  args <- list(...)",
        "+ ",
        "  ",
        "+ ",
        "  # ensure required functions exist",
        "+ ",
        "  needed_funs <- c(\"build_ellps\", \"get_suitable_env\",",
        "+ ",
        "                   \"set_bias_surface\", \"get_sample_occ\")",
        "+ ",
        "  ",
        "+ ",
        "  missing_funs <- needed_funs[!vapply(needed_funs, exists, logical(1), mode = \"function\")]",
        "+ ",
        "  ",
        "+ ",
        "  if (length(missing_funs)) {",
        "+ ",
        "    stop(\"These functions are not available in the current environment: \",",
        "+ ",
        "         paste(missing_funs, collapse = \", \"))",
        "+ ",
        "  }",
        "+ ",
        "  ",
        "+ ",
        "  # pull formals for routing",
        "+ ",
        "  f_build <- names(formals(build_ellps))",
        "+ ",
        "  f_suit  <- names(formals(get_suitable_env))",
        "+ ",
        "  f_bias  <- names(formals(set_bias_surface))",
        "+ ",
        "  f_occ   <- names(formals(get_sample_occ))",
        "+ ",
        "  ",
        "+ ",
        "  # split args by target function",
        "+ ",
        "  args_build <- args[names(args) %in% f_build]",
        "+ ",
        "  args_suit  <- args[names(args) %in% f_suit]",
        "+ ",
        "  args_bias  <- args[names(args) %in% f_bias]",
        "+ ",
        "  args_occ   <- args[names(args) %in% f_occ]",
        "+ ",
        "  ",
        "+ ",
        "  # pass env_bg through if user supplied it at top level but it was not routed",
        "+ ",
        "  if (\"env_bg\" %in% names(args)) {",
        "+ ",
        "    if (!(\"env_bg\" %in% names(args_suit)) && (\"env_bg\" %in% f_suit)) {",
        "+ ",
        "      args_suit$env_bg <- args$env_bg",
        "+ ",
        "    }",
        "+ ",
        "    if (!(\"env_bg\" %in% names(args_occ)) && (\"env_bg\" %in% f_occ)) {",
        "+ ",
        "      args_occ$env_bg <- args$env_bg",
        "+ ",
        "    }",
        "+ ",
        "  }",
        "+ ",
        "  ",
        "+ ",
        "  # ensure env_bg will be available when needed for suitability",
        "+ ",
        "  if ((\"env_bg\" %in% f_suit) && !(\"env_bg\" %in% names(args_suit))) {",
        "+ ",
        "    stop(\"env_bg is required by get_suitable_env but was not supplied.\")",
        "+ ",
        "  }",
        "+ ",
        "  ",
        "+ ",
        "  # set sensible defaults for get_suitable_env behavior",
        "+ ",
        "  if (\"out.suit\" %in% f_suit && !(\"out.suit\" %in% names(args_suit))) {",
        "+ ",
        "    args_suit$out.suit <- \"both\"",
        "+ ",
        "    if (isTRUE(verbose)) {",
        "+ ",
        "      message(\"get_suitable_env(): 'out.suit' not supplied; using 'both'.\")",
        "+ ",
        "    }",
        "+ ",
        "  }",
        "+ ",
        "  if (\"distances\" %in% f_suit && !(\"distances\" %in% names(args_suit))) {",
        "+ ",
        "    args_suit$distances <- TRUE",
        "+ ",
        "    if (isTRUE(verbose)) {",
        "+ ",
        "      message(\"get_suitable_env(): 'distances' not supplied; computing distances = TRUE.\")",
        "+ ",
        "    }",
        "+ ",
        "  }",
        "+ ",
        "  ",
        "+ ",
        "  # ---------------------------------------------------------------------------",
        "+ ",
        "  # 1) build ellipsoid niche",
        "+ ",
        "  # ---------------------------------------------------------------------------",
        "+ ",
        "  niche_obj <- tryCatch(",
        "+ ",
        "    do.call(build_ellps, args_build),",
        "+ ",
        "    error = function(e) stop(\"build_ellps failed: \", e$message)",
        "+ ",
        "  )",
        "+ ",
        "  ",
        "+ ",
        "  if (verbose) message(\"Built niche object.\")",
        "+ ",
        "  ",
        "+ ",
        "  # ---------------------------------------------------------------------------",
        "+ ",
        "  # 2) suitability in G space",
        "+ ",
        "  # ---------------------------------------------------------------------------",
        "+ ",
        "  suit_env <- tryCatch(",
        "+ ",
        "    do.call(get_suitable_env, c(list(niche = niche_obj), args_suit)),",
        "+ ",
        "    error = function(e) stop(\"get_suitable_env failed: \", e$message)",
        "+ ",
        "  )",
        "+ ",
        "  ",
        "+ ",
        "  if (verbose) message(\"Computed suitable environments.\")",
        "+ ",
        "  ",
        "+ ",
        "  # If get_sample_occ has a 'suitable_env' arg and user didn't set it,",
        "+ ",
        "  # wire through the suitability object from get_suitable_env().",
        "+ ",
        "  if (\"suitable_env\" %in% f_occ && !(\"suitable_env\" %in% names(args_occ))) {",
        "+ ",
        "    args_occ$suitable_env <- suit_env",
        "+ ",
        "  }",
        "+ ",
        "  ",
        "+ ",
        "  # ---------------------------------------------------------------------------",
        "+ ",
        "  # 3) Optional bias construction",
        "+ ",
        "  # ---------------------------------------------------------------------------",
        "+ ",
        "  bias_obj <- NULL",
        "+ ",
        "  ",
        "+ ",
        "  # We treat bias as \"in play\" if user provided bias_surface at all",
        "+ ",
        "  has_any_bias_arg <- \"bias_surface\" %in% names(args)",
        "+ ",
        "  ",
        "+ ",
        "  if (has_any_bias_arg) {",
        "+ ",
        "    ",
        "+ ",
        "    # Decide if we should CALL set_bias_surface() or just forward bias_surface.",
        "+ ",
        "    # We call set_bias_surface() if any set_bias_surface-specific args",
        "+ ",
        "    # beyond 'bias_surface' and 'verbose' are present (e.g., bias_dir,",
        "+ ",
        "    # suitable_env, out.bias).",
        "+ ",
        "    bias_construction_args <- setdiff(names(args_bias),",
        "+ ",
        "                                      c(\"bias_surface\", \"verbose\"))",
        "+ ",
        "    ",
        "+ ",
        "    wants_bias_build <- length(bias_construction_args) > 0",
        "+ ",
        "    ",
        "+ ",
        "    if (wants_bias_build) {",
        "+ ",
        "      # We will build a bias surface with set_bias_surface()",
        "+ ",
        "      ",
        "+ ",
        "      bias_call_args <- args_bias",
        "+ ",
        "      ",
        "+ ",
        "      # If no suitable_env given to set_bias_surface, use the suitability",
        "+ ",
        "      # object from get_suitable_env() as mask/template.",
        "+ ",
        "      if (!(\"suitable_env\" %in% names(bias_call_args))) {",
        "+ ",
        "        bias_call_args$suitable_env <- suit_env",
        "+ ",
        "      }",
        "+ ",
        "      ",
        "+ ",
        "      bias_obj <- tryCatch(",
        "+ ",
        "        do.call(set_bias_surface, bias_call_args),",
        "+ ",
        "        error = function(e) stop(\"set_bias_surface failed: \", e$message)",
        "+ ",
        "      )",
        "+ ",
        "      ",
        "+ ",
        "      if (verbose) message(\"Constructed pooled bias surface via set_bias_surface().\")",
        "+ ",
        "      ",
        "+ ",
        "      # get_sample_occ() expects a single-layer bias raster;",
        "+ ",
        "      # pass the pooled layer if present.",
        "+ ",
        "      if (!is.null(bias_obj$pooled_bias_sp)) {",
        "+ ",
        "        args_occ$bias_surface <- bias_obj$pooled_bias_sp",
        "+ ",
        "      } else {",
        "+ ",
        "        warning(\"set_bias_surface() returned no 'pooled_bias_sp'; \",",
        "+ ",
        "                \"bias will not be applied in get_sample_occ().\",",
        "+ ",
        "                call. = FALSE)",
        "+ ",
        "      }",
        "+ ",
        "      ",
        "+ ",
        "    } else {",
        "+ ",
        "      # No extra set_bias_surface args: assume the user passed a precomputed",
        "+ ",
        "      # 01 bias raster as 'bias_surface' that should go straight into",
        "+ ",
        "      # get_sample_occ().",
        "+ ",
        "      if (\"bias_surface\" %in% names(args)) {",
        "+ ",
        "        args_occ$bias_surface <- args$bias_surface",
        "+ ",
        "        bias_obj <- args$bias_surface  # store in output for transparency",
        "+ ",
        "        if (verbose) {",
        "+ ",
        "          message(\"Using user-supplied 'bias_surface' directly in get_sample_occ().\")",
        "+ ",
        "        }",
        "+ ",
        "      }",
        "+ ",
        "    }",
        "+ ",
        "  }",
        "+ ",
        "  ",
        "+ ",
        "  # ---------------------------------------------------------------------------",
        "+ ",
        "  # 4) sample occurrences",
        "+ ",
        "  # ---------------------------------------------------------------------------",
        "+ ",
        "  occ <- tryCatch(",
        "+ ",
        "    do.call(get_sample_occ, args_occ),",
        "+ ",
        "    error = function(e) stop(\"get_sample_occ failed: \", e$message)",
        "+ ",
        "  )",
        "+ ",
        "  ",
        "+ ",
        "  if (verbose) message(\"Sampled occurrences.\")",
        "+ ",
        "  ",
        "+ ",
        "  # ---------------------------------------------------------------------------",
        "+ ",
        "  # 5) warn on unused args",
        "+ ",
        "  # ---------------------------------------------------------------------------",
        "+ ",
        "  used_names <- union(",
        "+ ",
        "    names(args_build),",
        "+ ",
        "    union(names(args_suit), union(names(args_occ), names(args_bias)))",
        "+ ",
        "  )",
        "+ ",
        "  unused <- setdiff(names(args), used_names)",
        "+ ",
        "  if (length(unused) && verbose) {",
        "+ ",
        "    warning(\"These arguments did not match any target function and were ignored: \",",
        "+ ",
        "            paste(unused, collapse = \", \"))",
        "+ ",
        "  }",
        "+ ",
        "  ",
        "+ ",
        "  # ---------------------------------------------------------------------------",
        "+ ",
        "  # 6) assemble S3 object",
        "+ ",
        "  # ---------------------------------------------------------------------------",
        "+ ",
        "  out <- list(",
        "+ ",
        "    niche        = niche_obj,",
        "+ ",
        "    suitability  = suit_env,",
        "+ ",
        "    bias_surface = bias_obj,",
        "+ ",
        "    occurrences  = occ,",
        "+ ",
        "    call_args    = args,",
        "+ ",
        "    routed_args  = list(",
        "+ ",
        "      build_ellps      = args_build,",
        "+ ",
        "      get_suitable_env = args_suit,",
        "+ ",
        "      set_bias_surface = args_bias,",
        "+ ",
        "      get_sample_occ   = args_occ",
        "+ ",
        "    ),",
        "+ ",
        "    save_path    = NULL",
        "+ ",
        "  )",
        "+ ",
        "  ",
        "+ ",
        "  class(out) <- c(\"NicheR_species\", class(out))",
        "+ ",
        "  ",
        "+ ",
        "  # ---- Saving logic ----",
        "+ ",
        "  if (isTRUE(out.file)) {",
        "+ ",
        "    ",
        "+ ",
        "    dir_path <- getwd()",
        "+ ",
        "    ",
        "+ ",
        "    if (is.null(out.file.name) || out.file.name == \"\") {",
        "+ ",
        "      timestamp <- format(Sys.time(), \"%Y-%m-%d_%H-%M-%S\")",
        "+ ",
        "      out.file.name <- paste0(\"NicheR_vs_\", timestamp)",
        "+ ",
        "    }",
        "+ ",
        "    ",
        "+ ",
        "    save_path <- file.path(dir_path, paste0(out.file.name, \".rds\"))",
        "+ ",
        "    saveRDS(out, save_path)",
        "+ ",
        "    ",
        "+ ",
        "    if (verbose) message(\"Virtual species saved to: \", normalizePath(save_path))",
        "+ ",
        "    ",
        "+ ",
        "    out$save_path <- save_path",
        "+ ",
        "    ",
        "+ ",
        "  } else if (verbose) {",
        "+ ",
        "    message(\"`out.file = FALSE`: object not saved to disk.\")",
        "+ ",
        "  }",
        "+ ",
        "  ",
        "+ ",
        "  return(out)",
        "+ ",
        "}",
        "> ",
        "#' Print a NicheR virtual species",
        "> ",
        "#'",
        "> ",
        "#' @param x A \\code{NicheR_species} object.",
        "> ",
        "#' @param ... Not used.",
        "> ",
        "#' @return \\code{x}, invisibly.",
        "> ",
        "#' @method print NicheR_species",
        "> ",
        "#' @export",
        "> ",
        "print.NicheR_species <- function(x, ...) {",
        "+ ",
        "  cat(\"NicheR virtual species components:\\n\")",
        "+ ",
        "  cat(\"  niche:        \", paste(class(x$niche), collapse = \"/\"), \"\\n\", sep = \"\")",
        "+ ",
        "  cat(\"  suitability:  \", paste(class(x$suitability), collapse = \"/\"), \"\\n\", sep = \"\")",
        "+ ",
        "  cat(\"  bias_surface: \",",
        "+ ",
        "      if (is.null(x$bias_surface)) \"NULL\" else paste(class(x$bias_surface), collapse = \"/\"),",
        "+ ",
        "      \"\\n\", sep = \"\")",
        "+ ",
        "  cat(\"  occurrences:  \", paste(class(x$occurrences), collapse = \"/\"), \"\\n\", sep = \"\")",
        "+ ",
        "  invisible(x)",
        "+ ",
        "}",
        "> ",
        "#' Combine one or more bias surfaces into a pooled bias raster",
        "> ",
        "#'",
        "> ",
        "#' This helper function combines one or more sampling bias layers into a single",
        "> ",
        "#' pooled bias surface. Each bias layer is:",
        "> ",
        "#' \\itemize{",
        "> ",
        "#'   \\item aligned to a common template grid,",
        "> ",
        "#'   \\item scaled to \\eqn{[0, 1]},",
        "> ",
        "#'   \\item optionally reversed via \\eqn{1 - x},",
        "> ",
        "#'   \\item multiplied with other bias layers to form a pooled bias surface.",
        "> ",
        "#' }",
        "> ",
        "#'",
        "> ",
        "#' The resulting pooled bias raster can then be used elsewhere in NicheR to",
        "> ",
        "#' modulate sampling or suitability. Optionally, the function can also return",
        "> ",
        "#' the standardized bias layers as a raster stack.",
        "> ",
        "#'",
        "> ",
        "#' @param bias_surface One or more bias layers which must be:",
        "> ",
        "#'   \\itemize{",
        "> ",
        "#'     \\item a \\code{terra::SpatRaster} (single or multi-layer), or",
        "> ",
        "#'     \\item a \\code{list} of \\code{terra::SpatRaster} objects.",
        "> ",
        "#'   }",
        "> ",
        "#'   Any multi-layer \\code{SpatRaster} is internally split into single-layer",
        "> ",
        "#'   rasters before standardization.",
        "> ",
        "#' @param bias_dir Numeric values of \\code{1} or \\code{-1} controlling",
        "> ",
        "#'   directionality. A length 1 value is recycled across all layers. A value",
        "> ",
        "#'   of \\code{-1} applies \\code{1 - layer} after scaling to \\eqn{[0, 1]}.",
        "> ",
        "#' @param suitable_env Optional \\code{terra::SpatRaster} or related object used",
        "> ",
        "#'   as a mask and template. Typically this is a binary or continuous",
        "> ",
        "#'   suitability raster or a \\code{suitable_env} object. Masking is applied",
        "> ",
        "#'   after standardization so that bias is only defined where the species is",
        "> ",
        "#'   suitable. Required when \\code{out.bias} is \\code{\"biased\"} or \\code{\"both\"}.",
        "> ",
        "#' @param out.bias Character, one of \\code{\"biased\"}, \\code{\"standardized\"},",
        "> ",
        "#'   or \\code{\"both\"}:",
        "> ",
        "#'   \\itemize{",
        "> ",
        "#'     \\item \\code{\"standardized\"}: returns only the standardized,",
        "> ",
        "#'       direction-adjusted bias stack.",
        "> ",
        "#'     \\item \\code{\"biased\"}: returns only the pooled bias surface, masked by",
        "> ",
        "#'       \\code{suitable_env}. Requires \\code{suitable_env}.",
        "> ",
        "#'     \\item \\code{\"both\"}: returns both the pooled bias surface and the",
        "> ",
        "#'       standardized stack. Requires \\code{suitable_env}.",
        "> ",
        "#'   }",
        "> ",
        "#' @param verbose Logical. If \\code{TRUE}, prints basic progress messages.",
        "> ",
        "#'",
        "> ",
        "#' @return A list of class \\code{\"nicheR_bias_surface\"} containing some or all",
        "> ",
        "#'   of:",
        "> ",
        "#'   \\item{pooled_bias_sp}{Pooled bias raster (scaled 01; \\code{SpatRaster}),",
        "> ",
        "#'         masked by \\code{suitable_env} when supplied. Present only when",
        "> ",
        "#'         \\code{out.bias} is \\code{\"biased\"} or \\code{\"both\"}.}",
        "> ",
        "#'   \\item{directional_bias_stack}{Stack of standardized, direction-corrected",
        "> ",
        "#'         bias layers (\\code{SpatRaster}). Present only when",
        "> ",
        "#'         \\code{out.bias} is \\code{\"standardized\"} or \\code{\"both\"}.}",
        "> ",
        "#'   \\item{combination_formula}{String describing how layers were combined",
        "> ",
        "#'         (e.g., \\code{\"bias_1 * (1-bias_2)\"}).}",
        "> ",
        "#'",
        "> ",
        "#' @importFrom terra rast resample values app nlyr as.list ext res mask",
        "> ",
        "#' @export",
        "> ",
        "set_bias_surface <- function(bias_surface,",
        "+ ",
        "                             bias_dir = 1,",
        "+ ",
        "                             suitable_env = NULL,",
        "+ ",
        "                             out.bias = c(\"biased\", \"standardized\", \"both\"),",
        "+ ",
        "                             verbose = TRUE) {",
        "+ ",
        "+ ",
        "  gc()",
        "+ ",
        "  out.bias <- match.arg(out.bias)",
        "+ ",
        "+ ",
        "  if (isTRUE(verbose)) {",
        "+ ",
        "    message(\"Starting set_bias_surface()...\")",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  # ---- 0. Basic checks ------------------------------------------------------",
        "+ ",
        "+ ",
        "  if (missing(bias_surface) || is.null(bias_surface)) {",
        "+ ",
        "    stop(\"'bias_surface' is required and must be a SpatRaster or a list of SpatRasters.\")",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  # Enforce raster inputs -----------------------------------------------------",
        "+ ",
        "  if (inherits(bias_surface, \"SpatRaster\")) {",
        "+ ",
        "    # split multi-layer rasters into single-layer list",
        "+ ",
        "    if (isTRUE(verbose)) {",
        "+ ",
        "      message(\"bias_surface provided as SpatRaster. Splitting into single layers...\")",
        "+ ",
        "    }",
        "+ ",
        "    bias_list <- terra::as.list(bias_surface)",
        "+ ",
        "  } else if (is.list(bias_surface) &&",
        "+ ",
        "             length(bias_surface) > 0 &&",
        "+ ",
        "             all(vapply(bias_surface, inherits, logical(1), \"SpatRaster\"))) {",
        "+ ",
        "    if (isTRUE(verbose)) {",
        "+ ",
        "      message(\"bias_surface provided as list of SpatRasters. Flattening layers...\")",
        "+ ",
        "    }",
        "+ ",
        "    # flatten list of SpatRasters into single-layer rasters",
        "+ ",
        "    bias_list <- unlist(lapply(bias_surface, terra::as.list), recursive = FALSE)",
        "+ ",
        "  } else {",
        "+ ",
        "    stop(",
        "+ ",
        "      \"'bias_surface' must be either:\\n\",",
        "+ ",
        "      \"  * a terra::SpatRaster (single or multi-layer), or\\n\",",
        "+ ",
        "      \"  * a list of terra::SpatRaster objects.\"",
        "+ ",
        "    )",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  if (length(bias_list) == 0) {",
        "+ ",
        "    stop(\"No bias layers provided.\")",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  # Suitable env / mask checks -----------------------------------------------",
        "+ ",
        "+ ",
        "  if (out.bias %in% c(\"biased\", \"both\") && is.null(suitable_env)) {",
        "+ ",
        "    stop(",
        "+ ",
        "      \"out.bias = '\", out.bias, \"' requires 'suitable_env' (SpatRaster or suitable_env object) \",",
        "+ ",
        "      \"to be provided so it can be used as a mask.\"",
        "+ ",
        "    )",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  mask_ras <- NULL",
        "+ ",
        "  if (!is.null(suitable_env)) {",
        "+ ",
        "+ ",
        "    # Helper: extract first SpatRaster found inside a variety of objects",
        "+ ",
        "    get_first_raster <- function(obj) {",
        "+ ",
        "      # Direct SpatRaster",
        "+ ",
        "      if (inherits(obj, \"SpatRaster\")) {",
        "+ ",
        "        return(obj[[1]])",
        "+ ",
        "      }",
        "+ ",
        "+ ",
        "      # \"suitable_env\" object from get_suitable_env(out.suit = \"both\")",
        "+ ",
        "      if (inherits(obj, \"suitable_env\") && \"suitable_env_sp\" %in% names(obj)) {",
        "+ ",
        "        return(get_first_raster(obj$suitable_env_sp)) # tiny recursive call",
        "+ ",
        "      }",
        "+ ",
        "+ ",
        "      # List: look for first SpatRaster in elements",
        "+ ",
        "      if (is.list(obj)) {",
        "+ ",
        "        # If named, try \"suitable\" first",
        "+ ",
        "        if (!is.null(names(obj)) && \"suitable\" %in% names(obj)) {",
        "+ ",
        "          if (inherits(obj[[\"suitable\"]], \"SpatRaster\")) {",
        "+ ",
        "            return(obj[[\"suitable\"]][[1]])",
        "+ ",
        "          }",
        "+ ",
        "        }",
        "+ ",
        "        # Otherwise, scan through elements",
        "+ ",
        "        for (el in obj) {",
        "+ ",
        "          if (inherits(el, \"SpatRaster\")) {",
        "+ ",
        "            return(el[[1]])",
        "+ ",
        "          }",
        "+ ",
        "        }",
        "+ ",
        "      }",
        "+ ",
        "+ ",
        "      # Nothing usable found",
        "+ ",
        "      NULL",
        "+ ",
        "    }",
        "+ ",
        "+ ",
        "    mask_ras <- get_first_raster(suitable_env)",
        "+ ",
        "+ ",
        "    if (is.null(mask_ras)) {",
        "+ ",
        "      stop(",
        "+ ",
        "        \"'suitable_env' must contain at least one terra::SpatRaster to be used as a mask.\\n\",",
        "+ ",
        "        \"Examples:\\n\",",
        "+ ",
        "        \"  - a SpatRaster directly (e.g. suitable_ras),\\n\",",
        "+ ",
        "        \"  - a 'suitable_env' object from get_suitable_env(out.suit = 'both'),\\n\",",
        "+ ",
        "        \"  - a list with a 'suitable' SpatRaster element \",",
        "+ ",
        "        \"    (e.g. suitable_env$suitable_env_sp$suitable).\"",
        "+ ",
        "      )",
        "+ ",
        "    }",
        "+ ",
        "+ ",
        "    if (isTRUE(verbose)) {",
        "+ ",
        "      message(\"Using 'suitable_env' raster as template and mask.\")",
        "+ ",
        "    }",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  # Template raster: use mask if available, else the first bias layer --------",
        "+ ",
        "+ ",
        "  if (!is.null(mask_ras)) {",
        "+ ",
        "    template_raster <- mask_ras",
        "+ ",
        "  } else {",
        "+ ",
        "    first_bias <- bias_list[[1]]",
        "+ ",
        "+ ",
        "    if (!inherits(first_bias, \"SpatRaster\")) {",
        "+ ",
        "      stop(\"First bias layer is not a SpatRaster. All bias layers must be SpatRasters.\")",
        "+ ",
        "    }",
        "+ ",
        "+ ",
        "    template_raster <- first_bias",
        "+ ",
        "+ ",
        "    if (isTRUE(verbose)) {",
        "+ ",
        "      message(\"Using first bias raster as template.\")",
        "+ ",
        "    }",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  # Validate bias_dir ---------------------------------------------------------",
        "+ ",
        "+ ",
        "  if (length(bias_dir) == 1) {",
        "+ ",
        "    bias_dir <- rep(bias_dir, length(bias_list))",
        "+ ",
        "  } else if (length(bias_dir) != length(bias_list)) {",
        "+ ",
        "    stop(\"The length of 'bias_dir' (\", length(bias_dir),",
        "+ ",
        "         \") must match the number of bias layers (\", length(bias_list),",
        "+ ",
        "         \") or be 1.\")",
        "+ ",
        "  }",
        "+ ",
        "  if (!all(bias_dir %in% c(1, -1))) {",
        "+ ",
        "    stop(\"'bias_dir' must only contain values of 1 or -1.\")",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  # ---- 1. Process, align, and standardize each bias layer -------------------",
        "+ ",
        "+ ",
        "  if (isTRUE(verbose)) {",
        "+ ",
        "    message(\"Processing and standardizing \", length(bias_list),",
        "+ ",
        "            \" bias layer(s) on the template grid...\")",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  directional_bias_list <- vector(\"list\", length(bias_list))",
        "+ ",
        "  dir_message_parts     <- character(length(bias_list))",
        "+ ",
        "+ ",
        "  for (i in seq_along(bias_list)) {",
        "+ ",
        "+ ",
        "    bias_raster_raw <- bias_list[[i]]",
        "+ ",
        "    this_dir        <- bias_dir[i]",
        "+ ",
        "+ ",
        "    # Try to derive a readable name",
        "+ ",
        "    layer_name <- names(bias_raster_raw)",
        "+ ",
        "    if (is.null(layer_name) || length(layer_name) == 0 || layer_name[1] == \"\") {",
        "+ ",
        "      layer_name <- paste0(\"bias_\", i)",
        "+ ",
        "    } else {",
        "+ ",
        "      layer_name <- layer_name[1]",
        "+ ",
        "    }",
        "+ ",
        "+ ",
        "    # Align resolution + extent to template",
        "+ ",
        "    if (!identical(terra::res(bias_raster_raw), terra::res(template_raster)) ||",
        "+ ",
        "        !identical(terra::ext(bias_raster_raw), terra::ext(template_raster))) {",
        "+ ",
        "+ ",
        "      if (isTRUE(verbose)) {",
        "+ ",
        "        message(\"  - Aligning bias layer \", i, \" (\", layer_name, \") to template grid (resample).\")",
        "+ ",
        "      }",
        "+ ",
        "      bias_raster_aligned <- terra::resample(bias_raster_raw, template_raster, method = \"near\")",
        "+ ",
        "    } else {",
        "+ ",
        "      bias_raster_aligned <- bias_raster_raw",
        "+ ",
        "    }",
        "+ ",
        "+ ",
        "    # Normalize to [0, 1] (preserving NA)",
        "+ ",
        "    vals      <- terra::values(bias_raster_aligned)",
        "+ ",
        "    min_val   <- min(vals, na.rm = TRUE)",
        "+ ",
        "    max_val   <- max(vals, na.rm = TRUE)",
        "+ ",
        "    range_val <- max_val - min_val",
        "+ ",
        "+ ",
        "    if (range_val == 0) {",
        "+ ",
        "      warning(\"Bias layer \", i,",
        "+ ",
        "              \" ('\", layer_name, \"') contains a single unique value. \",",
        "+ ",
        "              \"Setting all non-NA values to 1.\",",
        "+ ",
        "              call. = FALSE)",
        "+ ",
        "      scaled_layer <- bias_raster_aligned",
        "+ ",
        "      scaled_layer[!is.na(scaled_layer)] <- 1",
        "+ ",
        "    } else {",
        "+ ",
        "      scaled_layer <- (bias_raster_aligned - min_val) / range_val",
        "+ ",
        "    }",
        "+ ",
        "+ ",
        "    # Apply directionality",
        "+ ",
        "    if (this_dir == -1) {",
        "+ ",
        "      directional_layer    <- 1 - scaled_layer",
        "+ ",
        "      dir_message_parts[i] <- paste0(\"(1-\", layer_name, \")\")",
        "+ ",
        "    } else {",
        "+ ",
        "      directional_layer    <- scaled_layer",
        "+ ",
        "      dir_message_parts[i] <- layer_name",
        "+ ",
        "    }",
        "+ ",
        "+ ",
        "    names(directional_layer)   <- layer_name",
        "+ ",
        "    directional_bias_list[[i]] <- directional_layer",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  if (isTRUE(verbose)) {",
        "+ ",
        "    message(\"Finished processing bias layers.\")",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  # Stack directional layers ---------------------------------------------------",
        "+ ",
        "+ ",
        "  directional_bias_stack <- if (length(directional_bias_list) == 1) {",
        "+ ",
        "    directional_bias_list[[1]]",
        "+ ",
        "  } else {",
        "+ ",
        "    do.call(c, directional_bias_list)",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  # ---- 2. Pool bias layers into a single surface ----------------------------",
        "+ ",
        "+ ",
        "  pooled_bias_sp <- NULL",
        "+ ",
        "+ ",
        "  if (out.bias %in% c(\"biased\", \"both\")) {",
        "+ ",
        "+ ",
        "    if (isTRUE(verbose)) {",
        "+ ",
        "      message(\"Pooling \", terra::nlyr(directional_bias_stack),",
        "+ ",
        "              \" bias layer(s) into a single surface...\")",
        "+ ",
        "    }",
        "+ ",
        "+ ",
        "    if (terra::nlyr(directional_bias_stack) > 1) {",
        "+ ",
        "      pooled_bias_sp <- terra::app(",
        "+ ",
        "        directional_bias_stack,",
        "+ ",
        "        fun = function(x) {",
        "+ ",
        "          if (all(is.na(x))) {",
        "+ ",
        "            NA_real_           # keep fully-missing cells as NA",
        "+ ",
        "          } else {",
        "+ ",
        "            prod(x, na.rm = TRUE)",
        "+ ",
        "          }",
        "+ ",
        "        }",
        "+ ",
        "      )",
        "+ ",
        "    } else {",
        "+ ",
        "      pooled_bias_sp <- directional_bias_stack",
        "+ ",
        "    }",
        "+ ",
        "+ ",
        "    names(pooled_bias_sp) <- \"pooled_bias\"",
        "+ ",
        "+ ",
        "    # Mask to suitable area if provided",
        "+ ",
        "    if (!is.null(mask_ras)) {",
        "+ ",
        "      pooled_bias_sp <- terra::mask(pooled_bias_sp, mask_ras)",
        "+ ",
        "    }",
        "+ ",
        "+ ",
        "    if (isTRUE(verbose)) {",
        "+ ",
        "      message(\"Finished pooling bias layers.\")",
        "+ ",
        "    }",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  # Also mask the standardized stack if a mask was provided -------------------",
        "+ ",
        "+ ",
        "  if (!is.null(mask_ras)) {",
        "+ ",
        "    directional_bias_stack <- terra::mask(directional_bias_stack, mask_ras)",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  combination_formula <- paste(dir_message_parts, collapse = \" * \")",
        "+ ",
        "+ ",
        "  # ---- 3. Build result object -----------------------------------------------",
        "+ ",
        "+ ",
        "  res <- list(",
        "+ ",
        "    pooled_bias_sp         = NULL,",
        "+ ",
        "    directional_bias_stack = NULL,",
        "+ ",
        "    combination_formula    = combination_formula",
        "+ ",
        "  )",
        "+ ",
        "+ ",
        "  if (out.bias %in% c(\"biased\", \"both\")) {",
        "+ ",
        "    res$pooled_bias_sp <- pooled_bias_sp",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  if (out.bias %in% c(\"standardized\", \"both\")) {",
        "+ ",
        "    res$directional_bias_stack <- directional_bias_stack",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  class(res) <- \"nicheR_bias_surface\"",
        "+ ",
        "+ ",
        "  gc()",
        "+ ",
        "+ ",
        "  if (isTRUE(verbose)) {",
        "+ ",
        "    message(\"set_bias_surface() completed successfully.\")",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  return(res)",
        "+ ",
        "}",
        "> ",
        "> ",
        "#' @export",
        "> ",
        "print.nicheR_bias_surface <- function(x, ...) {",
        "+ ",
        "+ ",
        "  cat(\"NicheR bias surface object\\n\")",
        "+ ",
        "+ ",
        "  # Combination formula (how layers were combined)",
        "+ ",
        "  if (!is.null(x$combination_formula)) {",
        "+ ",
        "    cat(\"  Combination:\\n\")",
        "+ ",
        "    cat(\"    \", x$combination_formula, \"\\n\\n\")",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  # pooled_bias_sp summary",
        "+ ",
        "  if (!is.null(x$pooled_bias_sp) && inherits(x$pooled_bias_sp, \"SpatRaster\")) {",
        "+ ",
        "    r <- x$pooled_bias_sp",
        "+ ",
        "    cat(\"  pooled_bias_sp (terra::SpatRaster)\\n\")",
        "+ ",
        "    cat(\"    layers :\", terra::nlyr(r), \"\\n\")",
        "+ ",
        "    cat(\"    names  :\", paste(names(r), collapse = \", \"), \"\\n\\n\")",
        "+ ",
        "  } else {",
        "+ ",
        "    cat(\"  pooled_bias_sp : NULL\\n\\n\")",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  # directional_bias_stack summary (if present)",
        "+ ",
        "  if (!is.null(x$directional_bias_stack) &&",
        "+ ",
        "      inherits(x$directional_bias_stack, \"SpatRaster\")) {",
        "+ ",
        "+ ",
        "    r <- x$directional_bias_stack",
        "+ ",
        "    cat(\"  directional_bias_stack (terra::SpatRaster)\\n\")",
        "+ ",
        "    cat(\"    layers :\", terra::nlyr(r), \"\\n\")",
        "+ ",
        "    cat(\"    names  :\", paste(names(r), collapse = \", \"), \"\\n\")",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  invisible(x)",
        "+ ",
        "}",
        "> ",
        "#'   \\item \\code{occurrences}: sampled occurrences from [get_sample_occ()].",
        "> ",
        "#'   \\item \\code{call_args}: the original `...` captured as a named list.",
        "> ",
        "#'   \\item \\code{routed_args}: a list showing which args went to each function.",
        "> ",
        "#'   \\item \\code{save_path}: file path if \\code{out.file = TRUE}, otherwise `NULL`.",
        "> ",
        "#' }",
        "> ",
        "#'",
        "> ",
        "#' @seealso [build_ellps()], [get_suitable_env()], [set_bias_surface()],",
        "> ",
        "#'   [get_sample_occ()]",
        "> ",
        "#'",
        "> ",
        "#' @export",
        "> ",
        "create_virtual_species <- function(...,",
        "+ ",
        "                                   out.file = FALSE,",
        "+ ",
        "                                   out.file.name = NULL,",
        "+ ",
        "                                   verbose = TRUE) {",
        "+ ",
        "  ",
        "+ ",
        "  # capture all args once",
        "+ ",
        "  args <- list(...)",
        "+ ",
        "  ",
        "+ ",
        "  # ensure required functions exist",
        "+ ",
        "  needed_funs <- c(\"build_ellps\", \"get_suitable_env\",",
        "+ ",
        "                   \"set_bias_surface\", \"get_sample_occ\")",
        "+ ",
        "  ",
        "+ ",
        "  missing_funs <- needed_funs[!vapply(needed_funs, exists, logical(1), mode = \"function\")]",
        "+ ",
        "  ",
        "+ ",
        "  if (length(missing_funs)) {",
        "+ ",
        "    stop(\"These functions are not available in the current environment: \",",
        "+ ",
        "         paste(missing_funs, collapse = \", \"))",
        "+ ",
        "  }",
        "+ ",
        "  ",
        "+ ",
        "  # pull formals for routing",
        "+ ",
        "  f_build <- names(formals(build_ellps))",
        "+ ",
        "  f_suit  <- names(formals(get_suitable_env))",
        "+ ",
        "  f_bias  <- names(formals(set_bias_surface))",
        "+ ",
        "  f_occ   <- names(formals(get_sample_occ))",
        "+ ",
        "  ",
        "+ ",
        "  # split args by target function",
        "+ ",
        "  args_build <- args[names(args) %in% f_build]",
        "+ ",
        "  args_suit  <- args[names(args) %in% f_suit]",
        "+ ",
        "  args_bias  <- args[names(args) %in% f_bias]",
        "+ ",
        "  args_occ   <- args[names(args) %in% f_occ]",
        "+ ",
        "  ",
        "+ ",
        "  # pass env_bg through if user supplied it at top level but it was not routed",
        "+ ",
        "  if (\"env_bg\" %in% names(args)) {",
        "+ ",
        "    if (!(\"env_bg\" %in% names(args_suit)) && (\"env_bg\" %in% f_suit)) {",
        "+ ",
        "      args_suit$env_bg <- args$env_bg",
        "+ ",
        "    }",
        "+ ",
        "    if (!(\"env_bg\" %in% names(args_occ)) && (\"env_bg\" %in% f_occ)) {",
        "+ ",
        "      args_occ$env_bg <- args$env_bg",
        "+ ",
        "    }",
        "+ ",
        "  }",
        "+ ",
        "  ",
        "+ ",
        "  # ensure env_bg will be available when needed for suitability",
        "+ ",
        "  if ((\"env_bg\" %in% f_suit) && !(\"env_bg\" %in% names(args_suit))) {",
        "+ ",
        "    stop(\"env_bg is required by get_suitable_env but was not supplied.\")",
        "+ ",
        "  }",
        "+ ",
        "  ",
        "+ ",
        "  # set sensible defaults for get_suitable_env behavior",
        "+ ",
        "  if (\"out.suit\" %in% f_suit && !(\"out.suit\" %in% names(args_suit))) {",
        "+ ",
        "    args_suit$out.suit <- \"both\"",
        "+ ",
        "    if (isTRUE(verbose)) {",
        "+ ",
        "      message(\"get_suitable_env(): 'out.suit' not supplied; using 'both'.\")",
        "+ ",
        "    }",
        "+ ",
        "  }",
        "+ ",
        "  if (\"distances\" %in% f_suit && !(\"distances\" %in% names(args_suit))) {",
        "+ ",
        "    args_suit$distances <- TRUE",
        "+ ",
        "    if (isTRUE(verbose)) {",
        "+ ",
        "      message(\"get_suitable_env(): 'distances' not supplied; computing distances = TRUE.\")",
        "+ ",
        "    }",
        "+ ",
        "  }",
        "+ ",
        "  ",
        "+ ",
        "  # ---------------------------------------------------------------------------",
        "+ ",
        "  # 1) build ellipsoid niche",
        "+ ",
        "  # ---------------------------------------------------------------------------",
        "+ ",
        "  niche_obj <- tryCatch(",
        "+ ",
        "    do.call(build_ellps, args_build),",
        "+ ",
        "    error = function(e) stop(\"build_ellps failed: \", e$message)",
        "+ ",
        "  )",
        "+ ",
        "  ",
        "+ ",
        "  if (verbose) message(\"Built niche object.\")",
        "+ ",
        "  ",
        "+ ",
        "  # ---------------------------------------------------------------------------",
        "+ ",
        "  # 2) suitability in G space",
        "+ ",
        "  # ---------------------------------------------------------------------------",
        "+ ",
        "  suit_env <- tryCatch(",
        "+ ",
        "    do.call(get_suitable_env, c(list(niche = niche_obj), args_suit)),",
        "+ ",
        "    error = function(e) stop(\"get_suitable_env failed: \", e$message)",
        "+ ",
        "  )",
        "+ ",
        "  ",
        "+ ",
        "  if (verbose) message(\"Computed suitable environments.\")",
        "+ ",
        "  ",
        "+ ",
        "  # If get_sample_occ has a 'suitable_env' arg and user didn't set it,",
        "+ ",
        "  # wire through the suitability object from get_suitable_env().",
        "+ ",
        "  if (\"suitable_env\" %in% f_occ && !(\"suitable_env\" %in% names(args_occ))) {",
        "+ ",
        "    args_occ$suitable_env <- suit_env",
        "+ ",
        "  }",
        "+ ",
        "  ",
        "+ ",
        "  # ---------------------------------------------------------------------------",
        "+ ",
        "  # 3) Optional bias construction",
        "+ ",
        "  # ---------------------------------------------------------------------------",
        "+ ",
        "  bias_obj <- NULL",
        "+ ",
        "  ",
        "+ ",
        "  # We treat bias as \"in play\" if user provided bias_surface at all",
        "+ ",
        "  has_any_bias_arg <- \"bias_surface\" %in% names(args)",
        "+ ",
        "  ",
        "+ ",
        "  if (has_any_bias_arg) {",
        "+ ",
        "    ",
        "+ ",
        "    # Decide if we should CALL set_bias_surface() or just forward bias_surface.",
        "+ ",
        "    # We call set_bias_surface() if any set_bias_surface-specific args",
        "+ ",
        "    # beyond 'bias_surface' and 'verbose' are present (e.g., bias_dir,",
        "+ ",
        "    # suitable_env, out.bias).",
        "+ ",
        "    bias_construction_args <- setdiff(names(args_bias),",
        "+ ",
        "                                      c(\"bias_surface\", \"verbose\"))",
        "+ ",
        "    ",
        "+ ",
        "    wants_bias_build <- length(bias_construction_args) > 0",
        "+ ",
        "    ",
        "+ ",
        "    if (wants_bias_build) {",
        "+ ",
        "      # We will build a bias surface with set_bias_surface()",
        "+ ",
        "      ",
        "+ ",
        "      bias_call_args <- args_bias",
        "+ ",
        "      ",
        "+ ",
        "      # If no suitable_env given to set_bias_surface, use the suitability",
        "+ ",
        "      # object from get_suitable_env() as mask/template.",
        "+ ",
        "      if (!(\"suitable_env\" %in% names(bias_call_args))) {",
        "+ ",
        "        bias_call_args$suitable_env <- suit_env",
        "+ ",
        "      }",
        "+ ",
        "      ",
        "+ ",
        "      bias_obj <- tryCatch(",
        "+ ",
        "        do.call(set_bias_surface, bias_call_args),",
        "+ ",
        "        error = function(e) stop(\"set_bias_surface failed: \", e$message)",
        "+ ",
        "      )",
        "+ ",
        "      ",
        "+ ",
        "      if (verbose) message(\"Constructed pooled bias surface via set_bias_surface().\")",
        "+ ",
        "      ",
        "+ ",
        "      # get_sample_occ() expects a single-layer bias raster;",
        "+ ",
        "      # pass the pooled layer if present.",
        "+ ",
        "      if (!is.null(bias_obj$pooled_bias_sp)) {",
        "+ ",
        "        args_occ$bias_surface <- bias_obj$pooled_bias_sp",
        "+ ",
        "      } else {",
        "+ ",
        "        warning(\"set_bias_surface() returned no 'pooled_bias_sp'; \",",
        "+ ",
        "                \"bias will not be applied in get_sample_occ().\",",
        "+ ",
        "                call. = FALSE)",
        "+ ",
        "      }",
        "+ ",
        "      ",
        "+ ",
        "    } else {",
        "+ ",
        "      # No extra set_bias_surface args: assume the user passed a precomputed",
        "+ ",
        "      # 01 bias raster as 'bias_surface' that should go straight into",
        "+ ",
        "      # get_sample_occ().",
        "+ ",
        "      if (\"bias_surface\" %in% names(args)) {",
        "+ ",
        "        args_occ$bias_surface <- args$bias_surface",
        "+ ",
        "        bias_obj <- args$bias_surface  # store in output for transparency",
        "+ ",
        "        if (verbose) {",
        "+ ",
        "          message(\"Using user-supplied 'bias_surface' directly in get_sample_occ().\")",
        "+ ",
        "        }",
        "+ ",
        "      }",
        "+ ",
        "    }",
        "+ ",
        "  }",
        "+ ",
        "  ",
        "+ ",
        "  # ---------------------------------------------------------------------------",
        "+ ",
        "  # 4) sample occurrences",
        "+ ",
        "  # ---------------------------------------------------------------------------",
        "+ ",
        "  occ <- tryCatch(",
        "+ ",
        "    do.call(get_sample_occ, args_occ),",
        "+ ",
        "    error = function(e) stop(\"get_sample_occ failed: \", e$message)",
        "+ ",
        "  )",
        "+ ",
        "  ",
        "+ ",
        "  if (verbose) message(\"Sampled occurrences.\")",
        "+ ",
        "  ",
        "+ ",
        "  # ---------------------------------------------------------------------------",
        "+ ",
        "  # 5) warn on unused args",
        "+ ",
        "  # ---------------------------------------------------------------------------",
        "+ ",
        "  used_names <- union(",
        "+ ",
        "    names(args_build),",
        "+ ",
        "    union(names(args_suit), union(names(args_occ), names(args_bias)))",
        "+ ",
        "  )",
        "+ ",
        "  unused <- setdiff(names(args), used_names)",
        "+ ",
        "  if (length(unused) && verbose) {",
        "+ ",
        "    warning(\"These arguments did not match any target function and were ignored: \",",
        "+ ",
        "            paste(unused, collapse = \", \"))",
        "+ ",
        "  }",
        "+ ",
        "  ",
        "+ ",
        "  # ---------------------------------------------------------------------------",
        "+ ",
        "  # 6) assemble S3 object",
        "+ ",
        "  # ---------------------------------------------------------------------------",
        "+ ",
        "  out <- list(",
        "+ ",
        "    niche        = niche_obj,",
        "+ ",
        "    suitability  = suit_env,",
        "+ ",
        "    bias_surface = bias_obj,",
        "+ ",
        "    occurrences  = occ,",
        "+ ",
        "    call_args    = args,",
        "+ ",
        "    routed_args  = list(",
        "+ ",
        "      build_ellps      = args_build,",
        "+ ",
        "      get_suitable_env = args_suit,",
        "+ ",
        "      set_bias_surface = args_bias,",
        "+ ",
        "      get_sample_occ   = args_occ",
        "+ ",
        "    ),",
        "+ ",
        "    save_path    = NULL",
        "+ ",
        "  )",
        "+ ",
        "  ",
        "+ ",
        "  class(out) <- c(\"NicheR_species\", class(out))",
        "+ ",
        "  ",
        "+ ",
        "  # ---- Saving logic ----",
        "+ ",
        "  if (isTRUE(out.file)) {",
        "+ ",
        "    ",
        "+ ",
        "    dir_path <- getwd()",
        "+ ",
        "    ",
        "+ ",
        "    if (is.null(out.file.name) || out.file.name == \"\") {",
        "+ ",
        "      timestamp <- format(Sys.time(), \"%Y-%m-%d_%H-%M-%S\")",
        "+ ",
        "      out.file.name <- paste0(\"NicheR_vs_\", timestamp)",
        "+ ",
        "    }",
        "+ ",
        "    ",
        "+ ",
        "    save_path <- file.path(dir_path, paste0(out.file.name, \".rds\"))",
        "+ ",
        "    saveRDS(out, save_path)",
        "+ ",
        "    ",
        "+ ",
        "    if (verbose) message(\"Virtual species saved to: \", normalizePath(save_path))",
        "+ ",
        "    ",
        "+ ",
        "    out$save_path <- save_path",
        "+ ",
        "    ",
        "+ ",
        "  } else if (verbose) {",
        "+ ",
        "    message(\"`out.file = FALSE`: object not saved to disk.\")",
        "+ ",
        "  }",
        "+ ",
        "  ",
        "+ ",
        "  return(out)",
        "+ ",
        "}",
        "> ",
        "#' Print a NicheR virtual species",
        "> ",
        "#'",
        "> ",
        "#' @param x A \\code{NicheR_species} object.",
        "> ",
        "#' @param ... Not used.",
        "> ",
        "#' @return \\code{x}, invisibly.",
        "> ",
        "#' @method print NicheR_species",
        "> ",
        "#' @export",
        "> ",
        "print.NicheR_species <- function(x, ...) {",
        "+ ",
        "  cat(\"NicheR virtual species components:\\n\")",
        "+ ",
        "  cat(\"  niche:        \", paste(class(x$niche), collapse = \"/\"), \"\\n\", sep = \"\")",
        "+ ",
        "  cat(\"  suitability:  \", paste(class(x$suitability), collapse = \"/\"), \"\\n\", sep = \"\")",
        "+ ",
        "  cat(\"  bias_surface: \",",
        "+ ",
        "      if (is.null(x$bias_surface)) \"NULL\" else paste(class(x$bias_surface), collapse = \"/\"),",
        "+ ",
        "      \"\\n\", sep = \"\")",
        "+ ",
        "  cat(\"  occurrences:  \", paste(class(x$occurrences), collapse = \"/\"), \"\\n\", sep = \"\")",
        "+ ",
        "  invisible(x)",
        "+ ",
        "}",
        "> ",
        "vs_1 <- create_virtual_species(env_bg = env_stack_small,",
        "+ ",
        "                               center = niche_center,",
        "+ ",
        "                               axes = niche_axes,",
        "+ ",
        "                               n_occ = 75,",
        "+ ",
        "                               bias_surface = c(sp_rich, nighttime),",
        "+ ",
        "                               bias_dir = c(1, -1),",
        "+ ",
        "                               out.suit = \"both\",",
        "+ ",
        "                               out.bias = \"both\",",
        "+ ",
        "                               distances = TRUE,",
        "+ ",
        "                               out.file = TRUE)",
        "\u001BG3;Built niche object.\n\u001Bg\u001BG3;Starting get_suitable_env()...\n\u001Bg\u001BG3;Preparing environmental background...\n\u001Bg\u001BG3;env_bg is a SpatRaster. Estimating size for data.frame conversion...\n\u001Bg\u001BG3;Estimated size ~851 MB. Converting raster to data.frame with as.data.frame.nicheR()...\n\u001Bg\u001BG3;Estimated raster size ~ 425.52 MB (37182370 cells x 3 layers)\n\u001Bg\u001BG3;Using in-memory terra::as.data.frame (below threshold).\n\u001Bg\u001BG3;Using 3 predictor columns for the ellipsoid.\n\u001Bg\u001BG3;Subsetting to the ellipsoid bounding box in E space.",
        "..\n\u001Bg\u001BG3;Bounding box subsetting reduced data from 12412229 to 1070550 rows.\n\u001Bg\u001BG3;1070550 rows have complete predictor values. Computing Mahalanobis distances...\n\u001Bg\u001BG3;310771 points fall inside the ellipsoid.\n\u001Bg\u001BG3;Building spatial output...\n\u001Bg\u001BG3;Using original SpatRaster as template for spatial output.\n\u001Bg\u001BG3;Also creating distance raster (dist_sq).\n\u001Bg\u001BG3;Finished get_suitable_env().\n\u001Bg\u001BG3;Computed suitable environments.\n\u001Bg\u001BG3;Starting set_bias_surface()...\n\u001Bg\u001BG3;bias_surface provided as SpatRaster. Split",
        "ting into single layers...\n\u001Bg\u001BG3;Using 'suitable_env' raster as template and mask.\n\u001Bg\u001BG3;Processing and standardizing 2 bias layer(s) on the template grid...\n\u001Bg\u001BG3;  - Aligning bias layer 1 (sp_richness) to template grid (resample).\n\u001Bg\u001BG3;  - Aligning bias layer 2 (nighttime) to template grid (resample).\n\u001Bg\u001BG3;Finished processing bias layers.\n\u001Bg\u001BG3;Pooling 2 bias layer(s) into a single surface...\n\u001Bg\u001BG3;Finished pooling bias layers.\n\u001Bg\u001BG3;set_bias_surface() completed successfully.\n\u001Bg\u001BG3;Constructed pooled bi",
        "as surface via set_bias_surface().\n\u001Bg\u001BG3;Starting get_sample_occ()...\n\u001Bg\u001BG2;\u001BH2;Warning\u001Bh: Sampling seed not set; results will differ each time this function is run.\n\u001Bg\u001BG2;\u001BG3;Coercing 'suitable_env' to a data.frame of candidate environments...\n\u001Bg\u001BG3;Suitable pool contains 310771 candidate environments.\n\u001Bg\u001BG3;Extracting bias values at suitable locations...\n\u001Bg\u001Bg\u001BG2;\u001BG3;Computing sampling weights using method = 'random'...\n\u001Bg\u001BG3;Applying bias surface to sampling weights...\n\u001Bg\u001BG3;Drawing 75 samples without a f",
        "ixed seed...\n\u001Bg\u001BG3;Finished get_sample_occ(): sampled 75 occurrences.\n\u001Bg\u001BG3;Sampled occurrences.\n\u001Bg\u001Bg\u001BG2;\u001BG3;Virtual species saved to: C:\\Users\\mcguz\\OneDrive\\Desktop\\Virtual Species Project\\NicheR\\NicheR\\NicheR_vs_2025-11-18_16-36-01.rds\n\u001Bg\u001Bg\u001BG2;\u001BH2;Warning message\u001Bh:\nIn (function (center = c(x = 0, y = 0), axes = c(1, 1), angles = 0,  :\n  No angles specified. All axes will be applied the same angle specified: 0\n\u001Bg",
        "> ",
        "plot_e_space(vs = vs_1)",
        "\u001BG1;\u001BH1;Error\u001Bh in plot_e_space(vs = vs_1) : \n  'env_bg' must be supplied, or inferable from 'vs$suitability'.\n\u001Bg",
        "> ",
        "plot_e_space(env_bg = env_stack_small, vs = vs_1)",
        "\u001BG3;No complete x, y, z specification provided. Using predictor columns inferred from 'env_bg': mean_temp, temp_seasonality, annual_precip\n\u001Bg\u001BG3;Using predictor columns: mean_temp, temp_seasonality, annual_precip\n\u001Bg\u001BG3;Sampling 10000 of 310771 rows from 'suitable_env' for plotting.\n\u001Bg\u001BG3;Sampling 10000 of 12412229 rows from 'env_bg' for plotting.\n\u001Bg",
        "> ",
        "#' Plot Environmental Space with Optional Ellipsoid Overlays",
        "> ",
        "#'",
        "> ",
        "#' Produces pairwise views of a 3D environmental space with optional overlays of a",
        "> ",
        "#' virtual niche ellipsoid and occurrence points. In 2D mode, it returns a grid",
        "> ",
        "#' of pairwise scatterplots with projected ellipse boundaries. In 3D mode, it",
        "> ",
        "#' returns an interactive \\code{plotly} scatterplot.",
        "> ",
        "#'",
        "> ",
        "#' @param env_bg A \\code{data.frame} (or coercible object) of background environments",
        "> ",
        "#'   with at least three numeric predictor columns. These columns must contain",
        "> ",
        "#'   the variables referenced by \\code{x}, \\code{y}, and \\code{z}. If \\code{env_bg}",
        "> ",
        "#'   is a \\code{terra::SpatRaster} or \\code{raster::Raster*}, it is converted with",
        "> ",
        "#'   \\code{as.data.frame.nicheR()}. If \\code{NULL}, a \\code{NicheR_species} object",
        "> ",
        "#'   supplied via \\code{vs} can be used to infer \\code{env_bg} from its",
        "> ",
        "#'   \\code{suitability} slot.",
        "> ",
        "#' @param x,y,z Column specifications for the three predictors to display. Each may",
        "> ",
        "#'   be a single column name (character string) or a single 1-based integer index",
        "> ",
        "#'   into \\code{env_bg}. If any of \\code{x}, \\code{y}, or \\code{z} are omitted,",
        "> ",
        "#'   the function attempts to infer them from the predictor columns in \\code{env_bg}",
        "> ",
        "#'   (excluding \\code{\"x\"} and \\code{\"y\"} coordinate columns if present).",
        "> ",
        "#' @param labels Character vector of length 3 giving axis labels for the x, y,",
        "> ",
        "#'   and z variables in display order. Defaults to \\code{c(\"ENV 1\", \"ENV 2\", \"ENV 3\")}.",
        "> ",
        "#' @param n_bg Positive integer giving the maximum number of background rows to plot.",
        "> ",
        "#'   If \\code{nrow(env_bg)} is greater than \\code{n_bg}, a random subset of size",
        "> ",
        "#'   \\code{n_bg} is drawn. Using a large \\code{n_bg} may slow plotting.",
        "> ",
        "#' @param niche Optional object of class \\code{ellipsoid} describing the niche. If",
        "> ",
        "#'   provided, its boundary and center will be plotted. For 2D plots, the",
        "> ",
        "#'   object should contain \\code{niche$angles}. If \\code{NULL} and a",
        "> ",
        "#'   \\code{NicheR_species} object is supplied via \\code{vs}, \\code{niche} is",
        "> ",
        "#'   filled from \\code{vs$niche}.",
        "> ",
        "#' @param suitable_env Optional suitable environment object (data.frame,",
        "> ",
        "#'   \\code{suitable_env} list, or SpatRaster), typically produced by",
        "> ",
        "#'   \\code{\\link{get_suitable_env}}. When provided, points inside the ellipsoid",
        "> ",
        "#'   are plotted in E space.",
        "> ",
        "#' @param occ_pts Optional \\code{data.frame} of occurrence points that includes the",
        "> ",
        "#'   same predictor columns used for \\code{x}, \\code{y}, and \\code{z}. These are",
        "> ",
        "#'   overplotted if supplied. If \\code{NULL} and a \\code{NicheR_species} object",
        "> ",
        "#'   is supplied via \\code{vs}, this is filled from \\code{vs$occurrences} when available.",
        "> ",
        "#' @param rand_seed Integer used to set the random number generator seed for",
        "> ",
        "#'   reproducible background downsampling.",
        "> ",
        "#' @param show.occ.density Logical. If \\code{TRUE} and \\code{occ_pts} is provided,",
        "> ",
        "#'   adds marginal density panels for each variable (2D plots only;",
        "> ",
        "#'   \\code{plot.3d = FALSE}).",
        "> ",
        "#' @param plot.3d Logical. If \\code{TRUE}, returns an interactive \\code{plotly} 3D scatter",
        "> ",
        "#'   plot. If \\code{FALSE} (the default), returns a static \\code{ggpubr} grid of 2D panels.",
        "> ",
        "#' @param colors Optional named list of colors to override the default palette.",
        "> ",
        "#'   Valid names are: \\code{bg}, \\code{ellipsoid}, \\code{centroid}, \\code{tolerance},",
        "> ",
        "#'   \\code{suitable_env}, \\code{occ}.",
        "> ",
        "#' @param palette Character name of the internal palette to use.",
        "> ",
        "#'   One of \\code{\"default\"}, \\code{\"palette2\"}, ..., \\code{\"palette6\"}.",
        "> ",
        "#' @param vs Optional \\code{NicheR_species} object returned by",
        "> ",
        "#'   \\code{\\link{create_virtual_species}}. If provided, \\code{niche},",
        "> ",
        "#'   \\code{occ_pts}, \\code{env_bg}, and \\code{suitable_env} are auto-filled from",
        "> ",
        "#'   this object when they are not supplied explicitly.",
        "> ",
        "#'",
        "> ",
        "#' @return",
        "> ",
        "#' If \\code{plot.3d = TRUE}, a \\code{plotly} object.",
        "> ",
        "#' If \\code{plot.3d = FALSE}, a \\code{ggpubr} object containing arranged",
        "> ",
        "#' \\code{ggplot2} panels.",
        "> ",
        "#'",
        "> ",
        "#' @family plotting functions",
        "> ",
        "#' @seealso \\code{\\link{validate_plot_e_space_args}}, \\code{\\link{build_ellps}},",
        "> ",
        "#'   \\code{\\link{get_suitable_env}}, \\code{\\link{create_virtual_species}}",
        "> ",
        "#' @import RColorBrewer ggplot2 dplyr",
        "> ",
        "#' @importFrom rlang .data",
        "> ",
        "#' @export",
        "> ",
        "plot_e_space <- function(env_bg,",
        "+ ",
        "                         x, y, z,",
        "+ ",
        "                         labels = c(\"ENV 1\", \"ENV 2\", \"ENV 3\"),",
        "+ ",
        "                         n_bg = 10000,",
        "+ ",
        "                         niche = NULL,",
        "+ ",
        "                         suitable_env = NULL,",
        "+ ",
        "                         occ_pts = NULL,",
        "+ ",
        "                         rand_seed = 1234,",
        "+ ",
        "                         show.occ.density = FALSE, # only for 2D plots",
        "+ ",
        "                         plot.3d = FALSE,",
        "+ ",
        "                         colors = NULL,",
        "+ ",
        "                         palette = \"default\",",
        "+ ",
        "                         vs = NULL) {",
        "+ ",
        "+ ",
        "  # Track whether x,y,z were auto-inferred",
        "+ ",
        "  x_missing <- missing(x)",
        "+ ",
        "  y_missing <- missing(y)",
        "+ ",
        "  z_missing <- missing(z)",
        "+ ",
        "  auto_inferred <- x_missing || y_missing || z_missing",
        "+ ",
        "+ ",
        "  # --- 0. Optionally fill from NicheR_species object -------------------------",
        "+ ",
        "+ ",
        "  if (!is.null(vs)) {",
        "+ ",
        "    if (!inherits(vs, \"NicheR_species\")) {",
        "+ ",
        "      stop(\"'vs' must be a NicheR_species object created by create_virtual_species().\")",
        "+ ",
        "    }",
        "+ ",
        "+ ",
        "    # Fill niche if missing",
        "+ ",
        "    if (is.null(niche) && !is.null(vs$niche)) {",
        "+ ",
        "      niche <- vs$niche",
        "+ ",
        "    }",
        "+ ",
        "+ ",
        "    # Fill occurrences if missing",
        "+ ",
        "    if (is.null(occ_pts) && !is.null(vs$occurrences)) {",
        "+ ",
        "      occ_pts <- vs$occurrences",
        "+ ",
        "    }",
        "+ ",
        "+ ",
        "    # Fill env_bg if missing, using suitability slot",
        "+ ",
        "    if (missing(env_bg) || is.null(env_bg)) {",
        "+ ",
        "      if (inherits(vs$suitability, \"SpatRaster\")) {",
        "+ ",
        "        env_bg <- as.data.frame.nicheR(vs$suitability)",
        "+ ",
        "      } else if (is.data.frame(vs$suitability)) {",
        "+ ",
        "        env_bg <- vs$suitability",
        "+ ",
        "      }",
        "+ ",
        "    }",
        "+ ",
        "+ ",
        "    # Fill suitable_env if missing, using suitability slot directly",
        "+ ",
        "    if (is.null(suitable_env) && !is.null(vs$suitability)) {",
        "+ ",
        "      suitable_env <- vs$suitability",
        "+ ",
        "    }",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  if (missing(env_bg) || is.null(env_bg)) {",
        "+ ",
        "    stop(\"'env_bg' must be supplied, or inferable from 'vs$suitability'.\")",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  # --- 0.1 Coerce env_bg to data.frame --------------------------------------",
        "+ ",
        "+ ",
        "  if (inherits(env_bg, \"tbl_df\")) {",
        "+ ",
        "    env_bg <- as.data.frame(env_bg)",
        "+ ",
        "  }",
        "+ ",
        "  if (inherits(env_bg, \"Raster\")) {",
        "+ ",
        "    env_bg <- terra::rast(env_bg)",
        "+ ",
        "  }",
        "+ ",
        "  if (inherits(env_bg, \"SpatRaster\")) {",
        "+ ",
        "+ ",
        "    ncell <- terra::ncell(env_bg)",
        "+ ",
        "    nlyr  <- terra::nlyr(env_bg)",
        "+ ",
        "    est_mb <- (ncell * nlyr * 8) / 1024^2  # 8 bytes per numeric",
        "+ ",
        "+ ",
        "    size_threshold_mb <- 5000",
        "+ ",
        "+ ",
        "    if (est_mb > size_threshold_mb) {",
        "+ ",
        "      stop(",
        "+ ",
        "        \"The provided 'env_bg' raster stack is large (estimated ~\",",
        "+ ",
        "        round(est_mb, 1),",
        "+ ",
        "        \" MB if converted to a full data.frame).\\n\",",
        "+ ",
        "        \"For memory safety, please convert it to a data.frame yourself, e.g. using\\n\",",
        "+ ",
        "        \"  as.data.frame.nicheR(env_bg, use_cache = TRUE)\\n\",",
        "+ ",
        "        \"and then pass that data.frame as 'env_bg'.\"",
        "+ ",
        "      )",
        "+ ",
        "    }",
        "+ ",
        "+ ",
        "    env_bg <- as.data.frame.nicheR(env_bg)",
        "+ ",
        "+ ",
        "  }",
        "+ ",
        "  if (!is.data.frame(env_bg)) {",
        "+ ",
        "    stop(\"'env_bg' must be a data.frame or coercible to one.\")",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  # --- 0.2 Auto-infer x,y,z from env_bg if needed ---------------------------",
        "+ ",
        "+ ",
        "  if (auto_inferred) {",
        "+ ",
        "+ ",
        "    if (all(c(\"x\", \"y\") %in% names(env_bg))) {",
        "+ ",
        "      candidate_vars <- setdiff(names(env_bg), c(\"x\", \"y\"))",
        "+ ",
        "    } else {",
        "+ ",
        "      candidate_vars <- names(env_bg)",
        "+ ",
        "    }",
        "+ ",
        "+ ",
        "    if (length(candidate_vars) < 3) {",
        "+ ",
        "      stop(",
        "+ ",
        "        \"Could not infer x, y, z from 'env_bg' (fewer than 3 predictor columns after \",",
        "+ ",
        "        \"removing any 'x'/'y' coordinates). Please provide x, y, and z explicitly.\"",
        "+ ",
        "      )",
        "+ ",
        "    }",
        "+ ",
        "+ ",
        "    # Use first 3 predictor columns as x,y,z",
        "+ ",
        "    inferred <- candidate_vars[seq_len(3)]",
        "+ ",
        "    x <- inferred[1]",
        "+ ",
        "    y <- inferred[2]",
        "+ ",
        "    z <- inferred[3]",
        "+ ",
        "+ ",
        "    message(",
        "+ ",
        "      \"No complete x, y, z specification provided. Using predictor columns inferred from 'env_bg': \",",
        "+ ",
        "      paste(inferred, collapse = \", \")",
        "+ ",
        "    )",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  # --- 1. Validate core arguments and resolve predictor names ----------------",
        "+ ",
        "+ ",
        "  v <- validate_plot_e_space_args(",
        "+ ",
        "    env_bg, x, y, z,",
        "+ ",
        "    labels, n_bg,",
        "+ ",
        "    niche,",
        "+ ",
        "    occ_pts, show.occ.density",
        "+ ",
        "  )",
        "+ ",
        "+ ",
        "  col_x <- v$col_names[1]",
        "+ ",
        "  col_y <- v$col_names[2]",
        "+ ",
        "  col_z <- v$col_names[3]",
        "+ ",
        "+ ",
        "  # If user did provide x,y,z but as indices/variants, still nice to tell them",
        "+ ",
        "  if (auto_inferred) {",
        "+ ",
        "    message(",
        "+ ",
        "      \"Using predictor columns: \",",
        "+ ",
        "      paste(v$col_names, collapse = \", \")",
        "+ ",
        "    )",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  # Coerce occ_pts to data.frame (structure already checked in validator)",
        "+ ",
        "  if (!is.null(occ_pts)) {",
        "+ ",
        "    occ_pts <- as.data.frame(occ_pts)",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  # --- 2. Coerce suitable_env to a data.frame of inside points (if given) ----",
        "+ ",
        "+ ",
        "  pts_in <- NULL",
        "+ ",
        "  if (!is.null(suitable_env)) {",
        "+ ",
        "+ ",
        "    if (inherits(suitable_env, \"suitable_env\") ||",
        "+ ",
        "        (is.list(suitable_env) &&",
        "+ ",
        "         any(c(\"suitable_env_df\", \"suitable_env_sp\") %in% names(suitable_env)))) {",
        "+ ",
        "+ ",
        "      if (\"suitable_env_df\" %in% names(suitable_env) &&",
        "+ ",
        "          is.data.frame(suitable_env$suitable_env_df)) {",
        "+ ",
        "+ ",
        "        pts_in <- suitable_env$suitable_env_df",
        "+ ",
        "+ ",
        "      } else if (\"suitable_env_sp\" %in% names(suitable_env)) {",
        "+ ",
        "+ ",
        "        sp <- suitable_env$suitable_env_sp",
        "+ ",
        "        if (inherits(sp, \"Raster\")) sp <- terra::rast(sp)",
        "+ ",
        "+ ",
        "        if (inherits(sp, \"SpatRaster\")) {",
        "+ ",
        "          pts_in <- as.data.frame.nicheR(sp)",
        "+ ",
        "        } else if (is.list(sp) &&",
        "+ ",
        "                   length(sp) > 0 &&",
        "+ ",
        "                   all(vapply(sp, inherits, logical(1), \"SpatRaster\"))) {",
        "+ ",
        "+ ",
        "          if (\"suitable\" %in% names(sp)) {",
        "+ ",
        "            pts_in <- as.data.frame.nicheR(sp[[\"suitable\"]])",
        "+ ",
        "          } else {",
        "+ ",
        "            pts_in <- as.data.frame.nicheR(sp[[1]])",
        "+ ",
        "          }",
        "+ ",
        "        }",
        "+ ",
        "      }",
        "+ ",
        "+ ",
        "    } else if (inherits(suitable_env, \"Raster\") || inherits(suitable_env, \"SpatRaster\")) {",
        "+ ",
        "+ ",
        "      if (inherits(suitable_env, \"Raster\")) {",
        "+ ",
        "        suitable_env <- terra::rast(suitable_env)",
        "+ ",
        "      }",
        "+ ",
        "      pts_in <- as.data.frame.nicheR(suitable_env)",
        "+ ",
        "+ ",
        "    } else if (is.data.frame(suitable_env) || is.matrix(suitable_env)) {",
        "+ ",
        "+ ",
        "      pts_in <- as.data.frame(suitable_env)",
        "+ ",
        "    }",
        "+ ",
        "+ ",
        "    if (!is.null(pts_in)) {",
        "+ ",
        "      if (!all(c(col_x, col_y, col_z) %in% names(pts_in))) {",
        "+ ",
        "        warning(",
        "+ ",
        "          \"suitable_env does not contain all of x, y, z predictor columns; \",",
        "+ ",
        "          \"suitable points will not be plotted in E-space.\"",
        "+ ",
        "        )",
        "+ ",
        "        pts_in <- NULL",
        "+ ",
        "      }",
        "+ ",
        "+ ",
        "      if (nrow(pts_in) > n_bg) {",
        "+ ",
        "        message(sprintf(\"Sampling %d of %d rows from 'suitable_env' for plotting.\", n_bg, nrow(pts_in)))",
        "+ ",
        "        set.seed(rand_seed)",
        "+ ",
        "        pts_in <- pts_in[sample.int(nrow(pts_in), size = n_bg, replace = FALSE), ]",
        "+ ",
        "      }",
        "+ ",
        "+ ",
        "    }",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  # --- 3. Colors / palette ---------------------------------------------------",
        "+ ",
        "+ ",
        "  palettes <- list(",
        "+ ",
        "    default = list(",
        "+ ",
        "      bg           = \"#9093A2FF\",",
        "+ ",
        "      ellipsoid    = \"#2A363BFF\",",
        "+ ",
        "      centroid     = \"#D72000FF\",",
        "+ ",
        "      tolerance    = \"#EE6100FF\",",
        "+ ",
        "      suitable_env = \"#FED789FF\",",
        "+ ",
        "      occ          = \"#B4BF3AFF\"",
        "+ ",
        "    ),",
        "+ ",
        "    palette2 = list(",
        "+ ",
        "      bg           = \"#9CA9BAFF\",",
        "+ ",
        "      ellipsoid    = \"#3D619DFF\",",
        "+ ",
        "      centroid     = \"#345084FF\",",
        "+ ",
        "      tolerance    = \"#693829FF\",",
        "+ ",
        "      suitable_env = \"#CFB267FF\",",
        "+ ",
        "      occ          = \"#A56A3EFF\"",
        "+ ",
        "    ),",
        "+ ",
        "    palette3 = list(",
        "+ ",
        "      bg           = \"#C8CCC6FF\",",
        "+ ",
        "      ellipsoid    = \"#023743FF\",",
        "+ ",
        "      centroid     = \"#72874EFF\",",
        "+ ",
        "      tolerance    = \"#476F84FF\",",
        "+ ",
        "      suitable_env = \"#FED789FF\",",
        "+ ",
        "      occ          = \"#A4BED5FF\"",
        "+ ",
        "    ),",
        "+ ",
        "    palette4 = list(",
        "+ ",
        "      bg           = \"#C0D1CEFF\",",
        "+ ",
        "      ellipsoid    = \"#859B6CFF\",",
        "+ ",
        "      centroid     = \"#B74954FF\",",
        "+ ",
        "      tolerance    = \"#A99364FF\",",
        "+ ",
        "      suitable_env = \"#C2DDB2FF\",",
        "+ ",
        "      occ          = \"#EBA49EFF\"",
        "+ ",
        "    ),",
        "+ ",
        "    palette5 = list(",
        "+ ",
        "      bg           = \"#A89F8EFF\",",
        "+ ",
        "      ellipsoid    = \"#7887A4FF\",",
        "+ ",
        "      centroid     = \"#A8CDECFF\",",
        "+ ",
        "      tolerance    = \"#682C37FF\",",
        "+ ",
        "      suitable_env = \"#F6955EFF\",",
        "+ ",
        "      occ          = \"#9B6981FF\"",
        "+ ",
        "    ),",
        "+ ",
        "    palette6 = list(",
        "+ ",
        "      bg           = \"#D3D4D8FF\",",
        "+ ",
        "      ellipsoid    = \"#731A12FF\",",
        "+ ",
        "      centroid     = \"#F2D43DFF\",",
        "+ ",
        "      tolerance    = \"#3F858CFF\",",
        "+ ",
        "      suitable_env = \"#D9814EFF\",",
        "+ ",
        "      occ          = \"#707322FF\"",
        "+ ",
        "    )",
        "+ ",
        "  )",
        "+ ",
        "+ ",
        "  if (!palette %in% names(palettes)) {",
        "+ ",
        "    stop(\"Unknown palette '\", palette, \"'.\")",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  base_colors <- palettes[[palette]]",
        "+ ",
        "+ ",
        "  if (is.null(colors)) {",
        "+ ",
        "    colors <- base_colors",
        "+ ",
        "  } else {",
        "+ ",
        "    if (is.null(names(colors))) {",
        "+ ",
        "      names(colors) <- names(base_colors)[seq_along(colors)]",
        "+ ",
        "      if (!is.list(colors)) colors <- as.list(colors)",
        "+ ",
        "      message(",
        "+ ",
        "        \"No names detected in 'colors'. \",",
        "+ ",
        "        \"Using the order provided and filling missing entries with defaults.\\n\",",
        "+ ",
        "        \"If you want to change a specific object, use a named list.\\n\",",
        "+ ",
        "        \"Available options are: \",",
        "+ ",
        "        paste(names(base_colors), collapse = \", \")",
        "+ ",
        "      )",
        "+ ",
        "    }",
        "+ ",
        "    if (!is.list(colors)) colors <- as.list(colors)",
        "+ ",
        "    colors <- utils::modifyList(base_colors, colors)",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  # Legend options ------------------------------------------------------------",
        "+ ",
        "+ ",
        "  opts <- list(",
        "+ ",
        "    background_point     = TRUE,",
        "+ ",
        "    trace_line           = !is.null(niche),",
        "+ ",
        "    centroid_point       = !is.null(niche),",
        "+ ",
        "    tolerance_range_line = !is.null(niche),",
        "+ ",
        "    suitable_point       = !is.null(pts_in),",
        "+ ",
        "    occurrence_point     = !is.null(occ_pts)",
        "+ ",
        "  )",
        "+ ",
        "+ ",
        "  legend_items <- data.frame(",
        "+ ",
        "    id       = c(\"background_point\",\"trace_line\",\"centroid_point\",",
        "+ ",
        "                 \"tolerance_range_line\",\"suitable_point\",\"occurrence_point\"),",
        "+ ",
        "    type     = c(\"point\",\"line\",\"point\",\"line\",\"point\",\"point\"),",
        "+ ",
        "    label    = c(\"Background environments\",\"Niche boundary\",\"Niche centroid\",",
        "+ ",
        "                 \"Tolerance ranges\",\"Suitable environments\",\"Occurrences\"),",
        "+ ",
        "    color    = c(colors[[\"bg\"]], colors[[\"ellipsoid\"]], colors[[\"centroid\"]],",
        "+ ",
        "                 colors[[\"tolerance\"]], colors[[\"suitable_env\"]], colors[[\"occ\"]]),",
        "+ ",
        "    linetype = c(NA, 1, NA, 2, NA, NA),",
        "+ ",
        "    stringsAsFactors = FALSE",
        "+ ",
        "  )",
        "+ ",
        "+ ",
        "  active <- logical(nrow(legend_items))",
        "+ ",
        "  for (i in seq_len(nrow(legend_items))) {",
        "+ ",
        "    active[i] <- isTRUE(opts[[ legend_items$id[i] ]])",
        "+ ",
        "  }",
        "+ ",
        "  legend_items <- legend_items[active, , drop = FALSE]",
        "+ ",
        "+ ",
        "  # Build legend plot ---------------------------------------------------------",
        "+ ",
        "+ ",
        "  if (nrow(legend_items) == 0) {",
        "+ ",
        "    legend_plot <- ggplot2::ggplot() + ggplot2::theme_void()",
        "+ ",
        "  } else {",
        "+ ",
        "    top_y   <- 2",
        "+ ",
        "    spacing <- 0.25",
        "+ ",
        "    x_point <- 0.00",
        "+ ",
        "    x_text  <- 0.1",
        "+ ",
        "    x0_line <- -0.2",
        "+ ",
        "    x1_line <-  0.00",
        "+ ",
        "+ ",
        "    legend_items <- legend_items %>%",
        "+ ",
        "      dplyr::mutate(",
        "+ ",
        "        row     = dplyr::row_number(),",
        "+ ",
        "        y       = top_y - (row - 1) * spacing,",
        "+ ",
        "        x_point = x_point,",
        "+ ",
        "        x_text  = x_text,",
        "+ ",
        "        x0_line = x0_line,",
        "+ ",
        "        x1_line = x1_line",
        "+ ",
        "      )",
        "+ ",
        "+ ",
        "    legend_base <- ggplot2::ggplot() +",
        "+ ",
        "      ggplot2::coord_cartesian(xlim = c(-0.5, 0.5), ylim = c(0, 2.5), clip = \"off\") +",
        "+ ",
        "      ggplot2::theme_void() +",
        "+ ",
        "      ggplot2::theme(legend.position = \"none\")",
        "+ ",
        "+ ",
        "    legend_plot <- legend_base +",
        "+ ",
        "      ggplot2::geom_point(",
        "+ ",
        "        data  = dplyr::filter(legend_items, type == \"point\"),",
        "+ ",
        "        ggplot2::aes(x = x_point, y = y, colour = color),",
        "+ ",
        "        size = 2",
        "+ ",
        "      ) +",
        "+ ",
        "      ggplot2::geom_segment(",
        "+ ",
        "        data  = dplyr::filter(legend_items, type == \"line\"),",
        "+ ",
        "        ggplot2::aes(x = x0_line, xend = x1_line, y = y, yend = y,",
        "+ ",
        "                     colour = color, linetype = linetype),",
        "+ ",
        "        linewidth = 0.5",
        "+ ",
        "      ) +",
        "+ ",
        "      ggplot2::geom_text(",
        "+ ",
        "        data  = legend_items,",
        "+ ",
        "        ggplot2::aes(x = x_text, y = y, label = label),",
        "+ ",
        "        hjust = 0",
        "+ ",
        "      ) +",
        "+ ",
        "      ggplot2::scale_colour_identity() +",
        "+ ",
        "      ggplot2::scale_linetype_identity()",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  # Downsample background -----------------------------------------------------",
        "+ ",
        "+ ",
        "  if (nrow(env_bg) > n_bg) {",
        "+ ",
        "    message(sprintf(\"Sampling %d of %d rows from 'env_bg' for plotting.\", n_bg, nrow(env_bg)))",
        "+ ",
        "    set.seed(rand_seed)",
        "+ ",
        "    env_bg <- env_bg[sample.int(nrow(env_bg), size = n_bg, replace = FALSE), ]",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  # ---------------------------------------------------------------------------",
        "+ ",
        "  # 3D plotting branch",
        "+ ",
        "  # ---------------------------------------------------------------------------",
        "+ ",
        "+ ",
        "  if (isTRUE(plot.3d)) {",
        "+ ",
        "+ ",
        "    p3 <- plotly::plot_ly(",
        "+ ",
        "      data = env_bg,",
        "+ ",
        "      x    = env_bg[[col_x]],",
        "+ ",
        "      y    = env_bg[[col_y]],",
        "+ ",
        "      z    = env_bg[[col_z]],",
        "+ ",
        "      type = \"scatter3d\",",
        "+ ",
        "      mode = \"markers\",",
        "+ ",
        "      marker = list(color = colors[[\"bg\"]], size = 2),",
        "+ ",
        "      name   = \"Background Environments\"",
        "+ ",
        "    ) %>%",
        "+ ",
        "      plotly::layout(",
        "+ ",
        "        title = list(text = \"Background Environments (E-space)\"),",
        "+ ",
        "        scene = list(",
        "+ ",
        "          xaxis = list(title = list(text = labels[1])),",
        "+ ",
        "          yaxis = list(title = list(text = labels[2])),",
        "+ ",
        "          zaxis = list(title = list(text = labels[3]))",
        "+ ",
        "        ),",
        "+ ",
        "        legend = list(x = 0.05, y = 0.95)",
        "+ ",
        "      )",
        "+ ",
        "+ ",
        "    # Ellipsoid surface + centroid (if present)",
        "+ ",
        "    if (!is.null(niche) && !is.null(niche$surface)) {",
        "+ ",
        "+ ",
        "      surf <- as.data.frame(niche$surface)",
        "+ ",
        "      if (ncol(surf) >= 3) {",
        "+ ",
        "        p3 <- p3 %>%",
        "+ ",
        "          plotly::add_trace(",
        "+ ",
        "            data = surf,",
        "+ ",
        "            x    = surf[[1]],",
        "+ ",
        "            y    = surf[[2]],",
        "+ ",
        "            z    = surf[[3]],",
        "+ ",
        "            type = \"scatter3d\",",
        "+ ",
        "            mode = \"lines\",",
        "+ ",
        "            line = list(color = colors[[\"ellipsoid\"]]),",
        "+ ",
        "            name = \"Niche Boundary\",",
        "+ ",
        "            inherit = FALSE",
        "+ ",
        "          )",
        "+ ",
        "      }",
        "+ ",
        "+ ",
        "      if (!is.null(niche$center) && length(niche$center) >= 3) {",
        "+ ",
        "        p3 <- p3 %>%",
        "+ ",
        "          plotly::add_markers(",
        "+ ",
        "            x = niche$center[1],",
        "+ ",
        "            y = niche$center[2],",
        "+ ",
        "            z = niche$center[3],",
        "+ ",
        "            marker = list(color = colors[[\"centroid\"]], size = 5),",
        "+ ",
        "            name   = \"Niche Centroid\"",
        "+ ",
        "          )",
        "+ ",
        "      }",
        "+ ",
        "+ ",
        "      if (!is.null(pts_in)) {",
        "+ ",
        "        p3 <- p3 %>%",
        "+ ",
        "          plotly::add_markers(",
        "+ ",
        "            data = pts_in,",
        "+ ",
        "            x    = pts_in[[col_x]],",
        "+ ",
        "            y    = pts_in[[col_y]],",
        "+ ",
        "            z    = pts_in[[col_z]],",
        "+ ",
        "            marker = list(color = colors[[\"suitable_env\"]], size = 3),",
        "+ ",
        "            name   = \"Suitable Environments\",",
        "+ ",
        "            inherit = FALSE",
        "+ ",
        "          )",
        "+ ",
        "      }",
        "+ ",
        "    }",
        "+ ",
        "+ ",
        "    # Occurrence points in 3D",
        "+ ",
        "    if (!is.null(occ_pts)) {",
        "+ ",
        "      p3 <- p3 %>%",
        "+ ",
        "        plotly::add_markers(",
        "+ ",
        "          data = occ_pts,",
        "+ ",
        "          x    = occ_pts[[col_x]],",
        "+ ",
        "          y    = occ_pts[[col_y]],",
        "+ ",
        "          z    = occ_pts[[col_z]],",
        "+ ",
        "          marker = list(color = colors[[\"occ\"]], size = 3),",
        "+ ",
        "          name   = \"Sampled Occurrences\",",
        "+ ",
        "          inherit = FALSE",
        "+ ",
        "        ) %>%",
        "+ ",
        "        plotly::layout(",
        "+ ",
        "          title  = \"Virtual Niche and Sampled Occurrences in E-space\",",
        "+ ",
        "          legend = list(x = 0.05, y = 0.95)",
        "+ ",
        "        )",
        "+ ",
        "    }",
        "+ ",
        "+ ",
        "    return(p3)",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  # ---------------------------------------------------------------------------",
        "+ ",
        "  # 2D plotting branch",
        "+ ",
        "  # ---------------------------------------------------------------------------",
        "+ ",
        "+ ",
        "  p_main_y_x <- ggplot2::ggplot(",
        "+ ",
        "    env_bg,",
        "+ ",
        "    ggplot2::aes(x = .data[[col_y]], y = .data[[col_x]])",
        "+ ",
        "  ) +",
        "+ ",
        "    ggplot2::geom_point(alpha = 0.5, color = colors[[\"bg\"]], pch = \".\") +",
        "+ ",
        "    ggplot2::theme_bw() +",
        "+ ",
        "    ggplot2::theme(axis.title = ggplot2::element_blank())",
        "+ ",
        "+ ",
        "  p_main_z_x <- ggplot2::ggplot(",
        "+ ",
        "    env_bg,",
        "+ ",
        "    ggplot2::aes(x = .data[[col_z]], y = .data[[col_x]])",
        "+ ",
        "  ) +",
        "+ ",
        "    ggplot2::geom_point(alpha = 0.5, color = colors[[\"bg\"]], pch = \".\") +",
        "+ ",
        "    ggplot2::theme_bw() +",
        "+ ",
        "    ggplot2::theme(axis.title = ggplot2::element_blank())",
        "+ ",
        "+ ",
        "  p_main_z_y <- ggplot2::ggplot(",
        "+ ",
        "    env_bg,",
        "+ ",
        "    ggplot2::aes(x = .data[[col_z]], y = .data[[col_y]])",
        "+ ",
        "  ) +",
        "+ ",
        "    ggplot2::geom_point(alpha = 0.5, color = colors[[\"bg\"]], pch = \".\") +",
        "+ ",
        "    ggplot2::theme_bw() +",
        "+ ",
        "    ggplot2::theme(axis.title = ggplot2::element_blank())",
        "+ ",
        "+ ",
        "  x_name <- ggplot2::ggplot() + ggplot2::theme_void() +",
        "+ ",
        "    ggplot2::geom_text(ggplot2::aes(0, 0, label = labels[1]),",
        "+ ",
        "                       fontface = \"bold\")",
        "+ ",
        "  y_name <- ggplot2::ggplot() + ggplot2::theme_void() +",
        "+ ",
        "    ggplot2::geom_text(ggplot2::aes(0, 0, label = labels[2]),",
        "+ ",
        "                       fontface = \"bold\")",
        "+ ",
        "  z_name <- ggplot2::ggplot() + ggplot2::theme_void() +",
        "+ ",
        "    ggplot2::geom_text(ggplot2::aes(0, 0, label = labels[3]),",
        "+ ",
        "                       fontface = \"bold\")",
        "+ ",
        "+ ",
        "  return_plot <- ggpubr::ggarrange(",
        "+ ",
        "    x_name,      p_main_y_x, p_main_z_x,",
        "+ ",
        "    legend_plot, y_name,     p_main_z_y,",
        "+ ",
        "    NULL,        NULL,       z_name,",
        "+ ",
        "    ncol = 3, nrow = 3,",
        "+ ",
        "    widths  = c(0.15, 0.425, 0.425),",
        "+ ",
        "    heights = c(0.45, 0.45, 0.15)",
        "+ ",
        "  )",
        "+ ",
        "+ ",
        "  # --- Ellipsoid overlays and extras (2D) ------------------------------------",
        "+ ",
        "+ ",
        "  if (!is.null(niche)) {",
        "+ ",
        "+ ",
        "    center_y_x <- c(niche$center[2], niche$center[1])",
        "+ ",
        "    axes_y_x   <- c(niche$axes[2],   niche$axes[1])",
        "+ ",
        "    angle_y_x  <- c(niche$angles[2], niche$angles[1])",
        "+ ",
        "+ ",
        "    center_z_x <- c(niche$center[3], niche$center[1])",
        "+ ",
        "    axes_z_x   <- c(niche$axes[3],   niche$axes[1])",
        "+ ",
        "    angle_z_x  <- c(niche$angles[3], niche$angles[1])",
        "+ ",
        "+ ",
        "    center_z_y <- c(niche$center[3], niche$center[2])",
        "+ ",
        "    axes_z_y   <- c(niche$axes[3],   niche$axes[2])",
        "+ ",
        "    angle_z_y  <- c(niche$angles[3], niche$angles[2])",
        "+ ",
        "+ ",
        "    ell2d_y_x <- build_ellps(center = center_y_x, axes = axes_y_x, angles = angle_y_x)",
        "+ ",
        "    ell2d_z_x <- build_ellps(center = center_z_x, axes = axes_z_x, angles = angle_z_x)",
        "+ ",
        "    ell2d_z_y <- build_ellps(center = center_z_y, axes = axes_z_y, angles = angle_z_y)",
        "+ ",
        "+ ",
        "    ell_y_x <- p_main_y_x",
        "+ ",
        "    ell_z_x <- p_main_z_x",
        "+ ",
        "    ell_z_y <- p_main_z_y",
        "+ ",
        "+ ",
        "    if (any(niche$angles != 0)) {",
        "+ ",
        "      angle_warn <- ggplot2::ggplot() + ggplot2::theme_void() +",
        "+ ",
        "        ggplot2::geom_text(",
        "+ ",
        "          ggplot2::aes(0, 0,",
        "+ ",
        "                       label = \"Note: The ellipsoid is angled; its shape may appear distorted and some points may fall outside due to dimensionality.\"),",
        "+ ",
        "          size = 2",
        "+ ",
        "        )",
        "+ ",
        "    } else {",
        "+ ",
        "      angle_warn <- NULL",
        "+ ",
        "    }",
        "+ ",
        "+ ",
        "    # Suitable points (inside)",
        "+ ",
        "    if (!is.null(pts_in)) {",
        "+ ",
        "+ ",
        "      ell_y_x <- ell_y_x +",
        "+ ",
        "        ggplot2::geom_point(",
        "+ ",
        "          data = pts_in,",
        "+ ",
        "          ggplot2::aes(",
        "+ ",
        "            x = .data[[col_y]],",
        "+ ",
        "            y = .data[[col_x]]",
        "+ ",
        "          ),",
        "+ ",
        "          color = colors[[\"suitable_env\"]],",
        "+ ",
        "          size  = 0.1",
        "+ ",
        "        )",
        "+ ",
        "+ ",
        "      ell_z_x <- ell_z_x +",
        "+ ",
        "        ggplot2::geom_point(",
        "+ ",
        "          data = pts_in,",
        "+ ",
        "          ggplot2::aes(",
        "+ ",
        "            x = .data[[col_z]],",
        "+ ",
        "            y = .data[[col_x]]",
        "+ ",
        "          ),",
        "+ ",
        "          color = colors[[\"suitable_env\"]],",
        "+ ",
        "          size  = 0.5",
        "+ ",
        "        )",
        "+ ",
        "+ ",
        "      ell_z_y <- ell_z_y +",
        "+ ",
        "        ggplot2::geom_point(",
        "+ ",
        "          data = pts_in,",
        "+ ",
        "          ggplot2::aes(",
        "+ ",
        "            x = .data[[col_z]],",
        "+ ",
        "            y = .data[[col_y]]",
        "+ ",
        "          ),",
        "+ ",
        "          color = colors[[\"suitable_env\"]],",
        "+ ",
        "          size  = 0.5",
        "+ ",
        "        )",
        "+ ",
        "    }",
        "+ ",
        "+ ",
        "    # Occurrence points in 2D",
        "+ ",
        "    if (!is.null(occ_pts)) {",
        "+ ",
        "      ell_y_x <- ell_y_x +",
        "+ ",
        "        ggplot2::geom_point(",
        "+ ",
        "          data = occ_pts,",
        "+ ",
        "          ggplot2::aes(",
        "+ ",
        "            x = .data[[col_y]],",
        "+ ",
        "            y = .data[[col_x]]",
        "+ ",
        "          ),",
        "+ ",
        "          color = colors[[\"occ\"]],",
        "+ ",
        "          size  = 0.5",
        "+ ",
        "        )",
        "+ ",
        "+ ",
        "      ell_z_x <- ell_z_x +",
        "+ ",
        "        ggplot2::geom_point(",
        "+ ",
        "          data = occ_pts,",
        "+ ",
        "          ggplot2::aes(",
        "+ ",
        "            x = .data[[col_z]],",
        "+ ",
        "            y = .data[[col_x]]",
        "+ ",
        "          ),",
        "+ ",
        "          color = colors[[\"occ\"]],",
        "+ ",
        "          size  = 0.5",
        "+ ",
        "        )",
        "+ ",
        "+ ",
        "      ell_z_y <- ell_z_y +",
        "+ ",
        "        ggplot2::geom_point(",
        "+ ",
        "          data = occ_pts,",
        "+ ",
        "          ggplot2::aes(",
        "+ ",
        "            x = .data[[col_z]],",
        "+ ",
        "            y = .data[[col_y]]",
        "+ ",
        "          ),",
        "+ ",
        "          color = colors[[\"occ\"]],",
        "+ ",
        "          size  = 0.5",
        "+ ",
        "        )",
        "+ ",
        "    }",
        "+ ",
        "+ ",
        "    # Ellipse boundaries + axes + centroid -----------------------------------",
        "+ ",
        "+ ",
        "    ell_y_x <- ell_y_x +",
        "+ ",
        "      ggplot2::geom_path(",
        "+ ",
        "        data   = ell2d_y_x$surface,",
        "+ ",
        "        ggplot2::aes(x, y),",
        "+ ",
        "        color = colors[[\"ellipsoid\"]],",
        "+ ",
        "        linewidth = 0.5",
        "+ ",
        "      ) +",
        "+ ",
        "      ggplot2::annotate(",
        "+ ",
        "        \"segment\",",
        "+ ",
        "        x    = ell2d_y_x$center[1] - ell2d_y_x$axes[1],",
        "+ ",
        "        xend = ell2d_y_x$center[1] + ell2d_y_x$axes[1],",
        "+ ",
        "        y    = ell2d_y_x$center[2],",
        "+ ",
        "        yend = ell2d_y_x$center[2],",
        "+ ",
        "        color = colors[[\"tolerance\"]],",
        "+ ",
        "        linetype = \"dashed\"",
        "+ ",
        "      ) +",
        "+ ",
        "      ggplot2::annotate(",
        "+ ",
        "        \"segment\",",
        "+ ",
        "        y    = ell2d_y_x$center[2] - ell2d_y_x$axes[2],",
        "+ ",
        "        yend = ell2d_y_x$center[2] + ell2d_y_x$axes[2],",
        "+ ",
        "        x    = ell2d_y_x$center[1],",
        "+ ",
        "        xend = ell2d_y_x$center[1],",
        "+ ",
        "        color = colors[[\"tolerance\"]],",
        "+ ",
        "        linetype = \"dashed\"",
        "+ ",
        "      ) +",
        "+ ",
        "      ggplot2::annotate(",
        "+ ",
        "        \"point\",",
        "+ ",
        "        x = ell2d_y_x$center[1],",
        "+ ",
        "        y = ell2d_y_x$center[2],",
        "+ ",
        "        color = colors[[\"centroid\"]],",
        "+ ",
        "        size  = 2",
        "+ ",
        "      )",
        "+ ",
        "+ ",
        "    ell_z_x <- ell_z_x +",
        "+ ",
        "      ggplot2::geom_path(",
        "+ ",
        "        data   = ell2d_z_x$surface,",
        "+ ",
        "        ggplot2::aes(x, y),",
        "+ ",
        "        color = colors[[\"ellipsoid\"]],",
        "+ ",
        "        linewidth = 0.5",
        "+ ",
        "      ) +",
        "+ ",
        "      ggplot2::annotate(",
        "+ ",
        "        \"segment\",",
        "+ ",
        "        x    = ell2d_z_x$center[1] - ell2d_z_x$axes[1],",
        "+ ",
        "        xend = ell2d_z_x$center[1] + ell2d_z_x$axes[1],",
        "+ ",
        "        y    = ell2d_z_x$center[2],",
        "+ ",
        "        yend = ell2d_z_x$center[2],",
        "+ ",
        "        color = colors[[\"tolerance\"]],",
        "+ ",
        "        linetype = \"dashed\"",
        "+ ",
        "      ) +",
        "+ ",
        "      ggplot2::annotate(",
        "+ ",
        "        \"segment\",",
        "+ ",
        "        y    = ell2d_z_x$center[2] - ell2d_z_x$axes[2],",
        "+ ",
        "        yend = ell2d_z_x$center[2] + ell2d_z_x$axes[2],",
        "+ ",
        "        x    = ell2d_z_x$center[1],",
        "+ ",
        "        xend = ell2d_z_x$center[1],",
        "+ ",
        "        color = colors[[\"tolerance\"]],",
        "+ ",
        "        linetype = \"dashed\"",
        "+ ",
        "      ) +",
        "+ ",
        "      ggplot2::annotate(",
        "+ ",
        "        \"point\",",
        "+ ",
        "        x = ell2d_z_x$center[1],",
        "+ ",
        "        y = ell2d_z_x$center[2],",
        "+ ",
        "        color = colors[[\"centroid\"]],",
        "+ ",
        "        size  = 2",
        "+ ",
        "      )",
        "+ ",
        "+ ",
        "    ell_z_y <- ell_z_y +",
        "+ ",
        "      ggplot2::geom_path(",
        "+ ",
        "        data   = ell2d_z_y$surface,",
        "+ ",
        "        ggplot2::aes(x, y),",
        "+ ",
        "        color = colors[[\"ellipsoid\"]],",
        "+ ",
        "        linewidth = 0.5",
        "+ ",
        "      ) +",
        "+ ",
        "      ggplot2::annotate(",
        "+ ",
        "        \"segment\",",
        "+ ",
        "        x    = ell2d_z_y$center[1] - ell2d_z_y$axes[1],",
        "+ ",
        "        xend = ell2d_z_y$center[1] + ell2d_z_y$axes[1],",
        "+ ",
        "        y    = ell2d_z_y$center[2],",
        "+ ",
        "        yend = ell2d_z_y$center[2],",
        "+ ",
        "        color = colors[[\"tolerance\"]],",
        "+ ",
        "        linetype = \"dashed\"",
        "+ ",
        "      ) +",
        "+ ",
        "      ggplot2::annotate(",
        "+ ",
        "        \"segment\",",
        "+ ",
        "        y    = ell2d_z_y$center[2] - ell2d_z_y$axes[2],",
        "+ ",
        "        yend = ell2d_z_y$center[2] + ell2d_z_y$axes[2],",
        "+ ",
        "        x    = ell2d_z_y$center[1],",
        "+ ",
        "        xend = ell2d_z_y$center[1],",
        "+ ",
        "        color = colors[[\"tolerance\"]],",
        "+ ",
        "        linetype = \"dashed\"",
        "+ ",
        "      ) +",
        "+ ",
        "      ggplot2::annotate(",
        "+ ",
        "        \"point\",",
        "+ ",
        "        x = ell2d_z_y$center[1],",
        "+ ",
        "        y = ell2d_z_y$center[2],",
        "+ ",
        "        color = colors[[\"centroid\"]],",
        "+ ",
        "        size  = 2",
        "+ ",
        "      )",
        "+ ",
        "+ ",
        "    # Re-assemble main grid with ellipsoid overlays --------------------------",
        "+ ",
        "+ ",
        "    return_plot <- ggpubr::ggarrange(",
        "+ ",
        "      x_name,      ell_y_x,   ell_z_x,",
        "+ ",
        "      legend_plot, y_name,    ell_z_y,",
        "+ ",
        "      NULL,        angle_warn, z_name,",
        "+ ",
        "      ncol = 3, nrow = 3,",
        "+ ",
        "      widths  = c(0.15, 0.425, 0.425),",
        "+ ",
        "      heights = c(0.45, 0.45, 0.15)",
        "+ ",
        "    )",
        "+ ",
        "+ ",
        "    # Optional occurrence density panels -------------------------------------",
        "+ ",
        "+ ",
        "    if (isTRUE(show.occ.density) && !is.null(occ_pts)) {",
        "+ ",
        "+ ",
        "      rng_z <- range(env_bg[[col_z]], na.rm = TRUE)",
        "+ ",
        "      rng_y <- range(env_bg[[col_y]], na.rm = TRUE)",
        "+ ",
        "      rng_x <- range(env_bg[[col_x]], na.rm = TRUE)",
        "+ ",
        "+ ",
        "      env_z_top <- ggplot2::ggplot(occ_pts, ggplot2::aes(x = .data[[col_z]])) +",
        "+ ",
        "        ggplot2::geom_density(fill = colors[[\"occ\"]], alpha = 0.6) +",
        "+ ",
        "        ggplot2::scale_x_continuous(limits = rng_z) +",
        "+ ",
        "        ggplot2::scale_y_continuous(n.breaks = 3) +",
        "+ ",
        "        ggplot2::theme_minimal() +",
        "+ ",
        "        ggplot2::theme(",
        "+ ",
        "          axis.text.x  = ggplot2::element_blank(),",
        "+ ",
        "          axis.title.x = ggplot2::element_blank(),",
        "+ ",
        "          axis.title.y = ggplot2::element_blank(),",
        "+ ",
        "          axis.text.y  = ggplot2::element_text(size = 5)",
        "+ ",
        "        )",
        "+ ",
        "+ ",
        "      env_y_top <- ggplot2::ggplot(occ_pts, ggplot2::aes(x = .data[[col_y]])) +",
        "+ ",
        "        ggplot2::geom_density(fill = colors[[\"occ\"]], alpha = 0.6) +",
        "+ ",
        "        ggplot2::scale_x_continuous(limits = rng_y) +",
        "+ ",
        "        ggplot2::scale_y_continuous(n.breaks = 3) +",
        "+ ",
        "        ggplot2::theme_minimal() +",
        "+ ",
        "        ggplot2::theme(",
        "+ ",
        "          axis.text.x  = ggplot2::element_blank(),",
        "+ ",
        "          axis.title.x = ggplot2::element_blank(),",
        "+ ",
        "          axis.title.y = ggplot2::element_blank(),",
        "+ ",
        "          axis.text.y  = ggplot2::element_text(size = 5)",
        "+ ",
        "        )",
        "+ ",
        "+ ",
        "      env_x_right <- ggplot2::ggplot(occ_pts, ggplot2::aes(x = .data[[col_x]])) +",
        "+ ",
        "        ggplot2::geom_density(fill = colors[[\"occ\"]], alpha = 0.6) +",
        "+ ",
        "        ggplot2::scale_x_continuous(limits = rng_x) +",
        "+ ",
        "        ggplot2::coord_flip() +",
        "+ ",
        "        ggplot2::scale_y_continuous(n.breaks = 3) +",
        "+ ",
        "        ggplot2::theme_minimal() +",
        "+ ",
        "        ggplot2::theme(",
        "+ ",
        "          axis.text.y  = ggplot2::element_blank(),",
        "+ ",
        "          axis.title.y = ggplot2::element_blank(),",
        "+ ",
        "          axis.title.x = ggplot2::element_blank(),",
        "+ ",
        "          axis.text.x  = ggplot2::element_text(size = 5)",
        "+ ",
        "        )",
        "+ ",
        "+ ",
        "      env_y_right <- ggplot2::ggplot(occ_pts, ggplot2::aes(x = .data[[col_y]])) +",
        "+ ",
        "        ggplot2::geom_density(fill = colors[[\"occ\"]], alpha = 0.6) +",
        "+ ",
        "        ggplot2::scale_x_continuous(limits = rng_y) +",
        "+ ",
        "        ggplot2::coord_flip() +",
        "+ ",
        "        ggplot2::scale_y_continuous(n.breaks = 3) +",
        "+ ",
        "        ggplot2::theme_minimal() +",
        "+ ",
        "        ggplot2::theme(",
        "+ ",
        "          axis.text.y  = ggplot2::element_blank(),",
        "+ ",
        "          axis.title.y = ggplot2::element_blank(),",
        "+ ",
        "          axis.title.x = ggplot2::element_blank(),",
        "+ ",
        "          axis.text.x  = ggplot2::element_text(size = 5)",
        "+ ",
        "        )",
        "+ ",
        "+ ",
        "      return_plot <- ggpubr::ggarrange(",
        "+ ",
        "        NULL,        env_y_top, env_z_top, NULL,",
        "+ ",
        "        x_name,      ell_y_x,   ell_z_x,   env_x_right,",
        "+ ",
        "        legend_plot, y_name,    ell_z_y,   env_y_right,",
        "+ ",
        "        NULL,        angle_warn, z_name,   NULL,",
        "+ ",
        "        ncol = 4, nrow = 4,",
        "+ ",
        "        widths  = c(0.1, 0.4, 0.4, 0.1),",
        "+ ",
        "        heights = c(0.1, 0.4, 0.4, 0.1)",
        "+ ",
        "      )",
        "+ ",
        "    }",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  return(return_plot)",
        "+ ",
        "}",
        "> ",
        "plot_e_space(env_bg = env_stack_small, vs = vs_1)",
        "\u001BG3;No complete x, y, z specification provided. Using predictor columns inferred from 'env_bg': mean_temp, temp_seasonality, annual_precip\n\u001Bg\u001BG3;Using predictor columns: mean_temp, temp_seasonality, annual_precip\n\u001Bg\u001BG3;Sampling 10000 of 310771 rows from 'suitable_env' for plotting.\n\u001Bg\u001BG3;Sampling 10000 of 12412229 rows from 'env_bg' for plotting.\n\u001Bg",
        "> ",
        "#' Plot Environmental Space with Optional Ellipsoid Overlays",
        "> ",
        "#'",
        "> ",
        "#' Produces pairwise views of a 3D environmental space with optional overlays of a",
        "> ",
        "#' virtual niche ellipsoid and occurrence points. In 2D mode, it returns a grid",
        "> ",
        "#' of pairwise scatterplots with projected ellipse boundaries. In 3D mode, it",
        "> ",
        "#' returns an interactive \\code{plotly} scatterplot.",
        "> ",
        "#'",
        "> ",
        "#' @param env_bg A \\code{data.frame} (or coercible object) of background environments",
        "> ",
        "#'   with at least three numeric predictor columns. These columns must contain",
        "> ",
        "#'   the variables referenced by \\code{x}, \\code{y}, and \\code{z}. If \\code{env_bg}",
        "> ",
        "#'   is a \\code{terra::SpatRaster} or \\code{raster::Raster*}, it is converted with",
        "> ",
        "#'   \\code{as.data.frame.nicheR()}. If \\code{NULL}, a \\code{NicheR_species} object",
        "> ",
        "#'   supplied via \\code{vs} can be used to infer \\code{env_bg} from its",
        "> ",
        "#'   \\code{suitability} slot.",
        "> ",
        "#' @param x,y,z Column specifications for the three predictors to display. Each may",
        "> ",
        "#'   be a single column name (character string) or a single 1-based integer index",
        "> ",
        "#'   into \\code{env_bg}. If any of \\code{x}, \\code{y}, or \\code{z} are omitted,",
        "> ",
        "#'   the function attempts to infer them from the predictor columns in \\code{env_bg}",
        "> ",
        "#'   (excluding \\code{\"x\"} and \\code{\"y\"} coordinate columns if present).",
        "> ",
        "#' @param labels Character vector of length 3 giving axis labels for the x, y,",
        "> ",
        "#'   and z variables in display order. Defaults to \\code{c(\"ENV 1\", \"ENV 2\", \"ENV 3\")}.",
        "> ",
        "#' @param n_bg Positive integer giving the maximum number of background rows to plot.",
        "> ",
        "#'   If \\code{nrow(env_bg)} is greater than \\code{n_bg}, a random subset of size",
        "> ",
        "#'   \\code{n_bg} is drawn. Using a large \\code{n_bg} may slow plotting.",
        "> ",
        "#' @param niche Optional object of class \\code{ellipsoid} describing the niche. If",
        "> ",
        "#'   provided, its boundary and center will be plotted. For 2D plots, the",
        "> ",
        "#'   object should contain \\code{niche$angles}. If \\code{NULL} and a",
        "> ",
        "#'   \\code{NicheR_species} object is supplied via \\code{vs}, \\code{niche} is",
        "> ",
        "#'   filled from \\code{vs$niche}.",
        "> ",
        "#' @param suitable_env Optional suitable environment object (data.frame,",
        "> ",
        "#'   \\code{suitable_env} list, or SpatRaster), typically produced by",
        "> ",
        "#'   \\code{\\link{get_suitable_env}}. When provided, points inside the ellipsoid",
        "> ",
        "#'   are plotted in E space.",
        "> ",
        "#' @param occ_pts Optional \\code{data.frame} of occurrence points that includes the",
        "> ",
        "#'   same predictor columns used for \\code{x}, \\code{y}, and \\code{z}. These are",
        "> ",
        "#'   overplotted if supplied. If \\code{NULL} and a \\code{NicheR_species} object",
        "> ",
        "#'   is supplied via \\code{vs}, this is filled from \\code{vs$occurrences} when available.",
        "> ",
        "#' @param rand_seed Integer used to set the random number generator seed for",
        "> ",
        "#'   reproducible background downsampling.",
        "> ",
        "#' @param show.occ.density Logical. If \\code{TRUE} and \\code{occ_pts} is provided,",
        "> ",
        "#'   adds marginal density panels for each variable (2D plots only;",
        "> ",
        "#'   \\code{plot.3d = FALSE}).",
        "> ",
        "#' @param plot.3d Logical. If \\code{TRUE}, returns an interactive \\code{plotly} 3D scatter",
        "> ",
        "#'   plot. If \\code{FALSE} (the default), returns a static \\code{ggpubr} grid of 2D panels.",
        "> ",
        "#' @param colors Optional named list of colors to override the default palette.",
        "> ",
        "#'   Valid names are: \\code{bg}, \\code{ellipsoid}, \\code{centroid}, \\code{tolerance},",
        "> ",
        "#'   \\code{suitable_env}, \\code{occ}.",
        "> ",
        "#' @param palette Character name of the internal palette to use.",
        "> ",
        "#'   One of \\code{\"default\"}, \\code{\"palette2\"}, ..., \\code{\"palette6\"}.",
        "> ",
        "#' @param vs Optional \\code{NicheR_species} object returned by",
        "> ",
        "#'   \\code{\\link{create_virtual_species}}. If provided, \\code{niche},",
        "> ",
        "#'   \\code{occ_pts}, \\code{env_bg}, and \\code{suitable_env} are auto-filled from",
        "> ",
        "#'   this object when they are not supplied explicitly.",
        "> ",
        "#'",
        "> ",
        "#' @return",
        "> ",
        "#' If \\code{plot.3d = TRUE}, a \\code{plotly} object.",
        "> ",
        "#' If \\code{plot.3d = FALSE}, a \\code{ggpubr} object containing arranged",
        "> ",
        "#' \\code{ggplot2} panels.",
        "> ",
        "#'",
        "> ",
        "#' @family plotting functions",
        "> ",
        "#' @seealso \\code{\\link{validate_plot_e_space_args}}, \\code{\\link{build_ellps}},",
        "> ",
        "#'   \\code{\\link{get_suitable_env}}, \\code{\\link{create_virtual_species}}",
        "> ",
        "#' @import RColorBrewer ggplot2 dplyr",
        "> ",
        "#' @importFrom rlang .data",
        "> ",
        "#' @export",
        "> ",
        "plot_e_space <- function(env_bg,",
        "+ ",
        "                         x, y, z,",
        "+ ",
        "                         labels = c(\"ENV 1\", \"ENV 2\", \"ENV 3\"),",
        "+ ",
        "                         n_bg = 10000,",
        "+ ",
        "                         niche = NULL,",
        "+ ",
        "                         suitable_env = NULL,",
        "+ ",
        "                         occ_pts = NULL,",
        "+ ",
        "                         rand_seed = 1234,",
        "+ ",
        "                         show.occ.density = FALSE, # only for 2D plots",
        "+ ",
        "                         plot.3d = FALSE,",
        "+ ",
        "                         colors = NULL,",
        "+ ",
        "                         palette = \"default\",",
        "+ ",
        "                         vs = NULL) {",
        "+ ",
        "+ ",
        "  # Track whether x,y,z were auto-inferred",
        "+ ",
        "  x_missing <- missing(x)",
        "+ ",
        "  y_missing <- missing(y)",
        "+ ",
        "  z_missing <- missing(z)",
        "+ ",
        "  auto_inferred <- x_missing || y_missing || z_missing",
        "+ ",
        "+ ",
        "  # --- 0. Optionally fill from NicheR_species object -------------------------",
        "+ ",
        "+ ",
        "  if (!is.null(vs)) {",
        "+ ",
        "    if (!inherits(vs, \"NicheR_species\")) {",
        "+ ",
        "      stop(\"'vs' must be a NicheR_species object created by create_virtual_species().\")",
        "+ ",
        "    }",
        "+ ",
        "+ ",
        "    # Fill niche if missing",
        "+ ",
        "    if (is.null(niche) && !is.null(vs$niche)) {",
        "+ ",
        "      niche <- vs$niche",
        "+ ",
        "    }",
        "+ ",
        "+ ",
        "    # Fill occurrences if missing",
        "+ ",
        "    if (is.null(occ_pts) && !is.null(vs$occurrences)) {",
        "+ ",
        "      occ_pts <- vs$occurrences",
        "+ ",
        "    }",
        "+ ",
        "+ ",
        "    # Fill env_bg if missing, using suitability slot",
        "+ ",
        "    if (missing(env_bg) || is.null(env_bg)) {",
        "+ ",
        "      if (inherits(vs$suitability, \"SpatRaster\")) {",
        "+ ",
        "        env_bg <- as.data.frame.nicheR(vs$suitability)",
        "+ ",
        "      } else if (is.data.frame(vs$suitability)) {",
        "+ ",
        "        env_bg <- vs$suitability",
        "+ ",
        "      }",
        "+ ",
        "    }",
        "+ ",
        "+ ",
        "    # Fill suitable_env if missing, using suitability slot directly",
        "+ ",
        "    if (is.null(suitable_env) && !is.null(vs$suitability)) {",
        "+ ",
        "      suitable_env <- vs$suitability",
        "+ ",
        "    }",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  if (missing(env_bg) || is.null(env_bg)) {",
        "+ ",
        "    stop(\"'env_bg' must be supplied, or inferable from 'vs$suitability'.\")",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  # --- 0.1 Coerce env_bg to data.frame --------------------------------------",
        "+ ",
        "+ ",
        "  if (inherits(env_bg, \"tbl_df\")) {",
        "+ ",
        "    env_bg <- as.data.frame(env_bg)",
        "+ ",
        "  }",
        "+ ",
        "  if (inherits(env_bg, \"Raster\")) {",
        "+ ",
        "    env_bg <- terra::rast(env_bg)",
        "+ ",
        "  }",
        "+ ",
        "  if (inherits(env_bg, \"SpatRaster\")) {",
        "+ ",
        "+ ",
        "    ncell <- terra::ncell(env_bg)",
        "+ ",
        "    nlyr  <- terra::nlyr(env_bg)",
        "+ ",
        "    est_mb <- (ncell * nlyr * 8) / 1024^2  # 8 bytes per numeric",
        "+ ",
        "+ ",
        "    size_threshold_mb <- 5000",
        "+ ",
        "+ ",
        "    if (est_mb > size_threshold_mb) {",
        "+ ",
        "      stop(",
        "+ ",
        "        \"The provided 'env_bg' raster stack is large (estimated ~\",",
        "+ ",
        "        round(est_mb, 1),",
        "+ ",
        "        \" MB if converted to a full data.frame).\\n\",",
        "+ ",
        "        \"For memory safety, please convert it to a data.frame yourself, e.g. using\\n\",",
        "+ ",
        "        \"  as.data.frame.nicheR(env_bg, use_cache = TRUE)\\n\",",
        "+ ",
        "        \"and then pass that data.frame as 'env_bg'.\"",
        "+ ",
        "      )",
        "+ ",
        "    }",
        "+ ",
        "+ ",
        "    env_bg <- as.data.frame.nicheR(env_bg)",
        "+ ",
        "+ ",
        "  }",
        "+ ",
        "  if (!is.data.frame(env_bg)) {",
        "+ ",
        "    stop(\"'env_bg' must be a data.frame or coercible to one.\")",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  # --- 0.2 Auto-infer x,y,z from env_bg if needed ---------------------------",
        "+ ",
        "+ ",
        "  if (auto_inferred) {",
        "+ ",
        "+ ",
        "    if (all(c(\"x\", \"y\") %in% names(env_bg))) {",
        "+ ",
        "      candidate_vars <- setdiff(names(env_bg), c(\"x\", \"y\"))",
        "+ ",
        "    } else {",
        "+ ",
        "      candidate_vars <- names(env_bg)",
        "+ ",
        "    }",
        "+ ",
        "+ ",
        "    if (length(candidate_vars) < 3) {",
        "+ ",
        "      stop(",
        "+ ",
        "        \"Could not infer x, y, z from 'env_bg' (fewer than 3 predictor columns after \",",
        "+ ",
        "        \"removing any 'x'/'y' coordinates). Please provide x, y, and z explicitly.\"",
        "+ ",
        "      )",
        "+ ",
        "    }",
        "+ ",
        "+ ",
        "    # Use first 3 predictor columns as x,y,z",
        "+ ",
        "    inferred <- candidate_vars[seq_len(3)]",
        "+ ",
        "    x <- inferred[1]",
        "+ ",
        "    y <- inferred[2]",
        "+ ",
        "    z <- inferred[3]",
        "+ ",
        "+ ",
        "    message(",
        "+ ",
        "      \"No complete x, y, z specification provided. Using predictor columns inferred from 'env_bg': \",",
        "+ ",
        "      paste(inferred, collapse = \", \")",
        "+ ",
        "    )",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  # --- 1. Validate core arguments and resolve predictor names ----------------",
        "+ ",
        "+ ",
        "  v <- validate_plot_e_space_args(",
        "+ ",
        "    env_bg, x, y, z,",
        "+ ",
        "    labels, n_bg,",
        "+ ",
        "    niche,",
        "+ ",
        "    occ_pts, show.occ.density",
        "+ ",
        "  )",
        "+ ",
        "+ ",
        "  col_x <- v$col_names[1]",
        "+ ",
        "  col_y <- v$col_names[2]",
        "+ ",
        "  col_z <- v$col_names[3]",
        "+ ",
        "+ ",
        "  # If user did provide x,y,z but as indices/variants, still nice to tell them",
        "+ ",
        "  if (auto_inferred) {",
        "+ ",
        "    message(",
        "+ ",
        "      \"Using predictor columns: \",",
        "+ ",
        "      paste(v$col_names, collapse = \", \")",
        "+ ",
        "    )",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  # Coerce occ_pts to data.frame (structure already checked in validator)",
        "+ ",
        "  if (!is.null(occ_pts)) {",
        "+ ",
        "    occ_pts <- as.data.frame(occ_pts)",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  # --- 2. Coerce suitable_env to a data.frame of inside points (if given) ----",
        "+ ",
        "+ ",
        "  pts_in <- NULL",
        "+ ",
        "  if (!is.null(suitable_env)) {",
        "+ ",
        "+ ",
        "    if (inherits(suitable_env, \"suitable_env\") ||",
        "+ ",
        "        (is.list(suitable_env) &&",
        "+ ",
        "         any(c(\"suitable_env_df\", \"suitable_env_sp\") %in% names(suitable_env)))) {",
        "+ ",
        "+ ",
        "      if (\"suitable_env_df\" %in% names(suitable_env) &&",
        "+ ",
        "          is.data.frame(suitable_env$suitable_env_df)) {",
        "+ ",
        "+ ",
        "        pts_in <- suitable_env$suitable_env_df",
        "+ ",
        "+ ",
        "      } else if (\"suitable_env_sp\" %in% names(suitable_env)) {",
        "+ ",
        "+ ",
        "        sp <- suitable_env$suitable_env_sp",
        "+ ",
        "        if (inherits(sp, \"Raster\")) sp <- terra::rast(sp)",
        "+ ",
        "+ ",
        "        if (inherits(sp, \"SpatRaster\")) {",
        "+ ",
        "          pts_in <- as.data.frame.nicheR(sp)",
        "+ ",
        "        } else if (is.list(sp) &&",
        "+ ",
        "                   length(sp) > 0 &&",
        "+ ",
        "                   all(vapply(sp, inherits, logical(1), \"SpatRaster\"))) {",
        "+ ",
        "+ ",
        "          if (\"suitable\" %in% names(sp)) {",
        "+ ",
        "            pts_in <- as.data.frame.nicheR(sp[[\"suitable\"]])",
        "+ ",
        "          } else {",
        "+ ",
        "            pts_in <- as.data.frame.nicheR(sp[[1]])",
        "+ ",
        "          }",
        "+ ",
        "        }",
        "+ ",
        "      }",
        "+ ",
        "+ ",
        "    } else if (inherits(suitable_env, \"Raster\") || inherits(suitable_env, \"SpatRaster\")) {",
        "+ ",
        "+ ",
        "      if (inherits(suitable_env, \"Raster\")) {",
        "+ ",
        "        suitable_env <- terra::rast(suitable_env)",
        "+ ",
        "      }",
        "+ ",
        "      pts_in <- as.data.frame.nicheR(suitable_env)",
        "+ ",
        "+ ",
        "    } else if (is.data.frame(suitable_env) || is.matrix(suitable_env)) {",
        "+ ",
        "+ ",
        "      pts_in <- as.data.frame(suitable_env)",
        "+ ",
        "    }",
        "+ ",
        "+ ",
        "    if (!is.null(pts_in)) {",
        "+ ",
        "      if (!all(c(col_x, col_y, col_z) %in% names(pts_in))) {",
        "+ ",
        "        warning(",
        "+ ",
        "          \"suitable_env does not contain all of x, y, z predictor columns; \",",
        "+ ",
        "          \"suitable points will not be plotted in E-space.\"",
        "+ ",
        "        )",
        "+ ",
        "        pts_in <- NULL",
        "+ ",
        "      }",
        "+ ",
        "+ ",
        "      if (nrow(pts_in) > n_bg) {",
        "+ ",
        "        message(sprintf(\"Sampling %d of %d rows from 'suitable_env' for plotting.\", n_bg, nrow(pts_in)))",
        "+ ",
        "        set.seed(rand_seed)",
        "+ ",
        "        pts_in <- pts_in[sample.int(nrow(pts_in), size = n_bg, replace = FALSE), ]",
        "+ ",
        "      }",
        "+ ",
        "+ ",
        "    }",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  # --- 3. Colors / palette ---------------------------------------------------",
        "+ ",
        "+ ",
        "  palettes <- list(",
        "+ ",
        "    default = list(",
        "+ ",
        "      bg           = \"#9093A2FF\",",
        "+ ",
        "      ellipsoid    = \"#2A363BFF\",",
        "+ ",
        "      centroid     = \"#D72000FF\",",
        "+ ",
        "      tolerance    = \"#EE6100FF\",",
        "+ ",
        "      suitable_env = \"#FED789FF\",",
        "+ ",
        "      occ          = \"#B4BF3AFF\"",
        "+ ",
        "    ),",
        "+ ",
        "    palette2 = list(",
        "+ ",
        "      bg           = \"#9CA9BAFF\",",
        "+ ",
        "      ellipsoid    = \"#3D619DFF\",",
        "+ ",
        "      centroid     = \"#345084FF\",",
        "+ ",
        "      tolerance    = \"#693829FF\",",
        "+ ",
        "      suitable_env = \"#CFB267FF\",",
        "+ ",
        "      occ          = \"#A56A3EFF\"",
        "+ ",
        "    ),",
        "+ ",
        "    palette3 = list(",
        "+ ",
        "      bg           = \"#C8CCC6FF\",",
        "+ ",
        "      ellipsoid    = \"#023743FF\",",
        "+ ",
        "      centroid     = \"#72874EFF\",",
        "+ ",
        "      tolerance    = \"#476F84FF\",",
        "+ ",
        "      suitable_env = \"#FED789FF\",",
        "+ ",
        "      occ          = \"#A4BED5FF\"",
        "+ ",
        "    ),",
        "+ ",
        "    palette4 = list(",
        "+ ",
        "      bg           = \"#C0D1CEFF\",",
        "+ ",
        "      ellipsoid    = \"#859B6CFF\",",
        "+ ",
        "      centroid     = \"#B74954FF\",",
        "+ ",
        "      tolerance    = \"#A99364FF\",",
        "+ ",
        "      suitable_env = \"#C2DDB2FF\",",
        "+ ",
        "      occ          = \"#EBA49EFF\"",
        "+ ",
        "    ),",
        "+ ",
        "    palette5 = list(",
        "+ ",
        "      bg           = \"#A89F8EFF\",",
        "+ ",
        "      ellipsoid    = \"#7887A4FF\",",
        "+ ",
        "      centroid     = \"#A8CDECFF\",",
        "+ ",
        "      tolerance    = \"#682C37FF\",",
        "+ ",
        "      suitable_env = \"#F6955EFF\",",
        "+ ",
        "      occ          = \"#9B6981FF\"",
        "+ ",
        "    ),",
        "+ ",
        "    palette6 = list(",
        "+ ",
        "      bg           = \"#D3D4D8FF\",",
        "+ ",
        "      ellipsoid    = \"#731A12FF\",",
        "+ ",
        "      centroid     = \"#F2D43DFF\",",
        "+ ",
        "      tolerance    = \"#3F858CFF\",",
        "+ ",
        "      suitable_env = \"#D9814EFF\",",
        "+ ",
        "      occ          = \"#707322FF\"",
        "+ ",
        "    )",
        "+ ",
        "  )",
        "+ ",
        "+ ",
        "  if (!palette %in% names(palettes)) {",
        "+ ",
        "    stop(\"Unknown palette '\", palette, \"'.\")",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  base_colors <- palettes[[palette]]",
        "+ ",
        "+ ",
        "  if (is.null(colors)) {",
        "+ ",
        "    colors <- base_colors",
        "+ ",
        "  } else {",
        "+ ",
        "    if (is.null(names(colors))) {",
        "+ ",
        "      names(colors) <- names(base_colors)[seq_along(colors)]",
        "+ ",
        "      if (!is.list(colors)) colors <- as.list(colors)",
        "+ ",
        "      message(",
        "+ ",
        "        \"No names detected in 'colors'. \",",
        "+ ",
        "        \"Using the order provided and filling missing entries with defaults.\\n\",",
        "+ ",
        "        \"If you want to change a specific object, use a named list.\\n\",",
        "+ ",
        "        \"Available options are: \",",
        "+ ",
        "        paste(names(base_colors), collapse = \", \")",
        "+ ",
        "      )",
        "+ ",
        "    }",
        "+ ",
        "    if (!is.list(colors)) colors <- as.list(colors)",
        "+ ",
        "    colors <- utils::modifyList(base_colors, colors)",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  # Legend options ------------------------------------------------------------",
        "+ ",
        "+ ",
        "  opts <- list(",
        "+ ",
        "    background_point     = TRUE,",
        "+ ",
        "    trace_line           = !is.null(niche),",
        "+ ",
        "    centroid_point       = !is.null(niche),",
        "+ ",
        "    tolerance_range_line = !is.null(niche),",
        "+ ",
        "    suitable_point       = !is.null(pts_in),",
        "+ ",
        "    occurrence_point     = !is.null(occ_pts)",
        "+ ",
        "  )",
        "+ ",
        "+ ",
        "  legend_items <- data.frame(",
        "+ ",
        "    id       = c(\"background_point\",\"trace_line\",\"centroid_point\",",
        "+ ",
        "                 \"tolerance_range_line\",\"suitable_point\",\"occurrence_point\"),",
        "+ ",
        "    type     = c(\"point\",\"line\",\"point\",\"line\",\"point\",\"point\"),",
        "+ ",
        "    label    = c(\"Background environments\",\"Niche boundary\",\"Niche centroid\",",
        "+ ",
        "                 \"Tolerance ranges\",\"Suitable environments\",\"Occurrences\"),",
        "+ ",
        "    color    = c(colors[[\"bg\"]], colors[[\"ellipsoid\"]], colors[[\"centroid\"]],",
        "+ ",
        "                 colors[[\"tolerance\"]], colors[[\"suitable_env\"]], colors[[\"occ\"]]),",
        "+ ",
        "    linetype = c(NA, 1, NA, 2, NA, NA),",
        "+ ",
        "    stringsAsFactors = FALSE",
        "+ ",
        "  )",
        "+ ",
        "+ ",
        "  active <- logical(nrow(legend_items))",
        "+ ",
        "  for (i in seq_len(nrow(legend_items))) {",
        "+ ",
        "    active[i] <- isTRUE(opts[[ legend_items$id[i] ]])",
        "+ ",
        "  }",
        "+ ",
        "  legend_items <- legend_items[active, , drop = FALSE]",
        "+ ",
        "+ ",
        "  # Build legend plot ---------------------------------------------------------",
        "+ ",
        "+ ",
        "  if (nrow(legend_items) == 0) {",
        "+ ",
        "    legend_plot <- ggplot2::ggplot() + ggplot2::theme_void()",
        "+ ",
        "  } else {",
        "+ ",
        "    top_y   <- 2",
        "+ ",
        "    spacing <- 0.25",
        "+ ",
        "    x_point <- 0.00",
        "+ ",
        "    x_text  <- 0.1",
        "+ ",
        "    x0_line <- -0.2",
        "+ ",
        "    x1_line <-  0.00",
        "+ ",
        "+ ",
        "    legend_items <- legend_items %>%",
        "+ ",
        "      dplyr::mutate(",
        "+ ",
        "        row     = dplyr::row_number(),",
        "+ ",
        "        y       = top_y - (row - 1) * spacing,",
        "+ ",
        "        x_point = x_point,",
        "+ ",
        "        x_text  = x_text,",
        "+ ",
        "        x0_line = x0_line,",
        "+ ",
        "        x1_line = x1_line",
        "+ ",
        "      )",
        "+ ",
        "+ ",
        "    legend_base <- ggplot2::ggplot() +",
        "+ ",
        "      ggplot2::coord_cartesian(xlim = c(-0.5, 0.5), ylim = c(0, 2.5), clip = \"off\") +",
        "+ ",
        "      ggplot2::theme_void() +",
        "+ ",
        "      ggplot2::theme(legend.position = \"none\")",
        "+ ",
        "+ ",
        "    legend_plot <- legend_base +",
        "+ ",
        "      ggplot2::geom_point(",
        "+ ",
        "        data  = dplyr::filter(legend_items, type == \"point\"),",
        "+ ",
        "        ggplot2::aes(x = x_point, y = y, colour = color),",
        "+ ",
        "        size = 2",
        "+ ",
        "      ) +",
        "+ ",
        "      ggplot2::geom_segment(",
        "+ ",
        "        data  = dplyr::filter(legend_items, type == \"line\"),",
        "+ ",
        "        ggplot2::aes(x = x0_line, xend = x1_line, y = y, yend = y,",
        "+ ",
        "                     colour = color, linetype = linetype),",
        "+ ",
        "        linewidth = 0.5",
        "+ ",
        "      ) +",
        "+ ",
        "      ggplot2::geom_text(",
        "+ ",
        "        data  = legend_items,",
        "+ ",
        "        ggplot2::aes(x = x_text, y = y, label = label),",
        "+ ",
        "        hjust = 0",
        "+ ",
        "      ) +",
        "+ ",
        "      ggplot2::scale_colour_identity() +",
        "+ ",
        "      ggplot2::scale_linetype_identity()",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  # Downsample background -----------------------------------------------------",
        "+ ",
        "+ ",
        "  if (nrow(env_bg) > n_bg) {",
        "+ ",
        "    message(sprintf(\"Sampling %d of %d rows from 'env_bg' for plotting.\", n_bg, nrow(env_bg)))",
        "+ ",
        "    set.seed(rand_seed)",
        "+ ",
        "    env_bg <- env_bg[sample.int(nrow(env_bg), size = n_bg, replace = FALSE), ]",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  # ---------------------------------------------------------------------------",
        "+ ",
        "  # 3D plotting branch",
        "+ ",
        "  # ---------------------------------------------------------------------------",
        "+ ",
        "+ ",
        "  if (isTRUE(plot.3d)) {",
        "+ ",
        "+ ",
        "    p3 <- plotly::plot_ly(",
        "+ ",
        "      data = env_bg,",
        "+ ",
        "      x    = env_bg[[col_x]],",
        "+ ",
        "      y    = env_bg[[col_y]],",
        "+ ",
        "      z    = env_bg[[col_z]],",
        "+ ",
        "      type = \"scatter3d\",",
        "+ ",
        "      mode = \"markers\",",
        "+ ",
        "      marker = list(color = colors[[\"bg\"]], size = 2),",
        "+ ",
        "      name   = \"Background Environments\"",
        "+ ",
        "    ) %>%",
        "+ ",
        "      plotly::layout(",
        "+ ",
        "        title = list(text = \"Background Environments (E-space)\"),",
        "+ ",
        "        scene = list(",
        "+ ",
        "          xaxis = list(title = list(text = labels[1])),",
        "+ ",
        "          yaxis = list(title = list(text = labels[2])),",
        "+ ",
        "          zaxis = list(title = list(text = labels[3]))",
        "+ ",
        "        ),",
        "+ ",
        "        legend = list(x = 0.05, y = 0.95)",
        "+ ",
        "      )",
        "+ ",
        "+ ",
        "    # Ellipsoid surface + centroid (if present)",
        "+ ",
        "    if (!is.null(niche) && !is.null(niche$surface)) {",
        "+ ",
        "+ ",
        "      surf <- as.data.frame(niche$surface)",
        "+ ",
        "      if (ncol(surf) >= 3) {",
        "+ ",
        "        p3 <- p3 %>%",
        "+ ",
        "          plotly::add_trace(",
        "+ ",
        "            data = surf,",
        "+ ",
        "            x    = surf[[1]],",
        "+ ",
        "            y    = surf[[2]],",
        "+ ",
        "            z    = surf[[3]],",
        "+ ",
        "            type = \"scatter3d\",",
        "+ ",
        "            mode = \"lines\",",
        "+ ",
        "            line = list(color = colors[[\"ellipsoid\"]]),",
        "+ ",
        "            name = \"Niche Boundary\",",
        "+ ",
        "            inherit = FALSE",
        "+ ",
        "          )",
        "+ ",
        "      }",
        "+ ",
        "+ ",
        "      if (!is.null(niche$center) && length(niche$center) >= 3) {",
        "+ ",
        "        p3 <- p3 %>%",
        "+ ",
        "          plotly::add_markers(",
        "+ ",
        "            x = niche$center[1],",
        "+ ",
        "            y = niche$center[2],",
        "+ ",
        "            z = niche$center[3],",
        "+ ",
        "            marker = list(color = colors[[\"centroid\"]], size = 5),",
        "+ ",
        "            name   = \"Niche Centroid\"",
        "+ ",
        "          )",
        "+ ",
        "      }",
        "+ ",
        "+ ",
        "      if (!is.null(pts_in)) {",
        "+ ",
        "        p3 <- p3 %>%",
        "+ ",
        "          plotly::add_markers(",
        "+ ",
        "            data = pts_in,",
        "+ ",
        "            x    = pts_in[[col_x]],",
        "+ ",
        "            y    = pts_in[[col_y]],",
        "+ ",
        "            z    = pts_in[[col_z]],",
        "+ ",
        "            marker = list(color = colors[[\"suitable_env\"]], size = 3),",
        "+ ",
        "            name   = \"Suitable Environments\",",
        "+ ",
        "            inherit = FALSE",
        "+ ",
        "          )",
        "+ ",
        "      }",
        "+ ",
        "    }",
        "+ ",
        "+ ",
        "    # Occurrence points in 3D",
        "+ ",
        "    if (!is.null(occ_pts)) {",
        "+ ",
        "      p3 <- p3 %>%",
        "+ ",
        "        plotly::add_markers(",
        "+ ",
        "          data = occ_pts,",
        "+ ",
        "          x    = occ_pts[[col_x]],",
        "+ ",
        "          y    = occ_pts[[col_y]],",
        "+ ",
        "          z    = occ_pts[[col_z]],",
        "+ ",
        "          marker = list(color = colors[[\"occ\"]], size = 3),",
        "+ ",
        "          name   = \"Sampled Occurrences\",",
        "+ ",
        "          inherit = FALSE",
        "+ ",
        "        ) %>%",
        "+ ",
        "        plotly::layout(",
        "+ ",
        "          title  = \"Virtual Niche and Sampled Occurrences in E-space\",",
        "+ ",
        "          legend = list(x = 0.05, y = 0.95)",
        "+ ",
        "        )",
        "+ ",
        "    }",
        "+ ",
        "+ ",
        "    return(p3)",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  # ---------------------------------------------------------------------------",
        "+ ",
        "  # 2D plotting branch",
        "+ ",
        "  # ---------------------------------------------------------------------------",
        "+ ",
        "+ ",
        "  p_main_y_x <- ggplot2::ggplot(",
        "+ ",
        "    env_bg,",
        "+ ",
        "    ggplot2::aes(x = .data[[col_y]], y = .data[[col_x]])",
        "+ ",
        "  ) +",
        "+ ",
        "    ggplot2::geom_point(alpha = 0.5, color = colors[[\"bg\"]], pch = \".\") +",
        "+ ",
        "    ggplot2::theme_bw() +",
        "+ ",
        "    ggplot2::theme(axis.title = ggplot2::element_blank())",
        "+ ",
        "+ ",
        "  p_main_z_x <- ggplot2::ggplot(",
        "+ ",
        "    env_bg,",
        "+ ",
        "    ggplot2::aes(x = .data[[col_z]], y = .data[[col_x]])",
        "+ ",
        "  ) +",
        "+ ",
        "    ggplot2::geom_point(alpha = 0.5, color = colors[[\"bg\"]], pch = \".\") +",
        "+ ",
        "    ggplot2::theme_bw() +",
        "+ ",
        "    ggplot2::theme(axis.title = ggplot2::element_blank())",
        "+ ",
        "+ ",
        "  p_main_z_y <- ggplot2::ggplot(",
        "+ ",
        "    env_bg,",
        "+ ",
        "    ggplot2::aes(x = .data[[col_z]], y = .data[[col_y]])",
        "+ ",
        "  ) +",
        "+ ",
        "    ggplot2::geom_point(alpha = 0.5, color = colors[[\"bg\"]], pch = \".\") +",
        "+ ",
        "    ggplot2::theme_bw() +",
        "+ ",
        "    ggplot2::theme(axis.title = ggplot2::element_blank())",
        "+ ",
        "+ ",
        "  x_name <- ggplot2::ggplot() + ggplot2::theme_void() +",
        "+ ",
        "    ggplot2::geom_text(ggplot2::aes(0, 0, label = labels[1]),",
        "+ ",
        "                       fontface = \"bold\")",
        "+ ",
        "  y_name <- ggplot2::ggplot() + ggplot2::theme_void() +",
        "+ ",
        "    ggplot2::geom_text(ggplot2::aes(0, 0, label = labels[2]),",
        "+ ",
        "                       fontface = \"bold\")",
        "+ ",
        "  z_name <- ggplot2::ggplot() + ggplot2::theme_void() +",
        "+ ",
        "    ggplot2::geom_text(ggplot2::aes(0, 0, label = labels[3]),",
        "+ ",
        "                       fontface = \"bold\")",
        "+ ",
        "+ ",
        "  return_plot <- ggpubr::ggarrange(",
        "+ ",
        "    x_name,      p_main_y_x, p_main_z_x,",
        "+ ",
        "    legend_plot, y_name,     p_main_z_y,",
        "+ ",
        "    NULL,        NULL,       z_name,",
        "+ ",
        "    ncol = 3, nrow = 3,",
        "+ ",
        "    widths  = c(0.15, 0.425, 0.425),",
        "+ ",
        "    heights = c(0.45, 0.45, 0.15)",
        "+ ",
        "  )",
        "+ ",
        "+ ",
        "  # --- Ellipsoid overlays and extras (2D) ------------------------------------",
        "+ ",
        "+ ",
        "  if (!is.null(niche)) {",
        "+ ",
        "+ ",
        "    center_y_x <- c(niche$center[2], niche$center[1])",
        "+ ",
        "    axes_y_x   <- c(niche$axes[2],   niche$axes[1])",
        "+ ",
        "    angle_y_x  <- c(niche$angles[2], niche$angles[1])",
        "+ ",
        "+ ",
        "    center_z_x <- c(niche$center[3], niche$center[1])",
        "+ ",
        "    axes_z_x   <- c(niche$axes[3],   niche$axes[1])",
        "+ ",
        "    angle_z_x  <- c(niche$angles[3], niche$angles[1])",
        "+ ",
        "+ ",
        "    center_z_y <- c(niche$center[3], niche$center[2])",
        "+ ",
        "    axes_z_y   <- c(niche$axes[3],   niche$axes[2])",
        "+ ",
        "    angle_z_y  <- c(niche$angles[3], niche$angles[2])",
        "+ ",
        "+ ",
        "    ell2d_y_x <- build_ellps(center = center_y_x, axes = axes_y_x, angles = angle_y_x)",
        "+ ",
        "    ell2d_z_x <- build_ellps(center = center_z_x, axes = axes_z_x, angles = angle_z_x)",
        "+ ",
        "    ell2d_z_y <- build_ellps(center = center_z_y, axes = axes_z_y, angles = angle_z_y)",
        "+ ",
        "+ ",
        "    ell_y_x <- p_main_y_x",
        "+ ",
        "    ell_z_x <- p_main_z_x",
        "+ ",
        "    ell_z_y <- p_main_z_y",
        "+ ",
        "+ ",
        "    if (any(niche$angles != 0)) {",
        "+ ",
        "      angle_warn <- ggplot2::ggplot() + ggplot2::theme_void() +",
        "+ ",
        "        ggplot2::geom_text(",
        "+ ",
        "          ggplot2::aes(0, 0,",
        "+ ",
        "                       label = \"Note: The ellipsoid is angled; its shape may appear distorted and some points may fall outside due to dimensionality.\"),",
        "+ ",
        "          size = 2",
        "+ ",
        "        )",
        "+ ",
        "    } else {",
        "+ ",
        "      angle_warn <- NULL",
        "+ ",
        "    }",
        "+ ",
        "+ ",
        "    # Suitable points (inside)",
        "+ ",
        "    if (!is.null(pts_in)) {",
        "+ ",
        "+ ",
        "      ell_y_x <- ell_y_x +",
        "+ ",
        "        ggplot2::geom_point(",
        "+ ",
        "          data = pts_in,",
        "+ ",
        "          ggplot2::aes(",
        "+ ",
        "            x = .data[[col_y]],",
        "+ ",
        "            y = .data[[col_x]]",
        "+ ",
        "          ),",
        "+ ",
        "          color = colors[[\"suitable_env\"]],",
        "+ ",
        "          pch = \".\"",
        "+ ",
        "        )",
        "+ ",
        "+ ",
        "      ell_z_x <- ell_z_x +",
        "+ ",
        "        ggplot2::geom_point(",
        "+ ",
        "          data = pts_in,",
        "+ ",
        "          ggplot2::aes(",
        "+ ",
        "            x = .data[[col_z]],",
        "+ ",
        "            y = .data[[col_x]]",
        "+ ",
        "          ),",
        "+ ",
        "          color = colors[[\"suitable_env\"]],",
        "+ ",
        "          size  = 0.5",
        "+ ",
        "        )",
        "+ ",
        "+ ",
        "      ell_z_y <- ell_z_y +",
        "+ ",
        "        ggplot2::geom_point(",
        "+ ",
        "          data = pts_in,",
        "+ ",
        "          ggplot2::aes(",
        "+ ",
        "            x = .data[[col_z]],",
        "+ ",
        "            y = .data[[col_y]]",
        "+ ",
        "          ),",
        "+ ",
        "          color = colors[[\"suitable_env\"]],",
        "+ ",
        "          size  = 0.5",
        "+ ",
        "        )",
        "+ ",
        "    }",
        "+ ",
        "+ ",
        "    # Occurrence points in 2D",
        "+ ",
        "    if (!is.null(occ_pts)) {",
        "+ ",
        "      ell_y_x <- ell_y_x +",
        "+ ",
        "        ggplot2::geom_point(",
        "+ ",
        "          data = occ_pts,",
        "+ ",
        "          ggplot2::aes(",
        "+ ",
        "            x = .data[[col_y]],",
        "+ ",
        "            y = .data[[col_x]]",
        "+ ",
        "          ),",
        "+ ",
        "          color = colors[[\"occ\"]],",
        "+ ",
        "          size  = 0.5",
        "+ ",
        "        )",
        "+ ",
        "+ ",
        "      ell_z_x <- ell_z_x +",
        "+ ",
        "        ggplot2::geom_point(",
        "+ ",
        "          data = occ_pts,",
        "+ ",
        "          ggplot2::aes(",
        "+ ",
        "            x = .data[[col_z]],",
        "+ ",
        "            y = .data[[col_x]]",
        "+ ",
        "          ),",
        "+ ",
        "          color = colors[[\"occ\"]],",
        "+ ",
        "          size  = 0.5",
        "+ ",
        "        )",
        "+ ",
        "+ ",
        "      ell_z_y <- ell_z_y +",
        "+ ",
        "        ggplot2::geom_point(",
        "+ ",
        "          data = occ_pts,",
        "+ ",
        "          ggplot2::aes(",
        "+ ",
        "            x = .data[[col_z]],",
        "+ ",
        "            y = .data[[col_y]]",
        "+ ",
        "          ),",
        "+ ",
        "          color = colors[[\"occ\"]],",
        "+ ",
        "          size  = 0.5",
        "+ ",
        "        )",
        "+ ",
        "    }",
        "+ ",
        "+ ",
        "    # Ellipse boundaries + axes + centroid -----------------------------------",
        "+ ",
        "+ ",
        "    ell_y_x <- ell_y_x +",
        "+ ",
        "      ggplot2::geom_path(",
        "+ ",
        "        data   = ell2d_y_x$surface,",
        "+ ",
        "        ggplot2::aes(x, y),",
        "+ ",
        "        color = colors[[\"ellipsoid\"]],",
        "+ ",
        "        linewidth = 0.5",
        "+ ",
        "      ) +",
        "+ ",
        "      ggplot2::annotate(",
        "+ ",
        "        \"segment\",",
        "+ ",
        "        x    = ell2d_y_x$center[1] - ell2d_y_x$axes[1],",
        "+ ",
        "        xend = ell2d_y_x$center[1] + ell2d_y_x$axes[1],",
        "+ ",
        "        y    = ell2d_y_x$center[2],",
        "+ ",
        "        yend = ell2d_y_x$center[2],",
        "+ ",
        "        color = colors[[\"tolerance\"]],",
        "+ ",
        "        linetype = \"dashed\"",
        "+ ",
        "      ) +",
        "+ ",
        "      ggplot2::annotate(",
        "+ ",
        "        \"segment\",",
        "+ ",
        "        y    = ell2d_y_x$center[2] - ell2d_y_x$axes[2],",
        "+ ",
        "        yend = ell2d_y_x$center[2] + ell2d_y_x$axes[2],",
        "+ ",
        "        x    = ell2d_y_x$center[1],",
        "+ ",
        "        xend = ell2d_y_x$center[1],",
        "+ ",
        "        color = colors[[\"tolerance\"]],",
        "+ ",
        "        linetype = \"dashed\"",
        "+ ",
        "      ) +",
        "+ ",
        "      ggplot2::annotate(",
        "+ ",
        "        \"point\",",
        "+ ",
        "        x = ell2d_y_x$center[1],",
        "+ ",
        "        y = ell2d_y_x$center[2],",
        "+ ",
        "        color = colors[[\"centroid\"]],",
        "+ ",
        "        size  = 2",
        "+ ",
        "      )",
        "+ ",
        "+ ",
        "    ell_z_x <- ell_z_x +",
        "+ ",
        "      ggplot2::geom_path(",
        "+ ",
        "        data   = ell2d_z_x$surface,",
        "+ ",
        "        ggplot2::aes(x, y),",
        "+ ",
        "        color = colors[[\"ellipsoid\"]],",
        "+ ",
        "        linewidth = 0.5",
        "+ ",
        "      ) +",
        "+ ",
        "      ggplot2::annotate(",
        "+ ",
        "        \"segment\",",
        "+ ",
        "        x    = ell2d_z_x$center[1] - ell2d_z_x$axes[1],",
        "+ ",
        "        xend = ell2d_z_x$center[1] + ell2d_z_x$axes[1],",
        "+ ",
        "        y    = ell2d_z_x$center[2],",
        "+ ",
        "        yend = ell2d_z_x$center[2],",
        "+ ",
        "        color = colors[[\"tolerance\"]],",
        "+ ",
        "        linetype = \"dashed\"",
        "+ ",
        "      ) +",
        "+ ",
        "      ggplot2::annotate(",
        "+ ",
        "        \"segment\",",
        "+ ",
        "        y    = ell2d_z_x$center[2] - ell2d_z_x$axes[2],",
        "+ ",
        "        yend = ell2d_z_x$center[2] + ell2d_z_x$axes[2],",
        "+ ",
        "        x    = ell2d_z_x$center[1],",
        "+ ",
        "        xend = ell2d_z_x$center[1],",
        "+ ",
        "        color = colors[[\"tolerance\"]],",
        "+ ",
        "        linetype = \"dashed\"",
        "+ ",
        "      ) +",
        "+ ",
        "      ggplot2::annotate(",
        "+ ",
        "        \"point\",",
        "+ ",
        "        x = ell2d_z_x$center[1],",
        "+ ",
        "        y = ell2d_z_x$center[2],",
        "+ ",
        "        color = colors[[\"centroid\"]],",
        "+ ",
        "        size  = 2",
        "+ ",
        "      )",
        "+ ",
        "+ ",
        "    ell_z_y <- ell_z_y +",
        "+ ",
        "      ggplot2::geom_path(",
        "+ ",
        "        data   = ell2d_z_y$surface,",
        "+ ",
        "        ggplot2::aes(x, y),",
        "+ ",
        "        color = colors[[\"ellipsoid\"]],",
        "+ ",
        "        linewidth = 0.5",
        "+ ",
        "      ) +",
        "+ ",
        "      ggplot2::annotate(",
        "+ ",
        "        \"segment\",",
        "+ ",
        "        x    = ell2d_z_y$center[1] - ell2d_z_y$axes[1],",
        "+ ",
        "        xend = ell2d_z_y$center[1] + ell2d_z_y$axes[1],",
        "+ ",
        "        y    = ell2d_z_y$center[2],",
        "+ ",
        "        yend = ell2d_z_y$center[2],",
        "+ ",
        "        color = colors[[\"tolerance\"]],",
        "+ ",
        "        linetype = \"dashed\"",
        "+ ",
        "      ) +",
        "+ ",
        "      ggplot2::annotate(",
        "+ ",
        "        \"segment\",",
        "+ ",
        "        y    = ell2d_z_y$center[2] - ell2d_z_y$axes[2],",
        "+ ",
        "        yend = ell2d_z_y$center[2] + ell2d_z_y$axes[2],",
        "+ ",
        "        x    = ell2d_z_y$center[1],",
        "+ ",
        "        xend = ell2d_z_y$center[1],",
        "+ ",
        "        color = colors[[\"tolerance\"]],",
        "+ ",
        "        linetype = \"dashed\"",
        "+ ",
        "      ) +",
        "+ ",
        "      ggplot2::annotate(",
        "+ ",
        "        \"point\",",
        "+ ",
        "        x = ell2d_z_y$center[1],",
        "+ ",
        "        y = ell2d_z_y$center[2],",
        "+ ",
        "        color = colors[[\"centroid\"]],",
        "+ ",
        "        size  = 2",
        "+ ",
        "      )",
        "+ ",
        "+ ",
        "    # Re-assemble main grid with ellipsoid overlays --------------------------",
        "+ ",
        "+ ",
        "    return_plot <- ggpubr::ggarrange(",
        "+ ",
        "      x_name,      ell_y_x,   ell_z_x,",
        "+ ",
        "      legend_plot, y_name,    ell_z_y,",
        "+ ",
        "      NULL,        angle_warn, z_name,",
        "+ ",
        "      ncol = 3, nrow = 3,",
        "+ ",
        "      widths  = c(0.15, 0.425, 0.425),",
        "+ ",
        "      heights = c(0.45, 0.45, 0.15)",
        "+ ",
        "    )",
        "+ ",
        "+ ",
        "    # Optional occurrence density panels -------------------------------------",
        "+ ",
        "+ ",
        "    if (isTRUE(show.occ.density) && !is.null(occ_pts)) {",
        "+ ",
        "+ ",
        "      rng_z <- range(env_bg[[col_z]], na.rm = TRUE)",
        "+ ",
        "      rng_y <- range(env_bg[[col_y]], na.rm = TRUE)",
        "+ ",
        "      rng_x <- range(env_bg[[col_x]], na.rm = TRUE)",
        "+ ",
        "+ ",
        "      env_z_top <- ggplot2::ggplot(occ_pts, ggplot2::aes(x = .data[[col_z]])) +",
        "+ ",
        "        ggplot2::geom_density(fill = colors[[\"occ\"]], alpha = 0.6) +",
        "+ ",
        "        ggplot2::scale_x_continuous(limits = rng_z) +",
        "+ ",
        "        ggplot2::scale_y_continuous(n.breaks = 3) +",
        "+ ",
        "        ggplot2::theme_minimal() +",
        "+ ",
        "        ggplot2::theme(",
        "+ ",
        "          axis.text.x  = ggplot2::element_blank(),",
        "+ ",
        "          axis.title.x = ggplot2::element_blank(),",
        "+ ",
        "          axis.title.y = ggplot2::element_blank(),",
        "+ ",
        "          axis.text.y  = ggplot2::element_text(size = 5)",
        "+ ",
        "        )",
        "+ ",
        "+ ",
        "      env_y_top <- ggplot2::ggplot(occ_pts, ggplot2::aes(x = .data[[col_y]])) +",
        "+ ",
        "        ggplot2::geom_density(fill = colors[[\"occ\"]], alpha = 0.6) +",
        "+ ",
        "        ggplot2::scale_x_continuous(limits = rng_y) +",
        "+ ",
        "        ggplot2::scale_y_continuous(n.breaks = 3) +",
        "+ ",
        "        ggplot2::theme_minimal() +",
        "+ ",
        "        ggplot2::theme(",
        "+ ",
        "          axis.text.x  = ggplot2::element_blank(),",
        "+ ",
        "          axis.title.x = ggplot2::element_blank(),",
        "+ ",
        "          axis.title.y = ggplot2::element_blank(),",
        "+ ",
        "          axis.text.y  = ggplot2::element_text(size = 5)",
        "+ ",
        "        )",
        "+ ",
        "+ ",
        "      env_x_right <- ggplot2::ggplot(occ_pts, ggplot2::aes(x = .data[[col_x]])) +",
        "+ ",
        "        ggplot2::geom_density(fill = colors[[\"occ\"]], alpha = 0.6) +",
        "+ ",
        "        ggplot2::scale_x_continuous(limits = rng_x) +",
        "+ ",
        "        ggplot2::coord_flip() +",
        "+ ",
        "        ggplot2::scale_y_continuous(n.breaks = 3) +",
        "+ ",
        "        ggplot2::theme_minimal() +",
        "+ ",
        "        ggplot2::theme(",
        "+ ",
        "          axis.text.y  = ggplot2::element_blank(),",
        "+ ",
        "          axis.title.y = ggplot2::element_blank(),",
        "+ ",
        "          axis.title.x = ggplot2::element_blank(),",
        "+ ",
        "          axis.text.x  = ggplot2::element_text(size = 5)",
        "+ ",
        "        )",
        "+ ",
        "+ ",
        "      env_y_right <- ggplot2::ggplot(occ_pts, ggplot2::aes(x = .data[[col_y]])) +",
        "+ ",
        "        ggplot2::geom_density(fill = colors[[\"occ\"]], alpha = 0.6) +",
        "+ ",
        "        ggplot2::scale_x_continuous(limits = rng_y) +",
        "+ ",
        "        ggplot2::coord_flip() +",
        "+ ",
        "        ggplot2::scale_y_continuous(n.breaks = 3) +",
        "+ ",
        "        ggplot2::theme_minimal() +",
        "+ ",
        "        ggplot2::theme(",
        "+ ",
        "          axis.text.y  = ggplot2::element_blank(),",
        "+ ",
        "          axis.title.y = ggplot2::element_blank(),",
        "+ ",
        "          axis.title.x = ggplot2::element_blank(),",
        "+ ",
        "          axis.text.x  = ggplot2::element_text(size = 5)",
        "+ ",
        "        )",
        "+ ",
        "+ ",
        "      return_plot <- ggpubr::ggarrange(",
        "+ ",
        "        NULL,        env_y_top, env_z_top, NULL,",
        "+ ",
        "        x_name,      ell_y_x,   ell_z_x,   env_x_right,",
        "+ ",
        "        legend_plot, y_name,    ell_z_y,   env_y_right,",
        "+ ",
        "        NULL,        angle_warn, z_name,   NULL,",
        "+ ",
        "        ncol = 4, nrow = 4,",
        "+ ",
        "        widths  = c(0.1, 0.4, 0.4, 0.1),",
        "+ ",
        "        heights = c(0.1, 0.4, 0.4, 0.1)",
        "+ ",
        "      )",
        "+ ",
        "    }",
        "+ ",
        "  }",
        "+ ",
        "+ ",
        "  return(return_plot)",
        "+ ",
        "}",
        "> ",
        "plot_e_space(env_bg = env_stack_small, vs = vs_1)",
        "\u001BG3;No complete x, y, z specification provided. Using predictor columns inferred from 'env_bg': mean_temp, temp_seasonality, annual_precip\n\u001Bg\u001BG3;Using predictor columns: mean_temp, temp_seasonality, annual_precip\n\u001Bg\u001BG3;Sampling 10000 of 310771 rows from 'suitable_env' for plotting.\n\u001Bg\u001BG3;Sampling 10000 of 12412229 rows from 'env_bg' for plotting.\n\u001Bg",
        "\u001BG3;Restarting R session...\u001Bg"
    ]
}